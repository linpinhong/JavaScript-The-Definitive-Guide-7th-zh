[{"categories":null,"content":"JavaScript is the programming language of the web. The overwhelming majority of websites use JavaScript, and all modern web browsers—on desktops, tablets, and phones—include JavaScript interpreters, making JavaScript the most-deployed programming language in history. Over the last decade, Node.js has enabled JavaScript programming outside of web browsers, and the dramatic success of Node means that JavaScript is now also the most-used programming language among software developers. Whether you’re starting from scratch or are already using JavaScript professionally, this book will help you master the language. JavaScript 是 web 的编程语言。绝大多数的网站都使用 JavaScript，所有的现代网络浏览器——台式机、平板电脑和手机——都包括 JavaScript 解释器，这使得 JavaScript 成为历史上部署最多的编程语言。在过去的十年中，Node.js 使得 JavaScript 编程可以在 web 浏览器之外进行，Node 的巨大成功意味着 JavaScript 现在也是软件开发人员最常用的编程语言。无论你是从零开始还是已经开始专业地使用 JavaScript，这本书都会帮助你掌握这门语言。 If you are already familiar with other programming languages, it may help you to know that JavaScript is a high-level, dynamic, interpreted programming language that is well-suited to object-oriented and functional programming styles. JavaScript’s variables are untyped. Its syntax is loosely based on Java, but the languages are otherwise unrelated. JavaScript derives its first-class functions from Scheme and its prototype-based inheritance from the little-known language Self. But you do not need to know any of those languages, or be familiar with those terms, to use this book and learn JavaScript. 如果您已经熟悉了其他编程语言，那么了解 JavaScript 是一种高级的、动态的、解释的编程语言可能会对您有所帮助，它非常适合面向对象和函数式编程风格。JavaScript 的变量是无类型的。它的语法不严格地讲基于 Java，但是这两种语言在其他方面是无关的。JavaScript 的 first-class 类型函数衍生于 Scheme，从鲜为人知的 Self 继承基于原型的函数。但您不需要了解任何这些语言，或熟悉这些术语，以使用这本书和学习 JavaScript。 The name “JavaScript” is quite misleading. Except for a superficial syntactic resemblance, JavaScript is completely different from the Java programming language. And JavaScript has long since outgrown its scripting-language roots to become a robust and efficient general-purpose language suitable for serious software engineering and projects with huge codebases. “JavaScript”这个名称很容易引起误解。除了表面上的语法相似之外，JavaScript 与 Java 编程语言完全不同。而且 JavaScript 早已超越了它的脚本语言根基，成为一种健壮、高效的通用语言，适合于具有巨大代码库的严肃软件工程和项目。 JAVASCRIPT: NAMES, VERSIONS, AND MODES JavaScript was created at Netscape in the early days of the web, and technically, “JavaScript” is a trademark licensed from Sun Microsystems (now Oracle) used to describe Netscape’s (now Mozilla’s) implementation of the language. Netscape submitted the language for standardization to ECMA—the European Computer Manufacturer’s Association—and because of trademark issues, the standardized version of the language was stuck with the awkward name “ECMAScript.” In practice, everyone just calls the language JavaScript. This book uses the name “ECMAScript” and the abbreviation “ES” to refer to the language standard and to versions of that standard. JavaScript 是在网络早期由网景公司创建的，从技术上讲，“JavaScript”是 Sun Microsystems（现在的 Oracle）授权的商标，用来描述 Netscape 公司（现在的Mozilla 公司）对该语言的实现。Netscape 公司将这种语言提交给欧洲计算机制造商协会（ecma）进行标准化，但由于商标问题，这种语言的标准化版本只能使用一个尴尬的名字“ECMAScript”。实际上，每个人都称这种语言为 JavaScript。本书使用名称“ECMAScript”和缩写“ES”来表示该语言标准和该标准的版本。 For most of the 2010s, version 5 of the ECMAScript standard has been supported by all web browsers. This book treats ES5 as the compatibility baseline and no longer discusses earlier versions of the language. ES6 was released in 2015 and added major new features—including class and module syntax—that changed JavaScript from a scripting language into a serious, general-purpose language suitable for large-scale software engineering. Since ES6, the ECMAScript specification has moved to a yearly release cadence, and versions of the language—ES2016, ES2017, ES2018, ES2019, and ES2020—are now identified by year of release. 对于2010年代的大多数版本，所有 web 浏览器都支持 ECMAScript 标准的第5版。本书将 ES5 作为兼容性基线，不再讨论该语言的早期版本。ES6 于2015年发布，增加了主要的新特性（包括类和模块语法），使 JavaScript 从一种脚本语言变成了一种严肃的、适用于大规模软件工程的通用语言。自 ES6 以来，ECMAScript 规范已经以每年发布一次为基调，该语言的版本——es2016、ES20","date":"2020-11-02","objectID":"/posts/ch1/:0:0","tags":null,"title":"第 1 章 JavaScript 概述","uri":"/posts/ch1/"},{"categories":null,"content":"1.1 Exploring JavaScript When learning a new programming language, it’s important to try the examples in the book, then modify them and try them again to test your understanding of the language. To do that, you need a JavaScript interpreter. 在学习一门新的编程语言时，试一试书中的示例是很重要的，然后修改它们，再试一次来测试你对这门语言的理解。为此，需要一个 JavaScript 解释器。 The easiest way to try out a few lines of JavaScript is to open up the web developer tools in your web browser (with F12, Ctrl-Shift-I, or Command-Option-I) and select the Console tab. You can then type code at the prompt and see the results as you type. Browser developer tools often appear as panes at the bottom or right of the browser window, but you can usually detach them as separate windows (as pictured in Figure 1-1), which is often quite convenient. 尝试几行 JavaScript 的最简单方法是在web浏览器中打开 web developer 工具（使用 F12、Ctrl-Shift-I 或 Command-Option-I）并选择 Console 选项卡。然后可以在提示符处键入代码，并在键入时查看结果。浏览器开发人员工具通常以窗格的形式出现在浏览器窗口的底部或右侧，但是您通常可以将它们分离为单独的窗口（如图1-1所示），这通常非常方便。 The JavaScript console in Firefox’s Developer ToolsAnother way to try out JavaScript code is to download and install Node from https://nodejs.org. Once Node is installed on your system, you can simply open a Terminal window and type node to begin an interactive JavaScript session like this one: 另一种尝试 JavaScript 代码的方法是从https://nodejs.org下载并安装 Node。一旦在你的系统上安装了 Node，你可以简单地打开一个终端窗口，输入 Node 来开始一个交互式的 JavaScript 会话，就像这样： $ node Welcome to Node.js v12.13.0. Type \".help\" for more information. \u003e .help .break Sometimes you get stuck, this gets you out .clear Alias for .break .editor Enter editor mode .exit Exit the repl .help Print this help message .load Load JS from a file into the REPL session .save Save all evaluated commands in this REPL session to a file Press ^C to abort current expression, ^D to exit the repl \u003e let x = 2, y = 3; undefined \u003e x + y 5 \u003e (x === 2) \u0026\u0026 (y === 3) true \u003e (x \u003e 3) || (y \u003c 3) false ","date":"2020-11-02","objectID":"/posts/ch1/:1:0","tags":null,"title":"第 1 章 JavaScript 概述","uri":"/posts/ch1/"},{"categories":null,"content":"1.2 Hello World When you are ready to start experimenting with longer chunks of code, these line-by-line interactive environments may no longer be suitable, and you will probably prefer to write your code in a text editor. From there, you can copy and paste to the JavaScript console or into a Node session. Or you can save your code to a file (the traditional filename extension for JavaScript code is .js) and then run that file of JavaScript code with Node: 当您准备开始尝试更长的代码块时，这些逐行交互环境可能不再适合，您可能更喜欢在文本编辑器中编写代码。从那里，您可以复制并粘贴到JavaScript控制台或节点会话中。或者你可以将你的代码保存到一个文件中（传统的 JavaScript 代码的文件名扩展名是 .js），然后用 Node 运行该 JavaScript 代码文件: $ node snippet.js If you use Node in a noninteractive manner like this, it won’t automatically print out the value of all the code you run, so you’ll have to do that yourself. You can use the function console.log() to display text and other JavaScript values in your terminal window or in a browser’s developer tools console. So, for example, if you create a hello.js file containing this line of code: 如果像这样以非交互的方式使用 Node，它不会自动打印出您运行的所有代码的值，因此您必须自己执行。可以使用 console.log() 函数在终端窗口或浏览器的 developer tools 控制台中显示文本和其他 JavaScript 值。因此，例如，如果你创建一个 hello.js 文件，其中包含这行代码: console.log(\"Hello World!\"); and execute the file with node hello.js, you’ll see the message “Hello World!” printed out. 并执行 node hello.js ，你会看到消息“Hello World!”打印出来。 If you want to see that same message printed out in the JavaScript console of a web browser, create a new file named hello.html, and put this text in it: 如果您想在 web 浏览器的 JavaScript 控制台中看到同样的消息打印出来，那么创建一个名为 hello.html 的文件，并把这段文字放进去： \u003cscript src=\"hello.js\"\u003e\u003c/script\u003e Then load hello.html into your web browser using a file:// URL like this one: 然后使用 file:// URL将 hello.html 加载到浏览器中，如下图所示： file:///Users/username/javascript/hello.html Open the developer tools window to see the greeting in the console. 打开 developer tools 窗口，在控制台中查看问候语。 ","date":"2020-11-02","objectID":"/posts/ch1/:2:0","tags":null,"title":"第 1 章 JavaScript 概述","uri":"/posts/ch1/"},{"categories":null,"content":"1.3 A Tour of JavaScript This section presents a quick introduction, through code examples, to the JavaScript language. After this introductory chapter, we dive into JavaScript at the lowest level: Chapter 2 explains things like JavaScript comments, semicolons, and the Unicode character set. Chapter 3 starts to get more interesting: it explains JavaScript variables and the values you can assign to those variables. 本节通过代码示例快速介绍 JavaScript 语言。在这一介绍性章节之后，我们将深入到 JavaScript 的底层:第 2 章说明了 JavaScript 注释、分号和 Unicode 字符集等内容。第 3 章开始变得更有趣：它说明了 JavaScript 变量和你可以为这些变量赋值的值。 Here’s some sample code to illustrate the highlights of those two chapters: 下面是一些示例代码，演示这两章的重点内容： // Anything following double slashes is an English-language comment. // Read the comments carefully: they explain the JavaScript code. // A variable is a symbolic name for a value. // Variables are declared with the let keyword: let x; // Declare a variable named x. // Values can be assigned to variables with an = sign x = 0; // Now the variable x has the value 0 x // =\u003e 0: A variable evaluates to its value. // JavaScript supports several types of values x = 1; // Numbers. x = 0.01; // Numbers can be integers or reals. x = \"hello world\"; // Strings of text in quotation marks. x = 'JavaScript'; // Single quote marks also delimit strings. x = true; // A Boolean value. x = false; // The other Boolean value. x = null; // Null is a special value that means \"no value.\" x = undefined; // Undefined is another special value like null. Two other very important types that JavaScript programs can manipulate are objects and arrays. These are the subjects of Chapters 6 and 7, but they are so important that you’ll see them many times before you reach those chapters: JavaScript 程序可以操作的另外两种非常重要的类型是对象和数组。这些是第 6 章和第 7 章的主题，但它们非常重要，在你读到这些章节之前，你会多次看到它们： // JavaScript's most important datatype is the object. // An object is a collection of name/value pairs, or a string to value map. let book = { // Objects are enclosed in curly braces. topic: \"JavaScript\", // The property \"topic\" has value \"JavaScript.\" edition: 7 // The property \"edition\" has value 7 }; // The curly brace marks the end of the object. // Access the properties of an object with . or []: book.topic // =\u003e \"JavaScript\" book[\"edition\"] // =\u003e 7: another way to access property values. book.author = \"Flanagan\"; // Create new properties by assignment. book.contents = {}; // {} is an empty object with no properties. // Conditionally access properties with ?. (ES2020): book.contents?.ch01?.sect1 // =\u003e undefined: book.contents has no ch01 property. // JavaScript also supports arrays (numerically indexed lists) of values: let primes = [2, 3, 5, 7]; // An array of 4 values, delimited with [ and ]. primes[0] // =\u003e 2: the first element (index 0) of the array. primes.length // =\u003e 4: how many elements in the array. primes[primes.length-1] // =\u003e 7: the last element of the array. primes[4] = 9; // Add a new element by assignment. primes[4] = 11; // Or alter an existing element by assignment. let empty = []; // [] is an empty array with no elements. empty.length // =\u003e 0 // Arrays and objects can hold other arrays and objects: let points = [ // An array with 2 elements. {x: 0, y: 0}, // Each element is an object. {x: 1, y: 1} ]; let data = { // An object with 2 properties trial1: [[1,2], [3,4]], // The value of each property is an array. trial2: [[2,3], [4,5]] // The elements of the arrays are arrays. }; COMMENT SYNTAX IN CODE EXAMPLES You may have noticed in the preceding code that some of the comments begin with an arrow (=\u003e). These show the value produced by the code before the comment and are my attempt to emulate an interactive JavaScript environment like a web browser console in a printed book. 您可能已经注意到，在前面的代码中，一些注释以箭头开头（=\u003e）。这些代码显示了注释之前代码产生的值，我试图模拟交互式 JavaScript 环境，就像印刷书籍中的 web 浏览器控制台一样。 Those // =\u003e comments also serve as an assertion, and I’ve written a tool that tests the code and verifies that it produces the value specified in the comment. Th","date":"2020-11-02","objectID":"/posts/ch1/:3:0","tags":null,"title":"第 1 章 JavaScript 概述","uri":"/posts/ch1/"},{"categories":null,"content":"1.4 Example: Character Frequency Histograms This chapter concludes with a short but nontrivial JavaScript program. Example 1-1 is a Node program that reads text from standard input, computes a character frequency histogram from that text, and then prints out the histogram. You could invoke the program like this to analyze the character frequency of its own source code: 本章以一个简短但不平凡的 JavaScript 程序结束。示例 1-1 是一个节点程序，它从标准输入中读取文本，根据文本计算字符频率直方图，然后打印该直方图。你可以调用这样的程序来分析字符频率自己的源代码： $ node charfreq.js \u003c charfreq.js T: ########### 11.22% E: ########## 10.15% R: ####### 6.68% S: ###### 6.44% A: ###### 6.16% N: ###### 5.81% O: ##### 5.45% I: ##### 4.54% H: #### 4.07% C: ### 3.36% L: ### 3.20% U: ### 3.08% /: ### 2.88% This example uses a number of advanced JavaScript features and is intended to demonstrate what real-world JavaScript programs can look like. You should not expect to understand all of the code yet, but be assured that all of it will be explained in the chapters that follow. 这个示例使用了许多高级 JavaScript 特性，旨在演示真实的 JavaScript 程序是什么样的。你不应该期望理解所有的代码，但是要确保所有的代码将在下面的章节中被解释。 Example 1-1. Computing character frequency histograms with JavaScript /** * This Node program reads text from standard input, computes the frequency * of each letter in that text, and displays a histogram of the most * frequently used characters. It requires Node 12 or higher to run. * * In a Unix-type environment you can invoke the program like this: * node charfreq.js \u003c corpus.txt */ // This class extends Map so that the get() method returns the specified // value instead of null when the key is not in the map class DefaultMap extends Map { constructor(defaultValue) { super(); // Invoke superclass constructor this.defaultValue = defaultValue; // Remember the default value } get(key) { if (this.has(key)) { // If the key is already in the map return super.get(key); // return its value from superclass. } else { return this.defaultValue; // Otherwise return the default value } } } // This class computes and displays letter frequency histograms class Histogram { constructor() { this.letterCounts = new DefaultMap(0); // Map from letters to counts this.totalLetters = 0; // How many letters in all } // This function updates the histogram with the letters of text. add(text) { // Remove whitespace from the text, and convert to upper case text = text.replace(/\\s/g, \"\").toUpperCase(); // Now loop through the characters of the text for(let character of text) { let count = this.letterCounts.get(character); // Get old count this.letterCounts.set(character, count+1); // Increment it this.totalLetters++; } } // Convert the histogram to a string that displays an ASCII graphic toString() { // Convert the Map to an array of [key,value] arrays let entries = [...this.letterCounts]; // Sort the array by count, then alphabetically entries.sort((a,b) =\u003e { // A function to define sort order. if (a[1] === b[1]) { // If the counts are the same return a[0] \u003c b[0] ? -1 : 1; // sort alphabetically. } else { // If the counts differ return b[1] - a[1]; // sort by largest count. } }); // Convert the counts to percentages for(let entry of entries) { entry[1] = entry[1] / this.totalLetters*100; } // Drop any entries less than 1% entries = entries.filter(entry =\u003e entry[1] \u003e= 1); // Now convert each entry to a line of text let lines = entries.map( ([l,n]) =\u003e `${l}: ${\"#\".repeat(Math.round(n))}${n.toFixed(2)}%` ); // And return the concatenated lines, separated by newline characters. return lines.join(\"\\n\"); } } // This async (Promise-returning) function creates a Histogram object, // asynchronously reads chunks of text from standard input, and adds those chunks to // the histogram. When it reaches the end of the stream, it returns this histogram async function histogramFromStdin() { process.stdin.setEncoding(\"utf-8\"); // Read Unicode strings, not bytes let histogram = new Histogram(); for await (let chunk of process.stdin) { histogram.add(chunk); } return histogram; } // This one final line of code is the","date":"2020-11-02","objectID":"/posts/ch1/:4:0","tags":null,"title":"第 1 章 JavaScript 概述","uri":"/posts/ch1/"},{"categories":null,"content":"1.5 Summary This book explains JavaScript from the bottom up. This means that we start with low-level details like comments, identifiers, variables, and types; then build to expressions, statements, objects, and functions; and then cover high-level language abstractions like classes and modules. I take the word definitive in the title of this book seriously, and the coming chapters explain the language at a level of detail that may feel off-putting at first. True mastery of JavaScript requires an understanding of the details, however, and I hope that you will make time to read this book cover to cover. But please don’t feel that you need to do that on your first reading. If you find yourself feeling bogged down in a section, simply skip to the next. You can come back and master the details once you have a working knowledge of the language as a whole. 这本书从下至上地说明了 JavaScript。这意味着我们从底层细节开始，比如注释、标识符、变量和类型；然后构建表达式、语句、对象和函数；然后介绍高级语言抽象，比如类和模块。我在这本书的标题中认真地使用了“权威”这个词，接下来的章节会详细地解释这种语言，一开始可能会让人感到不快。然而，真正掌握 JavaScript 需要了解细节，我希望您能抽出时间从头到尾阅读这本书。但请不要觉得在第一次阅读时就需要这样做。如果你发现自己在某个章节陷入困境，直接跳到下一个章节。一旦你对语言有了整体的应用知识，你可以回过头来掌握细节。 ","date":"2020-11-02","objectID":"/posts/ch1/:5:0","tags":null,"title":"第 1 章 JavaScript 概述","uri":"/posts/ch1/"},{"categories":null,"content":"The lexical structure of a programming language is the set of elementary rules that specifies how you write programs in that language. It is the lowest-level syntax of a language: it specifies what variable names look like, the delimiter characters for comments, and how one program statement is separated from the next, for example. This short chapter documents the lexical structure of JavaScript. It covers: 编程语言的词法结构是一组基本规则，用于指定如何用该语言编写程序。它是一种语言的最低层次语法：例如，它指定变量名的样子，注释的分隔符字符，以及一个程序语句如何与下一个程序语句分隔。这个简短的章节描述了 JavaScript 的词法结构。它涵盖了： Case sensitivity, spaces, and line breaks Comments Literals Identifiers and reserved words Unicode Optional semicolons ","date":"2020-11-02","objectID":"/posts/ch2/:0:0","tags":null,"title":"第 2 章 词法结构","uri":"/posts/ch2/"},{"categories":null,"content":"2.1 The Text of a JavaScript Program JavaScript is a case-sensitive language. This means that language keywords, variables, function names, and other identifiers must always be typed with a consistent capitalization of letters. The while keyword, for example, must be typed “while,” not “While” or “WHILE.” Similarly, online, Online, OnLine, and ONLINE are four distinct variable names. JavaScript 是一种区分大小写的语言。这意味着语言关键字、变量、函数名和其他标识符必须始终以一致的大小写输入。例如，while 关键字必须输入“while”，而不是“While”或“WHILE”。同样，online, Online，OnLine 和 ONLINE 是四个不同的变量名。 JavaScript ignores spaces that appear between tokens in programs. For the most part, JavaScript also ignores line breaks (but see §2.6 for an exception). Because you can use spaces and newlines freely in your programs, you can format and indent your programs in a neat and consistent way that makes the code easy to read and understand. JavaScript 忽略程序中标记之间出现的空格。在大多数情况下，JavaScript 也会忽略换行符（但是，关于一个例外，请参阅 §2.6）。由于您可以在程序中自由地使用空格和换行符，因此您可以以一种整洁和一致的方式对程序进行格式化和缩进，从而使代码易于阅读和理解。 In addition to the regular space character (\\u0020), JavaScript also recognizes tabs, assorted ASCII control characters, and various Unicode space characters as whitespace. JavaScript recognizes newlines, carriage returns, and a carriage return/line feed sequence as line terminators. 除了常规的空格字符（\\u0020）之外，JavaScript 还将制表符、各种 ASCII 控制字符和各种 Unicode 空格字符识别为空格。JavaScript 识别换行符、回车符和回车/换行序列作为行结束符。 ","date":"2020-11-02","objectID":"/posts/ch2/:1:0","tags":null,"title":"第 2 章 词法结构","uri":"/posts/ch2/"},{"categories":null,"content":"2.2 Comments JavaScript supports two styles of comments. Any text between a // and the end of a line is treated as a comment and is ignored by JavaScript. Any text between the characters /* and */ is also treated as a comment; these comments may span multiple lines but may not be nested. The following lines of code are all legal JavaScript comments: JavaScript 支持两种风格的注释。在 // 和行尾之间的任何文本都被 JavaScript 视为注释并被忽略。字符 /* 和 */ 之间的任何文本也被视为注释；这些注释可能跨越多行，但可能不是嵌套的。下面几行代码都是合法的 JavaScript 注释： // This is a single-line comment. /* This is also a comment */ // and here is another comment. /* * This is a multi-line comment. The extra * characters at the start of * each line are not a required part of the syntax; they just look cool! */ ","date":"2020-11-02","objectID":"/posts/ch2/:2:0","tags":null,"title":"第 2 章 词法结构","uri":"/posts/ch2/"},{"categories":null,"content":"2.3 Literals A literal is a data value that appears directly in a program. The following are all literals: 字面量是直接出现在程序中的数据值。以下都是字面量： 12 // The number twelve 1.2 // The number one point two \"hello world\" // A string of text 'Hi' // Another string true // A Boolean value false // The other Boolean value null // Absence of an object Complete details on numeric and string literals appear in Chapter 3. 数值和字符串字面量的完整细节出现在第 3 章。 ","date":"2020-11-02","objectID":"/posts/ch2/:3:0","tags":null,"title":"第 2 章 词法结构","uri":"/posts/ch2/"},{"categories":null,"content":"2.4 Identifiers and Reserved Words An identifier is simply a name. In JavaScript, identifiers are used to name constants, variables, properties, functions, and classes and to provide labels for certain loops in JavaScript code. A JavaScript identifier must begin with a letter, an underscore (_), or a dollar sign ($). Subsequent characters can be letters, digits, underscores, or dollar signs. (Digits are not allowed as the first character so that JavaScript can easily distinguish identifiers from numbers.) These are all legal identifiers: 标识符只是一个名称。在 JavaScript 中，标识符用于命名常量、变量、属性、函数和类，并为 JavaScript 代码中的某些循环提供标签。JavaScript 标识符必须以字母、下划线（_）或美元符号（$）开头。后面的字符可以是字母、数字、下划线或美元符号。（数字不允许作为第一个字符，这样 JavaScript 可以很容易地将标识符与数字区分开来。）这些都是合法的标识符： i my_variable_name v13 _dummy $str Like any language, JavaScript reserves certain identifiers for use by the language itself. These “reserved words” cannot be used as regular identifiers. They are listed in the next section. 与任何语言一样，JavaScript 保留某些标识符供语言本身使用。这些“保留字”不能用作常规标识符。它们将在下一节中列出。 ","date":"2020-11-02","objectID":"/posts/ch2/:4:0","tags":null,"title":"第 2 章 词法结构","uri":"/posts/ch2/"},{"categories":null,"content":"2.4.1 Reserved Words The following words are part of the JavaScript language. Many of these (such as if, while, and for) are reserved keywords that must not be used as the names of constants, variables, functions, or classes (though they can all be used as the names of properties within an object). Others (such as from, of, get, and set) are used in limited contexts with no syntactic ambiguity and are perfectly legal as identifiers. Still other keywords (such as let) can’t be fully reserved in order to retain backward compatibility with older programs, and so there are complex rules that govern when they can be used as identifiers and when they cannot. (let can be used as a variable name if declared with var outside of a class, for example, but not if declared inside a class or with const.) The simplest course is to avoid using any of these words as identifiers, except for from, set, and target, which are safe to use and are already in common use. 下面的单词是 JavaScript 语言的一部分。其中许多（如 if、while 和 for）是保留的关键字，不能用作常量、变量、函数或类的名称（尽管它们都可以用作对象中的属性名称）。其他的（如 from、of、get 和 set）则在有限的上下文中使用，没有语法歧义，作为标识符完全合法。还有一些关键字（比如let）不能被完全保留，以保持与旧程序的向后兼容性，因此有复杂的规则来管理何时可以将它们用作标识符，何时不能。（例如，如果在类外部用 var 声明，let 就可以用作变量名，但如果在类内部或用 const 声明，let 就不能用作变量名。）最简单的方法是避免使用这些词作为标识符，除了 from、set 和 target 之外，这些词使用起来很安全，而且已经很常用了。 as const export get null target void async continue extends if of this while await debugger false import return throw with break default finally in set true yield case delete for instanceof static try catch do from let super typeof class else function new switch var JavaScript also reserves or restricts the use of certain keywords that are not currently used by the language but that might be used in future versions: JavaScript 还保留或限制使用某些关键字，目前没有使用的语言，但可能会在未来的版本： enum implements interface package private protected public For historical reasons, arguments and eval are not allowed as identifiers in certain circumstances and are best avoided entirely. 由于历史原因，参数和 eval 在某些情况下不允许作为标识符，最好完全避免使用。 ","date":"2020-11-02","objectID":"/posts/ch2/:4:1","tags":null,"title":"第 2 章 词法结构","uri":"/posts/ch2/"},{"categories":null,"content":"2.5 Unicode JavaScript programs are written using the Unicode character set, and you can use any Unicode characters in strings and comments. For portability and ease of editing, it is common to use only ASCII letters and digits in identifiers. But this is a programming convention only, and the language allows Unicode letters, digits, and ideographs (but not emojis) in identifiers. This means that programmers can use mathematical symbols and words from non-English languages as constants and variables: JavaScript 程序是使用 Unicode 字符集编写的，您可以在字符串和注释中使用任何 Unicode 字符。为了便于移植和编辑，通常在标识符中只使用 ASCII 字母和数字。但这只是一种编程约定，该语言允许在标识符中使用 Unicode 字母、数字和表意文字（但不允许使用表情符号）。这意味着程序员可以使用来自非英语语言的数学符号和单词作为常量和变量： const π = 3.14; const sí = true; ","date":"2020-11-02","objectID":"/posts/ch2/:5:0","tags":null,"title":"第 2 章 词法结构","uri":"/posts/ch2/"},{"categories":null,"content":"2.5.1 Unicode Escape Sequences Some computer hardware and software cannot display, input, or correctly process the full set of Unicode characters. To support programmers and systems using older technology, JavaScript defines escape sequences that allow us to write Unicode characters using only ASCII characters. These Unicode escapes begin with the characters \\u and are either followed by exactly four hexadecimal digits (using uppercase or lowercase letters A–F) or by one to six hexadecimal digits enclosed within curly braces. These Unicode escapes may appear in JavaScript string literals, regular expression literals, and identifiers (but not in language keywords). The Unicode escape for the character “é,” for example, is \\u00E9; here are three different ways to write a variable name that includes this character: 一些计算机硬件和软件不能显示、输入或正确处理完整的 Unicode 字符集。为了支持使用较旧技术的程序员和系统，JavaScript 定义了转义序列，允许我们仅使用 ASCII 字符编写 Unicode 字符。这些 Unicode 转义以字符 \\u 开始，后跟四个十六进制数字（使用大写或小写字母A-F），或者用大括号括起来的一到六个十六进制数字。这些 Unicode 转义可能以 JavaScript 字符串、正则表达式和标识符的形式出现（但不会以语言关键字的形式出现）。例如，Unicode 字符 “é,” 的转义是\\u00E9；这里有三种不同的方式来写一个变量名，包括这个字符： let café = 1; // Define a variable using a Unicode character caf\\u00e9 // =\u003e 1; access the variable using an escape sequence caf\\u{E9} // =\u003e 1; another form of the same escape sequence Early versions of JavaScript only supported the four-digit escape sequence. The version with curly braces was introduced in ES6 to better support Unicode codepoints that require more than 16 bits, such as emoji: 早期版本的 JavaScript 只支持四位数转义序列。带花括号的版本是在 ES6 中引入的，目的是为了更好地支持需要超过16位元的 Unicode 码点，比如表情符号: console.log(\"\\u{1F600}\"); // Prints a smiley face emoji Unicode escapes may also appear in comments, but since comments are ignored, they are simply treated as ASCII characters in that context and not interpreted as Unicode. Unicode 转义也可能出现在注释中，但是由于注释被忽略，因此它们在该上下文中只是作为 ASCII 字符处理，而不是解释为 Unicode。 ","date":"2020-11-02","objectID":"/posts/ch2/:5:1","tags":null,"title":"第 2 章 词法结构","uri":"/posts/ch2/"},{"categories":null,"content":"2.5.2 Unicode Normalization If you use non-ASCII characters in your JavaScript programs, you must be aware that Unicode allows more than one way of encoding the same character. The string “é,” for example, can be encoded as the single Unicode character \\u00E9 or as a regular ASCII “e” followed by the acute accent combining mark \\u0301. These two encodings typically look exactly the same when displayed by a text editor, but they have different binary encodings, meaning that they are considered different by JavaScript, which can lead to very confusing programs: 如果在 JavaScript 程序中使用非 ASCII 字符，则必须知道 Unicode 允许对同一字符进行多种编码方式。例如，字符串 “é,” 可以编码为单个Unicode字符 \\u00E9，或编码为后面跟着急性重音组合标记 \\u0301 的正则ASCII “e”。这两种编码在文本编辑器中显示时看起来是完全一样的，但是它们有不同的二进制编码，这意味着它们被 JavaScript 认为是不同的，这可能会导致非常混乱的程序: const café = 1; // This constant is named \"caf\\u{e9}\" const café = 2; // This constant is different: \"cafe\\u{301}\" café // =\u003e 1: this constant has one value café // =\u003e 2: this indistinguishable constant has a different value The Unicode standard defines the preferred encoding for all characters and specifies a normalization procedure to convert text to a canonical form suitable for comparisons. JavaScript assumes that the source code it is interpreting has already been normalized and does not do any normalization on its own. If you plan to use Unicode characters in your JavaScript programs, you should ensure that your editor or some other tool performs Unicode normalization of your source code to prevent you from ending up with different but visually indistinguishable identifiers. Unicode 标准定义了所有字符的首选编码，并指定了将文本转换为适合于比较的规范形式的标准化过程。JavaScript 假设它要解释的源代码已经被规范化了，它自己不做任何规范化。如果您计划在 JavaScript 程序中使用 Unicode 字符，那么应该确保您的编辑器或其他工具对源代码执行 Unicode 规范化，以防止出现不同但视觉上无法区分的标识符。 ","date":"2020-11-02","objectID":"/posts/ch2/:5:2","tags":null,"title":"第 2 章 词法结构","uri":"/posts/ch2/"},{"categories":null,"content":"2.6 Optional Semicolons Like many programming languages, JavaScript uses the semicolon (;) to separate statements (see Chapter 5) from one another. This is important for making the meaning of your code clear: without a separator, the end of one statement might appear to be the beginning of the next, or vice versa. In JavaScript, you can usually omit the semicolon between two statements if those statements are written on separate lines. (You can also omit a semicolon at the end of a program or if the next token in the program is a closing curly brace: }.) Many JavaScript programmers (and the code in this book) use semicolons to explicitly mark the ends of statements, even where they are not required. Another style is to omit semicolons whenever possible, using them only in the few situations that require them. Whichever style you choose, there are a few details you should understand about optional semicolons in JavaScript. 像许多编程语言一样，JavaScript 使用分号（;）来分隔语句（参见第 5 章）。这对于明确代码的含义非常重要：如果没有分隔符，一条语句的结尾可能会是下一条语句的开始，反之亦然。在 JavaScript 中，如果两个语句写在不同的行上，通常可以省略这两个语句之间的分号。（如果程序的下一个标记是右花括号 }，也可以省略在程序末尾的分号。）许多 JavaScript 程序员（以及本书中的代码）使用分号来显式地标记语句的结束，即使在不需要分号的地方也是如此。另一种风格是尽可能省略分号，只在少数需要分号的情况下使用。无论您选择哪种样式，关于 JavaScript 中的可选分号，您都应该了解一些细节。 Consider the following code. Since the two statements appear on separate lines, the first semicolon could be omitted: 考虑下面的代码。由于这两个语句出现在不同的行中，第一个分号可以省略： a = 3; b = 4; Written as follows, however, the first semicolon is required: 但是，如写如下，第一个分号是必需的: a = 3; b = 4; Note that JavaScript does not treat every line break as a semicolon: it usually treats line breaks as semicolons only if it can’t parse the code without adding an implicit semicolon. More formally (and with three exceptions described a bit later), JavaScript treats a line break as a semicolon if the next nonspace character cannot be interpreted as a continuation of the current statement. Consider the following code: 请注意，JavaScript 并不把每个断行符都当作分号来处理：它通常只在不添加隐式分号而无法解析代码时才把断行符当作分号来处理。更正式的说法是，如果下一个非空格字符不能解释为当前语句的延续，JavaScript将换行符视为分号。考虑以下代码: let a a = 3 console.log(a) JavaScript interprets this code like this: JavaScript 这样解释这段代码： let a; a = 3; console.log(a); JavaScript does treat the first line break as a semicolon because it cannot parse the code let a a without a semicolon. The second a could stand alone as the statement a;, but JavaScript does not treat the second line break as a semicolon because it can continue parsing the longer statement a = 3;. JavaScript 确实把第一个换行符当作分号，因为它不能解析没有分号的代码。第二个 a 可以单独作为语句 a;，但 JavaScript 不会将第二个换行符作为分号处理，因为它可以继续解析较长的语句 a = 3;。 These statement termination rules lead to some surprising cases. This code looks like two separate statements separated with a newline: 这些语句终止规则会导致一些奇怪的情况。这段代码看起来像用换行符分隔的两个单独的语句： let y = x + f (a+b).toString() But the parentheses on the second line of code can be interpreted as a function invocation of f from the first line, and JavaScript interprets the code like this: 但是第二行括号可以解释为第一行 f 的函数调用，JavaScript 是这样解释的： let y = x + f(a+b).toString(); More likely than not, this is not the interpretation intended by the author of the code. In order to work as two separate statements, an explicit semicolon is required in this case. 很可能，这不是代码作者想要的解释。为了作为两个独立的语句工作，在这种情况下需要显式的分号。 In general, if a statement begins with (, [, /, +, or -, there is a chance that it could be interpreted as a continuation of the statement before. Statements beginning with /, +, and - are quite rare in practice, but statements beginning with ( and [ are not uncommon at all, at least in some styles of JavaScript programming. Some programmers like to put a defensive semicolon at the beginning of any such statement so that it will continue to work correctly even if the statement before it is modified and a previously terminating semicolon removed: 通常，如果一个语句以 (、[、/、+ 或 - 开头，那么它有可能被解释为之前语句的延续。在实践中，以 /、+ 和 - 开头的语句非常少见，但是以 ( 和 [ 开头的语句并不少见，至少在某些 JavaScript 编程风格中是这样的。一些程序员喜欢在任何这样的语句的开头放一个防御分号，这样即使在修改之前的语句和删除之前的终止分号时，它也能继续正确工作: let x = 0 // Semicolon","date":"2020-11-02","objectID":"/posts/ch2/:6:0","tags":null,"title":"第 2 章 词法结构","uri":"/posts/ch2/"},{"categories":null,"content":"2.7 Summary This chapter has shown how JavaScript programs are written at the lowest level. The next chapter takes us one step higher and introduces the primitive types and values (numbers, strings, and so on) that serve as the basic units of computation for JavaScript programs. 本章展示了 JavaScript 程序是如何在底层编写的。下一章将进一步介绍作为 JavaScript 程序基本计算单元的基本类型和值（数字、字符串等）。 ","date":"2020-11-02","objectID":"/posts/ch2/:7:0","tags":null,"title":"第 2 章 词法结构","uri":"/posts/ch2/"},{"categories":null,"content":"Computer programs work by manipulating values, such as the number 3.14 or the text “Hello World.” The kinds of values that can be represented and manipulated in a programming language are known as types, and one of the most fundamental characteristics of a programming language is the set of types it supports. When a program needs to retain a value for future use, it assigns the value to (or “stores” the value in) a variable. Variables have names, and they allow use of those names in our programs to refer to values. The way that variables work is another fundamental characteristic of any programming language. This chapter explains types, values, and variables in JavaScript. It begins with an overview and some definitions. 计算机程序通过处理数值来工作，比如数字 3.14 或文本“Hello World”。在编程语言中可以表示和操作的值的种类称为类型，而编程语言最基本的特征之一就是它所支持的类型集。当程序需要保留一个值以供将来使用时，它将该值赋给（或将该值“存储”在）一个变量。变量有名称，它们允许在程序中使用这些名称来引用值。变量工作的方式是任何编程语言的另一个基本特征。本章解释了 JavaScript 中的类型、值和变量。它以概述和一些定义开始。 ","date":"2020-11-02","objectID":"/posts/ch3/:0:0","tags":null,"title":"第 3 章 类型、值和变量","uri":"/posts/ch3/"},{"categories":null,"content":"3.1 Overview and Definitions JavaScript types can be divided into two categories: primitive types and object types. JavaScript’s primitive types include numbers, strings of text (known as strings), and Boolean truth values (known as booleans). A significant portion of this chapter is dedicated to a detailed explanation of the numeric (§3.2) and string (§3.3) types in JavaScript. Booleans are covered in §3.4. JavaScript 类型可以分为两类：基本类型和对象类型。JavaScript 的基本类型包括数字、文本字符串（称为字符串）和布尔真实性值（称为布尔值）。这一章的重要部分是专门详细解释 JavaScript 中的数字（§3.2）和字符串（§3.3）类型。在 §3.4 中介绍了布尔值。 The special JavaScript values null and undefined are primitive values, but they are not numbers, strings, or booleans. Each value is typically considered to be the sole member of its own special type. §3.5 has more about null and undefined. ES6 adds a new special-purpose type, known as Symbol, that enables the definition of language extensions without harming backward compatibility. Symbols are covered briefly in §3.6. 特殊的 JavaScript 值 null 和 undefined 是基本值，但它们不是数字、字符串或布尔值。每个值通常被认为是它自己特殊类型的唯一成员。§3.5 有更多关于 null 和 undefined 的内容。ES6 添加了一种新的特殊用途类型，称为 Symbol，它支持在不损害向后兼容性的情况下定义语言扩展。符号在§3.6中有简要介绍。 Any JavaScript value that is not a number, a string, a boolean, a symbol, null, or undefined is an object. An object (that is, a member of the type object) is a collection of properties where each property has a name and a value (either a primitive value or another object). One very special object, the global object, is covered in §3.7, but more general and more detailed coverage of objects is in Chapter 6. 任何不是数字、字符串、布尔值、Symbol、null 或 undefined 的 JavaScript 值都是对象。对象（即类型对象的成员）是属性的集合，其中每个属性都有一个名称和一个值（原始值或另一个对象）。一个非常特殊的对象，全局对象，在 §3.7 中介绍过了，但是在第 6 章中对对象进行了更广泛、更详细的介绍。 An ordinary JavaScript object is an unordered collection of named values. The language also defines a special kind of object, known as an array, that represents an ordered collection of numbered values. The JavaScript language includes special syntax for working with arrays, and arrays have some special behavior that distinguishes them from ordinary objects. Arrays are the subject of Chapter 7. 普通的 JavaScript 对象是命名值的无序集合。该语言还定义了一种特殊类型的对象，称为数组，它表示编号值的有序集合。JavaScript 语言包含处理数组的特殊语法，数组有一些特殊的行为将它们与普通对象区分开来。数组是第 7 章的主题。 In addition to basic objects and arrays, JavaScript defines a number of other useful object types. A Set object represents a set of values. A Map object represents a mapping from keys to values. Various “typed array” types facilitate operations on arrays of bytes and other binary data. The RegExp type represents textual patterns and enables sophisticated matching, searching, and replacing operations on strings. The Date type represents dates and times and supports rudimentary date arithmetic. Error and its subtypes represent errors that can arise when executing JavaScript code. All of these types are covered in Chapter 11. 除了基本对象和数组之外，JavaScript 还定义了许多其他有用的对象类型。Set 对象表示一组值。Map 对象表示从键到值的映射。各种“类型化数组”类型促进了对字节数组和其他二进制数据的操作。RegExp 类型表示文本模式，支持对字符串进行复杂的匹配、搜索和替换操作。Date 类型表示日期和时间，并支持基本的日期运算。Error 及其子类型表示在执行 JavaScript 代码时可能出现的错误。所有这些类型都在第 11 章中介绍。 JavaScript differs from more static languages in that functions and classes are not just part of the language syntax: they are themselves values that can be manipulated by JavaScript programs. Like any JavaScript value that is not a primitive value, functions and classes are a specialized kind of object. They are covered in detail in Chapters 8 and 9. JavaScript 与更静态的语言的不同之处在于，函数和类不仅仅是语言语法的一部分：它们本身是可由 JavaScript 程序操作的值。像任何不是基本值的 JavaScript 值一样，函数和类是一种特殊的对象。它们将在第 8 章和第 9 章中详细介绍。 The JavaScript interpreter performs automatic garbage collection for memory management. This means that a JavaScript programmer generally does not need to worry about destruction or deallocation of objects or other values. When a value is no longer reachable—when a program no longer has any way to refer to it—the interpreter knows it can never be used again and automatically reclaims the memory it was occupying. (Java","date":"2020-11-02","objectID":"/posts/ch3/:1:0","tags":null,"title":"第 3 章 类型、值和变量","uri":"/posts/ch3/"},{"categories":null,"content":"3.2 Number JavaScript’s primary numeric type, Number, is used to represent integers and to approximate real numbers. JavaScript represents numbers using the 64-bit floating-point format defined by the IEEE 754 standard,1 which means it can represent numbers as large as ±1.7976931348623157 × 10308 and as small as ±5 × 10−324. JavaScript 的主要数字类型 Number 用于表示整数和近似实数。JavaScript 使用 IEEE 754 标准定义的64位浮点格式表示数字1，这意味着它可以表示大到±1.7976931348623157×10308，小到±5×10−324的数字。 The JavaScript number format allows you to exactly represent all integers between −9,007,199,254,740,992 (−253) and 9,007,199,254,740,992 (253), inclusive. If you use integer values larger than this, you may lose precision in the trailing digits. Note, however, that certain operations in JavaScript (such as array indexing and the bitwise operators described in Chapter 4) are performed with 32-bit integers. If you need to exactly represent larger integers, see §3.2.5. JavaScript 数字格式允许你精确地表示 9,007,199,254,740,992(−253) 和 9,007,199,254,740,992(253) 之间的所有整数。如果使用大于这个值的整数值，则可能会丢失末尾数字的精度。然而，请注意，JavaScript 中的某些操作（如数组索引和第 4 章中描述的位运算符）是用 32 位整数执行的。如果你需要精确地表示更大的整数，请参阅 §3.2.5。 When a number appears directly in a JavaScript program, it’s called a numeric literal. JavaScript supports numeric literals in several formats, as described in the following sections. Note that any numeric literal can be preceded by a minus sign (-) to make the number negative. 当一个数字直接出现在 JavaScript 程序中时，它被称为数字文字。JavaScript 支持几种格式的数字文字，如下面的章节所述。注意，任何数字文字前面都可以加一个减号(-)，以使数字为负。 ","date":"2020-11-02","objectID":"/posts/ch3/:2:0","tags":null,"title":"第 3 章 类型、值和变量","uri":"/posts/ch3/"},{"categories":null,"content":"3.2.1 Integer Literals In a JavaScript program, a base-10 integer is written as a sequence of digits. For example: 在 JavaScript 程序中，以 10 为基数的整数被写成数字序列。例如： 0 3 10000000 In addition to base-10 integer literals, JavaScript recognizes hexadecimal (base-16) values. A hexadecimal literal begins with 0x or 0X, followed by a string of hexadecimal digits. A hexadecimal digit is one of the digits 0 through 9 or the letters a (or A) through f (or F), which represent values 10 through 15. Here are examples of hexadecimal integer literals: 除了以 10 为基数的整数字面量之外，JavaScript 还可以识别十六进制（以 16 为基数）的值。以 0x 或 0x 开头的十六进制文字，后面跟着一串十六进制数字。16进制数字是数字 0 到 9 或字母 a（或A）到 f（或F）中的一个，表示值 10 到 15。以下是十六进制整数字面量的例子: 0xff // =\u003e 255: (15*16 + 15) 0xBADCAFE // =\u003e 195939070 In ES6 and later, you can also express integers in binary (base 2) or octal (base 8) using the prefixes 0b and 0o (or 0B and 0O) instead of 0x: 在 ES6 及后续版本中，还可以使用前缀 0b 和 0o（或0B和0O）来表示二进制（以 2 为基数）或八进制（以 8 为基数）的整数，而不是 0x： 0b10101 // =\u003e 21: (1*16 + 0*8 + 1*4 + 0*2 + 1*1) 0o377 // =\u003e 255: (3*64 + 7*8 + 7*1) ","date":"2020-11-02","objectID":"/posts/ch3/:2:1","tags":null,"title":"第 3 章 类型、值和变量","uri":"/posts/ch3/"},{"categories":null,"content":"3.2.2 Floating-Point Literals Floating-point literals can have a decimal point; they use the traditional syntax for real numbers. A real value is represented as the integral part of the number, followed by a decimal point and the fractional part of the number. 浮点字面值可以有小数点；他们使用传统的实数语法。实数表示为数字的整数部分，然后是小数点和小数部分。 Floating-point literals may also be represented using exponential notation: a real number followed by the letter e (or E), followed by an optional plus or minus sign, followed by an integer exponent. This notation represents the real number multiplied by 10 to the power of the exponent. 浮点字量也可以用指数表示法表示：一个实数后面跟着字母 e（或 E），后面跟着一个可选的加号或减号，然后是一个整数指数。这种记数方法表示的数值，是由前面的实数乘以10的指数次幂。 More succinctly, the syntax is: 更简洁地说，语法是： [digits][.digits][(E|e)[(+|-)]digits] For example: 例如: 3.14 2345.6789 .333333333333333333 6.02e23 // 6.02 × 10²³ 1.4738223E-32 // 1.4738223 × 10⁻³² SEPARATORS IN NUMERIC LITERALS You can use underscores within numeric literals to break long literals up into chunks that are easier to read: 你可以在数字字面值中使用下划线将长字面值分解成更容易阅读的块： let billion = 1_000_000_000; // Underscore as a thousands separator. let bytes = 0x89_AB_CD_EF; // As a bytes separator. let bits = 0b0001_1101_0111; // As a nibble separator. let fraction = 0.123_456_789; // Works in the fractional part, too. At the time of this writing in early 2020, underscores in numeric literals are not yet formally standardized as part of JavaScript. But they are in the advanced stages of the standardization process and are implemented by all major browsers and by Node. 在 2020 年初撰写本文时，数字字面值中的下划线还没有作为 JavaScript 的一部分正式标准化。但是它们处于标准化过程的高级阶段，所有主流浏览器和 Node 都实现了它们。 ","date":"2020-11-02","objectID":"/posts/ch3/:2:2","tags":null,"title":"第 3 章 类型、值和变量","uri":"/posts/ch3/"},{"categories":null,"content":"3.2.3 Arithmetic in JavaScript JavaScript programs work with numbers using the arithmetic operators . that the language provides. These include + for addition, - for subtraction, * for multiplication, / for division, and % for modulo (remainder after division). ES2016 adds ** for exponentiation. Full details on these and other operators can be found in Chapter 4. JavaScript 程序使用算术运算符处理数字。这是语言提供的。这些参数包括 + 表示加法，- 表示减法，* 表示乘法，/ 表示除法，% 表示取模（除后的余数）。ES2016 为取幂添加了 **。关于这些运算符和其他运算符的详细信息可以在第 4 章中找到。 In addition to these basic arithmetic operators, JavaScript supports more complex mathematical operations through a set of functions and constants defined as properties of the Math object: 除了这些基本的算术运算符，JavaScript 还支持更加复杂的算术运算，这些复杂运算通过作为 Math 对象的属性定义的函数和常量来实现： Math.pow(2,53) // =\u003e 9007199254740992: 2 to the power 53 Math.round(.6) // =\u003e 1.0: round to the nearest integer Math.ceil(.6) // =\u003e 1.0: round up to an integer Math.floor(.6) // =\u003e 0.0: round down to an integer Math.abs(-5) // =\u003e 5: absolute value Math.max(x,y,z) // Return the largest argument Math.min(x,y,z) // Return the smallest argument Math.random() // Pseudo-random number x where 0 \u003c= x \u003c 1.0 Math.PI // π: circumference of a circle / diameter Math.E // e: The base of the natural logarithm Math.sqrt(3) // =\u003e 3**0.5: the square root of 3 Math.pow(3, 1/3) // =\u003e 3**(1/3): the cube root of 3 Math.sin(0) // Trigonometry: also Math.cos, Math.atan, etc. Math.log(10) // Natural logarithm of 10 Math.log(100)/Math.LN10 // Base 10 logarithm of 100 Math.log(512)/Math.LN2 // Base 2 logarithm of 512 Math.exp(3) // Math.E cubed ES6 defines more functions on the Math object: ES6 在 Math 对象上定义了更多的函数: Math.cbrt(27) // =\u003e 3: cube root Math.hypot(3, 4) // =\u003e 5: square root of sum of squares of all arguments Math.log10(100) // =\u003e 2: Base-10 logarithm Math.log2(1024) // =\u003e 10: Base-2 logarithm Math.log1p(x) // Natural log of (1+x); accurate for very small x Math.expm1(x) // Math.exp(x)-1; the inverse of Math.log1p() Math.sign(x) // -1, 0, or 1 for arguments \u003c, ==, or \u003e 0 Math.imul(2,3) // =\u003e 6: optimized multiplication of 32-bit integers Math.clz32(0xf) // =\u003e 28: number of leading zero bits in a 32-bit integer Math.trunc(3.9) // =\u003e 3: convert to an integer by truncating fractional part Math.fround(x) // Round to nearest 32-bit float number Math.sinh(x) // Hyperbolic sine. Also Math.cosh(), Math.tanh() Math.asinh(x) // Hyperbolic arcsine. Also Math.acosh(), Math.atanh() Arithmetic in JavaScript does not raise errors in cases of overflow, underflow, or division by zero. When the result of a numeric operation is larger than the largest representable number (overflow), the result is a special infinity value, Infinity. Similarly, when the absolute value of a negative value becomes larger than the absolute value of the largest representable negative number, the result is negative infinity, -Infinity. The infinite values behave as you would expect: adding, subtracting, multiplying, or dividing them by anything results in an infinite value (possibly with the sign reversed). JavaScript 中的算术在溢出、下溢或除以 0 的情况下不会引发错误。当数值操作的结果大于最大可表示数（溢出）时，结果是一个特殊的无穷值，即 Infinity。同样，当一个负数的绝对值大于最大可表示负数的绝对值时，结果是负无穷，-Infinity。无穷值的行为与您预期的一样：加、减、乘或除任何值都会产生无穷值（可能符号颠倒）。 Underflow occurs when the result of a numeric operation is closer to zero than the smallest representable number. In this case, JavaScript returns 0. If underflow occurs from a negative number, JavaScript returns a special value known as “negative zero.” This value is almost completely indistinguishable from regular zero and JavaScript programmers rarely need to detect it. 当数值操作的结果比最小的可表示数字更接近于零时，就会发生下溢。在这种情况下，JavaScript 返回 0。如果下溢发生在负数，JavaScript 将返回一个特殊的值，称为“负零”。这个值与普通的 0 几乎没有区别，JavaScript 程序员几乎不需要检测它。 Division by zero is not an error in JavaScript: it simply returns infinity or negative infinity. There is one exception, however: zero divided by zero does not have a well-defined value, and the result of this operation is the special not-a-number value, NaN. NaN also arises if","date":"2020-11-02","objectID":"/posts/ch3/:2:3","tags":null,"title":"第 3 章 类型、值和变量","uri":"/posts/ch3/"},{"categories":null,"content":"3.2.4 Binary Floating-Point and Rounding Errors There are infinitely many real numbers, but only a finite number of them (18,437,736,874,454,810,627, to be exact) can be represented exactly by the JavaScript floating-point format. This means that when you’re working with real numbers in JavaScript, the representation of the number will often be an approximation of the actual number. 有无穷多的实数，但只有有限的数（确切地说，18,437,736,874,454,810,627）可以用 JavaScript 浮点格式精确地表示。这意味着在 JavaScript 中处理实数时，数字的表示通常是实际数字的近似值。 The IEEE-754 floating-point representation used by JavaScript (and just about every other modern programming language) is a binary representation, which can exactly represent fractions like 1/2, 1/8, and 1/1024. Unfortunately, the fractions we use most commonly (especially when performing financial calculations) are decimal fractions: 1/10, 1/100, and so on. Binary floating-point representations cannot exactly represent numbers as simple as 0.1. JavaScript（以及几乎所有其他现代编程语言）使用的 IEEE-754 浮点表示法是二进制表示法，它可以精确地表示像 1/2、1/8 和 1/1024 这样的分数。不幸的是，我们最常用的分数（特别是在执行财务计算时）是十进制分数：1/10、1/100，等等。二进制浮点表示法不能精确地表示像 0.1 这样简单的数字。 JavaScript numbers have plenty of precision and can approximate 0.1 very closely. But the fact that this number cannot be represented exactly can lead to problems. Consider this code: JavaScript 数字有足够的精度，可以非常接近 0.1。但这个数字不能准确地表示，这可能会导致问题。考虑这段代码： let x = .3 - .2; // thirty cents minus 20 cents let y = .2 - .1; // twenty cents minus 10 cents x === y // =\u003e false: the two values are not the same! x === .1 // =\u003e false: .3-.2 is not equal to .1 y === .1 // =\u003e true: .2-.1 is equal to .1 Because of rounding error, the difference between the approximations of .3 and .2 is not exactly the same as the difference between the approximations of .2 and .1. It is important to understand that this problem is not specific to JavaScript: it affects any programming language that uses binary floating-point numbers. Also, note that the values x and y in the code shown here are very close to each other and to the correct value. The computed values are adequate for almost any purpose; the problem only arises when we attempt to compare values for equality. 由于舍入误差，.3 和 .2 的近似值与 .2 和 .1 的近似值之间的差并不完全相同。需要注意的是，这个问题并不是 JavaScript 特有的：它会影响任何使用二进制浮点数的编程语言。另外，请注意，这里显示的代码中的值 x 和 y 非常接近，也非常接近正确的值。计算的值几乎适用于任何目的；只有当我们试图比较平等的价值时，问题才会出现。 If these floating-point approximations are problematic for your programs, consider using scaled integers. For example, you might manipulate monetary values as integer cents rather than fractional dollars. 如果这些浮点逼使的程序出现问题时，请考虑使用缩放整数。例如，您可以将货币值转为整数美分，而不是小数美元。 ","date":"2020-11-02","objectID":"/posts/ch3/:2:4","tags":null,"title":"第 3 章 类型、值和变量","uri":"/posts/ch3/"},{"categories":null,"content":"3.2.5 Arbitrary Precision Integers with BigInt One of the newest features of JavaScript, defined in ES2020, is a new numeric type known as BigInt. As of early 2020, it has been implemented in Chrome, Firefox, Edge, and Node, and there is an implementation in progress in Safari. As the name implies, BigInt is a numeric type whose values are integers. The type was added to JavaScript mainly to allow the representation of 64-bit integers, which are required for compatibility with many other programming languages and APIs. But BigInt values can have thousands or even millions of digits, should you have need to work with numbers that large. (Note, however, that BigInt implementations are not suitable for cryptography because they do not attempt to prevent timing attacks.) 在 ES2020 中定义的 JavaScript 最新特性之一是一种名为 BigInt 的新数字类型。到 2020 年初，它已经在 Chrome、Firefox、Edge 和 Node 中实现，Safari 也正在实现中。顾名思义，BigInt 是一种数值类型，其值为整数。该类型添加到 JavaScript 主要是为了支持 64 位整数的表示，这是与许多其他编程语言和 api 兼容所必需的。但是，如果需要处理这么大的数字，BigInt 值可以有数千甚至数百万位数字。（但是，请注意，BigInt 实现不适合密码学，因为它们不试图阻止计时攻击。） BigInt literals are written as a string of digits followed by a lowercase letter n. By default, the are in base 10, but you can use the 0b, 0o, and 0x prefixes for binary, octal, and hexadecimal BigInts: Bigint 字面量以数字字符串编写，后跟小写字母 n。默认情况下，它是 10 进制的，但您可以将 0b、0o 和 0x 前缀用于二进制、八进制和十六进制 BigInts： 1234n // A not-so-big BigInt literal 0b111111n // A binary BigInt 0o7777n // An octal BigInt 0x8000000000000000n // =\u003e 2n**63n: A 64-bit integer You can use BigInt() as a function for converting regular JavaScript numbers or strings to BigInt values: 你可以使用 BigInt() 作为函数，将普通的 JavaScript 数字或字符串转换为 BigInt 值: BigInt(Number.MAX_SAFE_INTEGER) // =\u003e 9007199254740991n let string = \"1\" + \"0\".repeat(100); // 1 followed by 100 zeros. BigInt(string) // =\u003e 10n**100n: one googol Arithmetic with BigInt values works like arithmetic with regular JavaScript numbers, except that division drops any remainder and rounds down (toward zero): 使用 BigInt 值的算术运算与使用常规 JavaScript 数字的算术运算类似，只不过除法会去掉任何余数（归 0）: 1000n + 2000n // =\u003e 3000n 3000n - 2000n // =\u003e 1000n 2000n * 3000n // =\u003e 6000000n 3000n / 997n // =\u003e 3n: the quotient is 3 3000n % 997n // =\u003e 9n: and the remainder is 9 (2n ** 131071n) - 1n // A Mersenne prime with 39457 decimal digits Although the standard +, -, *, /, %, and ** operators work with BigInt, it is important to understand that you may not mix operands of type BigInt with regular number operands. This may seem confusing at first, but there is a good reason for it. If one numeric type was more general than the other, it would be easy to define arithmetic on mixed operands to simply return a value of the more general type. But neither type is more general than the other: BigInt can represent extraordinarily large values, making it more general than regular numbers. But BigInt can only represent integers, making the regular JavaScript number type more general. There is no way around this problem, so JavaScript sidesteps it by simply not allowing mixed operands to the arithmetic operators. 尽管标准的 +、-、*、/、% 和 ** 运算符可用于BigInt，但重要的是要理解不能将 BigInt 类型的操作数与常规的数字操作数混合使用。乍一看，这可能令人困惑，但这是有充分理由的。如果一种数字类型比另一种类型更通用，那么很容易在混合操作数上定义算术，只返回更通用类型的值。但是这两种类型都比另一种更通用：BigInt可以表示非常大的值，这使得它比普通数字更通用。但是 BigInt 只能表示整数，这使得常规的 JavaScript 数字类型更加通用。没有办法绕过这个问题，所以 JavaScript 只是通过不允许算术运算符使用混合操作数来绕过这个问题。 Comparison operators, by contrast, do work with mixed numeric types (but see §3.9.1 for more about the difference between == and ===): 相比之下，比较运算符适用于混合数值类型（关于 == 和 === 的区别，请参阅 §3.9.1）： 1 \u003c 2n // =\u003e true 2 \u003e 1n // =\u003e true 0 == 0n // =\u003e true 0 === 0n // =\u003e false: the === checks for type equality as well The bitwise operators (described in §4.8.3) generally work with BigInt operands. None of the functions of the Math object accept BigInt operands, however. 按位运算符（在 §4.8.3 中描述）通常用于 BigInt 操作数。但是，Math 对象的函数都不接受 BigInt 操作数。 ","date":"2020-11-02","objectID":"/posts/ch3/:2:5","tags":null,"title":"第 3 章 类型、值和变量","uri":"/posts/ch3/"},{"categories":null,"content":"3.2.6 Dates and Times JavaScript defines a simple Date class for representing and manipulating the numbers that represent dates and times. JavaScript Dates are objects, but they also have a numeric representation as a timestamp that specifies the number of elapsed milliseconds since January 1, 1970: JavaScript 定义了一个简单的 Date 类，用于表示和操作表示日期和时间的数字。JavaScript 的日期是对象，但它们也有一个数字表示形式的时间戳，指定了自1970年1月1日以来经过的毫秒数： let timestamp = Date.now(); // The current time as a timestamp (a number). let now = new Date(); // The current time as a Date object. let ms = now.getTime(); // Convert to a millisecond timestamp. let iso = now.toISOString(); // Convert to a string in standard format. The Date class and its methods are covered in detail in §11.4. But we will see Date objects again in §3.9.3 when we examine the details of JavaScript type conversions. Date 类及其方法在 §11.4 中有详细介绍。但在 §3.9.3 节中，我们会在讨论 JavaScript 类型转换的细节时再次看到 Date 对象。 ","date":"2020-11-02","objectID":"/posts/ch3/:2:6","tags":null,"title":"第 3 章 类型、值和变量","uri":"/posts/ch3/"},{"categories":null,"content":"3.3 Text The JavaScript type for representing text is the string. A string is an immutable ordered sequence of 16-bit values, each of which typically represents a Unicode character. The length of a string is the number of 16-bit values it contains. JavaScript’s strings (and its arrays) use zero-based indexing: the first 16-bit value is at position 0, the second at position 1, and so on. The empty string is the string of length 0. JavaScript does not have a special type that represents a single element of a string. To represent a single 16-bit value, simply use a string that has a length of 1. 表示文本的 JavaScript 类型是字符串。字符串是由 16 位值组成的不可变有序序列，每个值通常代表一个 Unicode 字符。字符串的长度是它包含的 16 位值的个数。JavaScript 的字符串（及其数组）使用从零开始的索引：第一个 16 位的值位于位置 0，第二个位于位置 1，以此类推。空字符串是长度为 0 的字符串。JavaScript 没有特殊的类型来表示字符串的单个元素。要表示单个 16 位值，只需使用长度为 1 的字符串。 CHARACTERS, CODEPOINTS, AND JAVASCRIPT STRINGS 字符集，内码和JavaScript字符串 JavaScript uses the UTF-16 encoding of the Unicode character set, and JavaScript strings are sequences of unsigned 16-bit values. The most commonly used Unicode characters (those from the “basic multilingual plane”) have codepoints that fit in 16 bits and can be represented by one element of a string. Unicode characters whose codepoints do not fit in 16 bits are encoded using the rules of UTF-16 as a sequence (known as a “surrogate pair”) of two 16-bit values. This means that a JavaScript string of length 2 (two 16-bit values) might represent only a single Unicode character: JavaScript 使用 Unicode 字符集的 UTF-16 编码，JavaScript 字符串是无符号的 16 位值序列。最常用的 Unicode 字符（来自“基本多语种平面”的字符）都是通过 16 位的内码表示，并代表字符串中的单个字符。那些不能表示为16位的 Unicode 字符则遵循 UTF-16 编码规则——用两个 16 位值组成的一个序列（亦称做“代理项对”）表示。这意味着一个长度为 2 的 JavaScript 字符串（两个 16 位值）有可能表 一个 Unicode 字符： let euro = \"€\"; let love = \"❤\"; euro.length // =\u003e 1: this character has one 16-bit element love.length // =\u003e 2: UTF-16 encoding of ❤ is \"\\ud83d\\udc99\" Most string-manipulation methods defined by JavaScript operate on 16-bit values, not characters. They do not treat surrogate pairs specially, they perform no normalization of the string, and don’t even ensure that a string is well-formed UTF-16. JavaScript 定义的大多数字符串操作方法操作的是 16 位值，而不是字符。它们没有特别对待代理对，它们没有对字符串执行规范化，甚至不确保字符串是格式良好的 UTF-16。 In ES6, however, strings are iterable, and if you use the for/of loop or … operator with a string, it will iterate the actual characters of the string, not the 16-bit values. 然而，在 ES6 中，字符串是可迭代的，如果你使用 for/of 循环或 … 运算符，它将迭代字符串的实际字符，而不是 16 位值。 ","date":"2020-11-02","objectID":"/posts/ch3/:3:0","tags":null,"title":"第 3 章 类型、值和变量","uri":"/posts/ch3/"},{"categories":null,"content":"3.3.1 String Literals To include a string in a JavaScript program, simply enclose the characters of the string within a matched pair of single or double quotes or backticks (' or \" or `). Double-quote characters and backticks may be contained within strings delimited by single-quote characters, and similarly for strings delimited by double quotes and backticks. Here are examples of string literals: 要在 JavaScript 程序中包含字符串，只需将字符串的字符包含在匹配的单引号或双引号或反引号（' or \" or `）中。双引号字符和反引号可以包含在由单引号字符分隔的字符串中，由双引号和反引号分隔的字符串也是如此。以下是字符串字面量的例子: \"\" // The empty string: it has zero characters 'testing' \"3.14\" 'name=\"myform\"' \"Wouldn't you prefer O'Reilly's book?\" \"τ is the ratio of a circle's circumference to its radius\" `\"She said 'hi'\", he said.` Strings delimited with backticks are a feature of ES6, and allow JavaScript expressions to be embedded within (or interpolated into) the string literal. This expression interpolation syntax is covered in §3.3.4. 用反引号包含的字符串是 ES6 的一个特性，它允许 JavaScript 表达式嵌入（或插入）字符串字面量。这种表达式插值语法在 §3.3.4 中介绍。 The original versions of JavaScript required string literals to be written on a single line, and it is common to see JavaScript code that creates long strings by concatenating single-line strings with the + operator. As of ES5, however, you can break a string literal across multiple lines by ending each line but the last with a backslash (\\). Neither the backslash nor the line terminator that follow it are part of the string literal. If you need to include a newline character in a single-quoted or double-quoted string literal, use the character sequence \\n (documented in the next section). The ES6 backtick syntax allows strings to be broken across multiple lines, and in this case, the line terminators are part of the string literal: 最初的 JavaScript 版本要求将字符串文字写在单行上，通常会看到 JavaScript 代码通过使用 + 运算符连接单行字符串来创建长字符串。但是，在 ES5 中，您可以通过在每行末尾使用反斜杠（\\）来将字符串分隔成多行。反斜杠及其后面的行结束符都不是字符串字面值的一部分。如果需要在单引号或双引号的字符串文字中包含换行字符，请使用字符序列 \\n（在下一节中介绍）。ES6 反引号语法允许字符串跨多行分割，在这种情况下，行结束符是字符串字面值的一部分： // A string representing 2 lines written on one line: 'two\\nlines' // A one-line string written on 3 lines: \"one\\ long\\ line\" // A two-line string written on two lines: `the newline character at the end of this line is included literally in this string` Note that when you use single quotes to delimit your strings, you must be careful with English contractions and possessives, such as can’t and O’Reilly’s. Since the apostrophe is the same as the single-quote character, you must use the backslash character (\\) to “escape” any apostrophes that appear in single-quoted strings (escapes are explained in the next section). 注意，当您使用单引号来分隔字符串时，必须小心使用英语缩写和所有格，如 can’t 和 O’Reilly’s。由于撇号与单引号字符相同，必须使用反斜杠字符（\\）来“转义”出现在单引号字符串中的任何撇号（转义将在下一节中解释）。 In client-side JavaScript programming, JavaScript code may contain strings of HTML code, and HTML code may contain strings of JavaScript code. Like JavaScript, HTML uses either single or double quotes to delimit its strings. Thus, when combining JavaScript and HTML, it is a good idea to use one style of quotes for JavaScript and the other style for HTML. In the following example, the string “Thank you” is single-quoted within a JavaScript expression, which is then double-quoted within an HTML event-handler attribute: 在客户端 JavaScript 编程中，JavaScript 代码可能包含 HTML 代码字符串，HTML 代码可能包含 JavaScript 代码字符串。和 JavaScript 一样，HTML 也使用单引号或双引号来分隔字符串。因此，在组合 JavaScript 和 HTML 时，最好使用一种风格的引号用于 JavaScript，另一种风格的引号用于 HTML。在下面的例子中，字符串“Thank you”在 JavaScript 表达式中被单引号引用，然后在 HTML 事件处理程序属性中被双引号引用: \u003cbutton onclick=\"alert('Thank you')\"\u003eClick Me\u003c/button\u003e ","date":"2020-11-02","objectID":"/posts/ch3/:3:1","tags":null,"title":"第 3 章 类型、值和变量","uri":"/posts/ch3/"},{"categories":null,"content":"3.3.2 Escape Sequences in String Literals The backslash character (\\) has a special purpose in JavaScript strings. Combined with the character that follows it, it represents a character that is not otherwise representable within the string. For example, \\n is an escape sequence that represents a newline character. 反斜杠字符（\\）在 JavaScript 字符串中有特殊用途。与它后面的字符相结合，它表示字符串中不能以其他方式表示的字符。例如，\\n 是表示换行符的转义序列。 Another example, mentioned earlier, is the ' escape, which represents the single quote (or apostrophe) character. This escape sequence is useful when you need to include an apostrophe in a string literal that is contained within single quotes. You can see why these are called escape sequences: the backslash allows you to escape from the usual interpretation of the single-quote character. Instead of using it to mark the end of the string, you use it as an apostrophe: 前面提到的另一个例子是 ' 转义符，它表示单引号（或撇号）字符。当您需要在包含在单引号中的字符串文本中包含撇号时，这个转义序列非常有用。您可以看到为什么它们被称为转义序列：反斜杠允许您转义单引号字符的通常解释。不是用它来标记字符串的结束，而是用它作为撇号： 'You\\'re right, it can\\'t be a quote' Table 3-1 lists the JavaScript escape sequences and the characters they represent. Three escape sequences are generic and can be used to represent any character by specifying its Unicode character code as a hexadecimal number. For example, the sequence \\xA9 represents the copyright symbol, which has the Unicode encoding given by the hexadecimal number A9. Similarly, the \\u escape represents an arbitrary Unicode character specified by four hexadecimal digits or one to five digits when the digits are enclosed in curly braces: \\u03c0 represents the character π, for example, and \\u{1f600} represents the “grinning face” emoji. JavaScript 转义序列及其代表的字符如表 3-1 所示。三个转义序列是通用的，可以通过将 Unicode 字符代码指定为十六进制数来表示任何字符。例如，序列 \\xA9 表示版权符号，它具有由十六进制数字 A9 给出的 Unicode 编码。同样，\\u 转义表示由四个十六进制数字或用花括号括起来的 1 ~ 5 个数字指定的任意 Unicode 字符：例如，\\u03c0 表示字符 π，\\u{1f600} 表示“龇牙笑”表情。 Table 3-1. JavaScript escape sequences Sequence Character represented \\0 The NUL character (\\u0000) \\b Backspace (\\u0008) \\t Horizontal tab (\\u0009) \\n Newline (\\u000A) \\v Vertical tab (\\u000B) \\f Form feed (\\u000C) \\r Carriage return (\\u000D) \" Double quote (\\u0022) ' Apostrophe or single quote (\\u0027) \\\\ Backslash (\\u005C) \\xnn The Unicode character specified by the two hexadecimal digits nn \\unnnn The Unicode character specified by the four hexadecimal digits nnnn \\u{n} The Unicode character specified by the codepoint n, where n is one to six hexadecimal digits between 0 and 10FFFF (ES6) If the \\ character precedes any character other than those shown in Table 3-1, the backslash is simply ignored (although future versions of the language may, of course, define new escape sequences). For example, \\# is the same as #. Finally, as noted earlier, ES5 allows a backslash before a line break to break a string literal across multiple lines. 如果 \\ 字符在表 3-1 中以外的任何字符之前，反斜杠将被忽略（当然，未来版本的语言可能会定义新的转义序列）。例如，\\# 和 # 是一样的。最后，如前所述，ES5 允许在换行之前使用反斜杠来跨多行分割字符串字面量。 ","date":"2020-11-02","objectID":"/posts/ch3/:3:2","tags":null,"title":"第 3 章 类型、值和变量","uri":"/posts/ch3/"},{"categories":null,"content":"3.3.3 Working with Strings One of the built-in features of JavaScript is the ability to concatenate strings. If you use the + operator with numbers, it adds them. But if you use this operator on strings, it joins them by appending the second to the first. For example: JavaScript 的内置特性之一是连接字符串的能力。如果您对数字使用 + 运算符，它将它们相加。但是如果你在字符串上使用这个运算符，它通过将第二个运算符附加到第一个运算符上来连接字符串。例如： let msg = \"Hello, \" + \"world\"; // Produces the string \"Hello, world\" let greeting = \"Welcome to my blog,\" + \" \" + name; Strings can be compared with the standard === equality and !== inequality operators: two strings are equal if and only if they consist of exactly the same sequence of 16-bit values. Strings can also be compared with the \u003c, \u003c=, \u003e, and \u003e= operators. String comparison is done simply by comparing the 16-bit values. (For more robust locale-aware string comparison and sorting, see §11.7.3.) 字符串可以与标准的 === 相等和 !== 不等运算符进行比较：当且仅当两个字符串由完全相同的 16 位值序列组成时，它们才相等。字符串还可以与 \u003c、\u003c=、\u003e 和 \u003e= 运算符进行比较。字符串比较简单地通过比较 16 位值来完成。（更健壮的语言环境感知字符串比较和排序，见 §11.7.3。） To determine the length of a string—the number of 16-bit values it contains—use the length property of the string: 要确定一个字符串的长度——它包含的 16 位值的数量——使用字符串的 length 属性： s.length In addition to this length property, JavaScript provides a rich API for working with strings: 除了这个 length 属性，JavaScript 还提供了一个丰富的 API 来处理字符串： let s = \"Hello, world\"; // Start with some text. // Obtaining portions of a string s.substring(1,4) // =\u003e \"ell\": the 2nd, 3rd, and 4th characters. s.slice(1,4) // =\u003e \"ell\": same thing s.slice(-3) // =\u003e \"rld\": last 3 characters s.split(\", \") // =\u003e [\"Hello\", \"world\"]: split at delimiter string // Searching a string s.indexOf(\"l\") // =\u003e 2: position of first letter l s.indexOf(\"l\", 3) // =\u003e 3: position of first \"l\" at or after 3 s.indexOf(\"zz\") // =\u003e -1: s does not include the substring \"zz\" s.lastIndexOf(\"l\") // =\u003e 10: position of last letter l // Boolean searching functions in ES6 and later s.startsWith(\"Hell\") // =\u003e true: the string starts with these s.endsWith(\"!\") // =\u003e false: s does not end with that s.includes(\"or\") // =\u003e true: s includes substring \"or\" // Creating modified versions of a string s.replace(\"llo\", \"ya\") // =\u003e \"Heya, world\" s.toLowerCase() // =\u003e \"hello, world\" s.toUpperCase() // =\u003e \"HELLO, WORLD\" s.normalize() // Unicode NFC normalization: ES6 s.normalize(\"NFD\") // NFD normalization. Also \"NFKC\", \"NFKD\" // Inspecting individual (16-bit) characters of a string s.charAt(0) // =\u003e \"H\": the first character s.charAt(s.length-1) // =\u003e \"d\": the last character s.charCodeAt(0) // =\u003e 72: 16-bit number at the specified position s.codePointAt(0) // =\u003e 72: ES6, works for codepoints \u003e 16 bits // String padding functions in ES2017 \"x\".padStart(3) // =\u003e \" x\": add spaces on the left to a length of 3 \"x\".padEnd(3) // =\u003e \"x \": add spaces on the right to a length of 3 \"x\".padStart(3, \"*\") // =\u003e \"**x\": add stars on the left to a length of 3 \"x\".padEnd(3, \"-\") // =\u003e \"x--\": add dashes on the right to a length of 3 // Space trimming functions. trim() is ES5; others ES2019 \" test \".trim() // =\u003e \"test\": remove spaces at start and end \" test \".trimStart() // =\u003e \"test \": remove spaces on left. Also trimLeft \" test \".trimEnd() // =\u003e \" test\": remove spaces at right. Also trimRight // Miscellaneous string methods s.concat(\"!\") // =\u003e \"Hello, world!\": just use + operator instead \"\u003c\u003e\".repeat(5) // =\u003e \"\u003c\u003e\u003c\u003e\u003c\u003e\u003c\u003e\u003c\u003e\": concatenate n copies. ES6 Remember that strings are immutable in JavaScript. Methods like replace() and toUpperCase() return new strings: they do not modify the string on which they are invoked. 记住，字符串在 JavaScript 中是不可变的。像 replace() 和 toUpperCase() 这样的方法返回新的字符串：它们不会修改调用它们的字符串。 Strings can also be treated like read-only arrays, and you can access individual characters (16-bit values) from a string using square brackets instead of the charAt() method: 字符串也可以像只读数组一样处理，你可以使用方括号而不是 charAt() 方法从字符串中访问单个字符（16 位值）: let s = \"hello, world\"; s[0] // =\u003e \"h\" s[s.length-1] // =\u003e \"d\" ","date":"2020-11-02","objectID":"/posts/ch3/:3:3","tags":null,"title":"第 3 章 类型、值和变量","uri":"/posts/ch3/"},{"categories":null,"content":"3.3.4 Template Literals In ES6 and later, string literals can be delimited with backticks: 在 ES6 及以后的版本中，字符串文字可以用反引号分隔： let s = `hello world`; This is more than just another string literal syntax, however, because these template literals can include arbitrary JavaScript expressions. The final value of a string literal in backticks is computed by evaluating any included expressions, converting the values of those expressions to strings and combining those computed strings with the literal characters within the backticks: 然而，这不仅仅是另一种字符串字面量语法，因为这些模板字面量可以包含任意的 JavaScript 表达式。反引号中的字符串字面量的原始值是通过计算包含的表达式来计算的，将这些表达式的值转换为字符串，并将这些计算出来的字符串与反引号中的字面量字符组合起来: let name = \"Bill\"; let greeting = `Hello ${ name }.`; // greeting == \"Hello Bill.\" Everything between the ${ and the matching } is interpreted as a JavaScript expression. Everything outside the curly braces is normal string literal text. The expression inside the braces is evaluated and then converted to a string and inserted into the template, replacing the dollar sign, the curly braces, and everything in between them. ${ 和匹配 } 之间的所有内容都被解释为 JavaScript 表达式。大括号之外的都是普通的字符串文本。括号内的表达式被求值，然后转换为字符串并插入到模板中，替换美元符号、花括号以及它们之间的所有内容。 A template literal may include any number of expressions. It can use any of the escape characters that normal strings can, and it can span any number of lines, with no special escaping required. The following template literal includes four JavaScript expressions, a Unicode escape sequence, and at least four newlines (the expression values may include newlines as well): 模板字面量可以包含任意数量的表达式。它可以使用普通字符串可以使用的任何转义字符，并且可以跨任意数量的行，不需要特殊转义。下面的模板文字包含四个 JavaScript 表达式，一个 Unicode 转义序列，以及至少四个换行符（表达式值也可以包含换行符）： let errorMessage = `\\ \\u2718 Test failure at ${filename}:${linenumber}: ${exception.message}Stack trace: ${exception.stack}`; The backslash at the end of the first line here escapes the initial newline so that the resulting string begins with the Unicode ✘ character (\\u2718) rather than a newline. 第一行末尾的反斜杠转义了最初的换行符，这样产生的字符串以 Unicode 符合英语习惯的字符（\\u2718）开始，而不是换行符。 TAGGED TEMPLATE LITERALS 标签模版字面量 A powerful but less commonly used feature of template literals is that, if a function name (or “tag”) comes right before the opening backtick, then the text and the values of the expressions within the template literal are passed to the function. The value of this “tagged template literal” is the return value of the function. This could be used, for example, to apply HTML or SQL escaping to the values before substituting them into the text. 模板字面值的一个强大但不太常用的特性是，如果一个函数名（或“标签”）恰好出现在开始的反勾之前，那么模板字面值中的文本和表达式的值就会传递给该函数。这个“标记模板字面量”的值是函数的返回值。例如，这可以用于在将值替换到文本之前对值应用 HTML 或 SQL 转义。 ES6 has one built-in tag function: String.raw(). It returns the text within backticks without any processing of backslash escapes: ES6 有一个内置的标记函数：String.raw()。它在不处理任何反斜杠转义的情况下返回带有反引号的文本: `\\n`.length // =\u003e 1: the string has a single newline character String.raw`\\n`.length // =\u003e 2: a backslash character and the letter n Note that even though the tag portion of a tagged template literal is a function, there are no parentheses used in its invocation. In this very specific case, the backtick characters replace the open and close parentheses. 请注意，尽管标记模板文字的标记部分是一个函数，但在调用它时没有使用圆括号。在这个非常特定的例子中，反勾字符替换了开括号和闭括号。 The ability to define your own template tag functions is a powerful feature of JavaScript. These functions do not need to return strings, and they can be used like constructors, as if defining a new literal syntax for the language. We’ll see an example in §14.5. 定义自己的模板标记函数的能力是 JavaScript 的一个强大特性。这些函数不需要返回字符串，它们可以像构造函数一样使用，就像为语言定义新的文字语法一样。我们将在 §14.5 中看到一个例子。 ","date":"2020-11-02","objectID":"/posts/ch3/:3:4","tags":null,"title":"第 3 章 类型、值和变量","uri":"/posts/ch3/"},{"categories":null,"content":"3.3.5 Pattern Matching JavaScript defines a datatype known as a regular expression (or RegExp) for describing and matching patterns in strings of text. RegExps are not one of the fundamental datatypes in JavaScript, but they have a literal syntax like numbers and strings do, so they sometimes seem like they are fundamental. The grammar of regular expression literals is complex and the API they define is nontrivial. They are documented in detail in §11.3. Because RegExps are powerful and commonly used for text processing, however, this section provides a brief overview. JavaScript 定义了一种称为正则表达式（或RegExp）的数据类型，用于描述和匹配文本字符串中的模式。regexp 并不是 JavaScript 中的基本数据类型之一，但它们像数字和字符串一样有字面语法，所以有时看起来它们似乎是基本类型。正则表达式字面量的语法很复杂，它们定义的 API 也很重要。它们在 §11.3 中有详细的记录。但是，由于 regexp 功能强大，通常用于文本处理，因此本节提供一个简要概述。 Text between a pair of slashes constitutes a regular expression literal. The second slash in the pair can also be followed by one or more letters, which modify the meaning of the pattern. For example: 一对斜杠之间的文本构成了正则表达式字面量。对中的第二个斜杠还可以后跟一个或多个字母，它们修改了模式的含义。例如： /^HTML/; // Match the letters H T M L at the start of a string /[1-9][0-9]*/; // Match a nonzero digit, followed by any # of digits /\\bjavascript\\b/i; // Match \"javascript\" as a word, case-insensitive RegExp objects define a number of useful methods, and strings also have methods that accept RegExp arguments. For example: RegExp 对象定义了许多有用的方法，字符串也有接受 RegExp 实参的方法。例如： let text = \"testing: 1, 2, 3\"; // Sample text let pattern = /\\d+/g; // Matches all instances of one or more digits pattern.test(text) // =\u003e true: a match exists text.search(pattern) // =\u003e 9: position of first match text.match(pattern) // =\u003e [\"1\", \"2\", \"3\"]: array of all matches text.replace(pattern, \"#\") // =\u003e \"testing: #, #, #\" text.split(/\\D+/) // =\u003e [\"\",\"1\",\"2\",\"3\"]: split on nondigits ","date":"2020-11-02","objectID":"/posts/ch3/:3:5","tags":null,"title":"第 3 章 类型、值和变量","uri":"/posts/ch3/"},{"categories":null,"content":"3.4 Boolean Values A boolean value represents truth or falsehood, on or off, yes or no. There are only two possible values of this type. The reserved words true and false evaluate to these two values. 布尔值表示真或假、开或关、是或否。这种类型只有两个可能的值。保留字 true 和 false 计算这两个值。 Boolean values are generally the result of comparisons you make in your JavaScript programs. For example: 布尔值通常是你在 JavaScript 程序中进行比较的结果。例如： a === 4 This code tests to see whether the value of the variable a is equal to the number 4. If it is, the result of this comparison is the boolean value true. If a is not equal to 4, the result of the comparison is false. 这段代码测试变量 a 的值是否等于数字 4。如果是，则此比较的结果为布尔值 true。如果 a 不等于 4，则比较的结果为 false。 Boolean values are commonly used in JavaScript control structures. For example, the if/else statement in JavaScript performs one action if a boolean value is true and another action if the value is false. You usually combine a comparison that creates a boolean value directly with a statement that uses it. The result looks like this: 布尔值通常用于 JavaScript 的控制结构中。例如，JavaScript 中的 if/else 语句在布尔值为 true 时执行一个动作，在值为 false 时执行另一个动作。通常将直接创建布尔值的比较与使用它的语句组合在一起。结果是这样的： if (a === 4) { b = b + 1; } else { a = a + 1; } This code checks whether a equals 4. If so, it adds 1 to b; otherwise, it adds 1 to a. 这段代码检查 a 是否等于 4。如果是，则给 b 加 1；否则，它给 a 加 1。 As we’ll discuss in §3.9, any JavaScript value can be converted to a boolean value. The following values convert to, and therefore work like, false: 正如我们将在 §3.9 中讨论的，任何 JavaScript 值都可以转换为布尔值。下面的值会转换为 false，因此工作方式类似于 false： undefined null 0 -0 NaN \"\" // the empty string All other values, including all objects (and arrays) convert to, and work like, true. false, and the six values that convert to it, are sometimes called falsy values, and all other values are called truthy. Any time JavaScript expects a boolean value, a falsy value works like false and a truthy value works like true. 所有其他值，包括所有对象（和数组）都转换为 true，并像 true 一样工作。假值，以及转换为假值的六个值，有时被称为假值，其他所有值都被称为真值。任何时候 JavaScript 期望一个布尔值，都可以将假值作为 false 使用，真值作为 true。 As an example, suppose that the variable o either holds an object or the value null. You can test explicitly to see if o is non-null with an if statement like this: 例如，假设变量 o 保存一个对象或值为 null。你可以使用如下的 if 语句来显式测试 o 是否非空： if (o !== null) ... The not-equal operator !== compares o to null and evaluates to either true or false. But you can omit the comparison and instead rely on the fact that null is falsy and objects are truthy: 不相等运算符 !== 将 o 与 null 进行比较，然后求值为 true 或 false。但是你可以忽略比较，而是依赖 null 是假的，对象是真的： if (o) ... In the first case, the body of the if will be executed only if o is not null. The second case is less strict: it will execute the body of the if only if o is not false or any falsy value (such as null or undefined). Which if statement is appropriate for your program really depends on what values you expect to be assigned to o. If you need to distinguish null from 0 and “”, then you should use an explicit comparison. 在第一种情况下，if 函数体只有在 o 不为空时才会执行。第二种情况不那么严格：它只在 o 不为假值或任何假值（如 null 或 undefined）时执行 if 语句体。哪个 if 语句适合你的程序实际上取决于你希望给 o 赋什么值。如果你需要区分 null 和 0 和 “\"，那么你应该使用显式比较。 Boolean values have a toString() method that you can use to convert them to the strings “true” or “false”, but they do not have any other useful methods. Despite the trivial API, there are three important boolean operators. 布尔值有一个 toString() 方法，可以用来将它们转换为字符串“true”或“false”，但它们没有任何其他有用的方法。尽管 API 很简单，但是有三个重要的布尔运算符。 The \u0026\u0026 operator performs the Boolean AND operation. It evaluates to a truthy value if and only if both of its operands are truthy; it evaluates to a falsy value otherwise. The || operator is the Boolean OR operation: it evaluates to a truthy value if either one (or both) of its operands is truthy and evaluates to a falsy value if both operands are falsy. Finally, the unary ! operator performs the Boolean NOT operation: it evaluates to true if its operand is falsy and evaluates to false if its operand is truthy. For example: \u0026\u0026 运算符执行布尔和运算。当且仅当它的两个操作数","date":"2020-11-02","objectID":"/posts/ch3/:4:0","tags":null,"title":"第 3 章 类型、值和变量","uri":"/posts/ch3/"},{"categories":null,"content":"3.5 null and undefined null is a language keyword that evaluates to a special value that is usually used to indicate the absence of a value. Using the typeof operator on null returns the string “object”, indicating that null can be thought of as a special object value that indicates “no object”. In practice, however, null is typically regarded as the sole member of its own type, and it can be used to indicate “no value” for numbers and strings as well as objects. Most programming languages have an equivalent to JavaScript’s null: you may be familiar with it as NULL, nil, or None. null 是一个语言关键字，其计算结果为一个特殊值，该值通常用于指示没有值。对 null 使用 typeof 运算符返回字符串“object”，表示 null 可以被认为是一个特殊的对象值，表示“没有对象”。然而，在实践中，null 通常被视为它自己类型的唯一成员，它可以用来表示数字、字符串和对象的“无值”。大多数编程语言都有一个等价于 JavaScript 的 null：您可能熟悉它为 NULL、nil 或 None。 JavaScript also has a second value that indicates absence of value. The undefined value represents a deeper kind of absence. It is the value of variables that have not been initialized and the value you get when you query the value of an object property or array element that does not exist. The undefined value is also the return value of functions that do not explicitly return a value and the value of function parameters for which no argument is passed. undefined is a predefined global constant (not a language keyword like null, though this is not an important distinction in practice) that is initialized to the undefined value. If you apply the typeof operator to the undefined value, it returns “undefined”, indicating that this value is the sole member of a special type. JavaScript 还有第二个值，表示没有值。undefined 值代表一种更深层次的缺席。它是尚未初始化的变量的值，以及在查询不存在的对象属性或数组元素的值时获得的值。未定义的值也是没有显式返回值的函数的返回值，以及没有传递实参的函数形参的值。undefined 是一个预定义的全局常量（不是像 null 这样的语言关键字，虽然这在实践中不是一个重要的区别），它被初始化为 undefined 值。如果对未定义的值应用 typeof 运算符，它将返回“undefined”，表明该值是特殊类型的唯一成员。 Despite these differences, null and undefined both indicate an absence of value and can often be used interchangeably. The equality operator == considers them to be equal. (Use the strict equality operator === to distinguish them.) Both are falsy values: they behave like false when a boolean value is required. Neither null nor undefined have any properties or methods. In fact, using . or [] to access a property or method of these values causes a TypeError. 尽管存在这些差异，null 和 undefined 都表示没有值，并且经常可以互换使用。相等运算符 == 认为它们相等。（使用严格的相等运算符 === 来区分它们。）两者都是假值：当需要布尔值时，它们的行为类似于假值。null 和 undefined 都没有任何属性或方法。事实上，使用。或 [] 访问这些值的属性或方法会导致 TypeError。 I consider undefined to represent a system-level, unexpected, or error-like absence of value and null to represent a program-level, normal, or expected absence of value. I avoid using null and undefined when I can, but if I need to assign one of these values to a variable or property or pass or return one of these values to or from a function, I usually use null. Some programmers strive to avoid null entirely and use undefined in its place wherever they can. 我认为 undefined 表示系统级的、意外的或类似错误的值缺失，null 表示程序级的、正常的或预期的值缺失。我尽可能避免使用 null 和 undefined，但如果我需要分配这些值给一个变量或属性，或函数传递或返回一个这些值，我通常使用 null。一些程序员避免使用 null，而使用 undefined。 ","date":"2020-11-02","objectID":"/posts/ch3/:5:0","tags":null,"title":"第 3 章 类型、值和变量","uri":"/posts/ch3/"},{"categories":null,"content":"3.6 Symbols Symbols were introduced in ES6 to serve as non-string property names. To understand Symbols, you need to know that JavaScript’s fundamental Object type is an unordered collection of properties, where each property has a name and a value. Property names are typically (and until ES6, were exclusively) strings. But in ES6 and later, Symbols can also serve this purpose: Symbol 在 ES6 中被引入，用作非字符串属性名。要理解 Symbol，您需要知道 JavaScript 的基本对象类型是属性的无序集合，其中每个属性都有一个名称和一个值。属性名通常是字符串（在 ES6 之前专有的）。但是在 ES6 和以后的版本中，Symbol 也可以达到这个目的： let strname = \"string name\"; // A string to use as a property name let symname = Symbol(\"propname\"); // A Symbol to use as a property name typeof strname // =\u003e \"string\": strname is a string typeof symname // =\u003e \"symbol\": symname is a symbol let o = {}; // Create a new object o[strname] = 1; // Define a property with a string name o[symname] = 2; // Define a property with a Symbol name o[strname] // =\u003e 1: access the string-named property o[symname] // =\u003e 2: access the symbol-named property The Symbol type does not have a literal syntax. To obtain a Symbol value, you call the Symbol() function. This function never returns the same value twice, even when called with the same argument. This means that if you call Symbol() to obtain a Symbol value, you can safely use that value as a property name to add a new property to an object and do not need to worry that you might be overwriting an existing property with the same name. Similarly, if you use symbolic property names and do not share those symbols, you can be confident that other modules of code in your program will not accidentally overwrite your properties. Symbol 类型没有文字语法。要获取符号值，可以调用 Symbol() 函数。这个函数不会两次返回相同的值，即使调用时带有相同的实参。这意味着，如果您调用 Symbol() 来获得一个 Symbol 值，您可以安全地使用该值作为属性名，向对象添加一个新属性，而不需要担心可能会用相同的名称覆盖现有的属性。同样，如果您使用 Symbol 属性名而不共享这些符号，您可以确信程序中的其他模块不会意外地覆盖您的属性。 In practice, Symbols serve as a language extension mechanism. When ES6 introduced the for/of loop (§5.4.4) and iterable objects (Chapter 12), it needed to define standard method that classes could implement to make themselves iterable. But standardizing any particular string name for this iterator method would have broken existing code, so a symbolic name was used instead. As we’ll see in Chapter 12, Symbol.iterator is a Symbol value that can be used as a method name to make an object iterable. 实际上，Symbol 是一种语言扩展机制。当 ES6 引入 for/of 循环（ §5.4.4 ）和可迭代对象（第 12 章）时，它需要定义标准方法使类可以迭代。但用任何特定的字符串标准化命名这个迭代器方法都会破坏现有的代码，所以使用了一个符号名称代替。我们将在第 12 章 中看到。Symbol.iterator 是一个 Symbol 值，可以用作方法名，使对象可迭代。 The Symbol() function takes an optional string argument and returns a unique Symbol value. If you supply a string argument, that string will be included in the output of the Symbol’s toString() method. Note, however, that calling Symbol() twice with the same string produces two completely different Symbol values. Symbol() 函数接受一个可选的字符串实参，并返回一个唯一的符号值。如果提供一个字符串实参，该字符串将包含在符号的 toString() 方法的输出中。但是请注意，对同一个字符串调用 Symbol() 两次会产生两个完全不同的符号值。 let s = Symbol(\"sym_x\"); s.toString() // =\u003e \"Symbol(sym_x)\" toString() is the only interesting method of Symbol instances. There are two other Symbol-related functions you should know about, however. Sometimes when using Symbols, you want to keep them private to your own code so you have a guarantee that your properties will never conflict with properties used by other code. Other times, however, you might want to define a Symbol value and share it widely with other code. This would be the case, for example, if you were defining some kind of extension that you wanted other code to be able to participate in, as with the Symbol.iterator mechanism described earlier. toString() 是 Symbol 实例中唯一有趣的方法。但是，您还应该了解另外两个与符号相关的函数。有时在使用符号时，您希望将它们保留为自己的代码的私有属性，这样就可以保证属性不会与其他代码使用的属性发生冲突。然而，在其他时候，可能想要定义一个 Symbol 值并与其他代码广泛共享它。例如，如果您正在定义某种希望其他代码能够参与的扩展，就像前面描述的 Symbol.iterator 机制。 To serve this latter use case, JavaScript defines a global Symbol registry. The Symbol.for() function takes a string argument and returns a Symbol ","date":"2020-11-02","objectID":"/posts/ch3/:6:0","tags":null,"title":"第 3 章 类型、值和变量","uri":"/posts/ch3/"},{"categories":null,"content":"3.7 The Global Object The preceding sections have explained JavaScript’s primitive types and values. Object types—objects, arrays, and functions—are covered in chapters of their own later in this book. But there is one very important object value that we must cover now. The global object is a regular JavaScript object that serves a very important purpose: the properties of this object are the globally defined identifiers that are available to a JavaScript program. When the JavaScript interpreter starts (or whenever a web browser loads a new page), it creates a new global object and gives it an initial set of properties that define: 前面的章节已经说明了 JavaScript 的基本类型和值。对象类型——对象、数组和函数——将在本书后面的章节中介绍。但是有一个非常重要的对象值，我们现在必须讲一下。全局对象是一个常规的 JavaScript 对象，它有一个非常重要的用途：该对象的属性是 JavaScript 程序可用的全局定义的标识符。当 JavaScript 解释器启动时(或者每当 web 浏览器加载一个新页面时)，它会创建一个新的全局对象，并为其提供一组初始属性，这些属性定义： Global constants like undefined, Infinity, and NaN Global functions like isNaN(), parseInt() (§3.9.2), and eval() (§4.12) Constructor functions like Date(), RegExp(), String(), Object(), and Array() (§3.9.2) Global objects like Math and JSON (§6.8) 全局常量，如 undefined、Infinity 和 NaN 全局函数，如 isNaN()、 parseInt()（§3.9.2）和 eval()（§4.12） 构造函数，如 Date()、 RegExp()、 String()、 Object() 和 Array()（§3.9.2） 全局对象，如 Math 和 JSON（§6.8） The initial properties of the global object are not reserved words, but they deserve to be treated as if they are. This chapter has already described some of these global properties. Most of the others will be covered elsewhere in this book. 全局对象的初始属性不是保留字，但是它们应该被当作保留字来对待。本章已经描述了其中一些全局属性。其余的大部分将在本书的其他地方讨论。 In Node, the global object has a property named global whose value is the global object itself, so you can always refer to the global object by the name global in Node programs. 在 Node 中，全局对象有一个名为 global 的属性，该属性的值就是全局对象本身，因此在 Node 程序中始终可以通过名称 global 来引用全局对象。 In web browsers, the Window object serves as the global object for all JavaScript code contained in the browser window it represents. This global Window object has a self-referential window property that can be used to refer to the global object. The Window object defines the core global properties, but it also defines quite a few other globals that are specific to web browsers and client-side JavaScript. Web worker threads (§15.13) have a different global object than the Window with which they are associated. Code in a worker can refer to its global object as self. 在 web 浏览器中，Window 对象充当它所代表的浏览器窗口中包含的所有 JavaScript 代码的全局对象。这个全局窗口对象有一个自引用窗口属性，可以用来引用全局对象。Window 对象定义了核心的全局属性，但是它也定义了一些其他的全局属性，这些全局属性是特定于 web 浏览器和客户端 JavaScript 的。Web worker 线程（§15.13）有一个与它们相关联的窗口不同的全局对象。worker 中的代码可以将其全局对象引用为 self。 ES2020 finally defines globalThis as the standard way to refer to the global object in any context. As of early 2020, this feature has been implemented by all modern browsers and by Node. ES2020 最终定义了 globalThis 作为在任何上下文中引用全局对象的标准方式。到 2020 年初，所有现代浏览器和 Node 都实现了该特性。 ","date":"2020-11-02","objectID":"/posts/ch3/:7:0","tags":null,"title":"第 3 章 类型、值和变量","uri":"/posts/ch3/"},{"categories":null,"content":"3.8 Immutable Primitive Values and Mutable Object References There is a fundamental difference in JavaScript between primitive values (undefined, null, booleans, numbers, and strings) and objects (including arrays and functions). Primitives are immutable: there is no way to change (or “mutate”) a primitive value. This is obvious for numbers and booleans—it doesn’t even make sense to change the value of a number. It is not so obvious for strings, however. Since strings are like arrays of characters, you might expect to be able to alter the character at any specified index. In fact, JavaScript does not allow this, and all string methods that appear to return a modified string are, in fact, returning a new string value. For example: JavaScript 中的原始值（undefined、null、布尔值、数字和字符串）与对象（包 括数组和函数）有着根本区别。原始值是不可更改的：任何方法都无法更改（或“突变”）一个原始值。对数字和布尔值来说显然如此——改变数字的值本身就说不通，而对字符串来说就不那么明显了，因为字符串看起来像由字符组成的数组，我们期望可以通过指定索引来修改字符串中的字符。实际上，JavaScript 是禁止这样做的。字符串中所有的方法看上去返回了一个修改后的字符串，实际上返回的 是一个新的字符串值。例如： let s = \"hello\"; // Start with some lowercase text s.toUpperCase(); // Returns \"HELLO\", but doesn't alter s s // =\u003e \"hello\": the original string has not changed Primitives are also compared by value: two values are the same only if they have the same value. This sounds circular for numbers, booleans, null, and undefined: there is no other way that they could be compared. Again, however, it is not so obvious for strings. If two distinct string values are compared, JavaScript treats them as equal if, and only if, they have the same length and if the character at each index is the same. 原始值的比较是值的比较：只有在它们的值相等时它们才相等。这对数字、布尔值、null 和 undefined 来说听起来有点儿难懂，并没有其他办法来比较它们。同样，对于字符串来说则并不明显：如果比较两个单独的字符串，当且仅当它们的长度相等且每个索引的字符都相等时，JavaScript 才认为它们相等。 Objects are different than primitives. First, they are mutable—their values can change: 对象和原始值不同，首先，它们是可变的——它们的值是可修改的： let o = { x: 1 }; // Start with an object o.x = 2; // Mutate it by changing the value of a property o.y = 3; // Mutate it again by adding a new property let a = [1,2,3]; // Arrays are also mutable a[0] = 0; // Change the value of an array element a[3] = 4; // Add a new array element Objects are not compared by value: two distinct objects are not equal even if they have the same properties and values. And two distinct arrays are not equal even if they have the same elements in the same order: 对象的比较并非值的比较：即使两个对象包含同样的属性及相同的值，它们也是不相等的。各个索引元素完全相等的两个数组也不相等。 let o = {x: 1}, p = {x: 1}; // Two objects with the same properties o === p // =\u003e false: distinct objects are never equal let a = [], b = []; // Two distinct, empty arrays a === b // =\u003e false: distinct arrays are never equal Objects are sometimes called reference types to distinguish them from JavaScript’s primitive types. Using this terminology, object values are references, and we say that objects are compared by reference: two object values are the same if and only if they refer to the same underlying object. 我们有时将对象称为引用类型（reference type），以此来和 JavaScript 的基本类型区分开来。依照术语的叫法，对象值都是引用（reference），对象的比较均是引用的比较：当且仅当它们引用同一个基对象时，它们才相等。 let a = []; // The variable a refers to an empty array. let b = a; // Now b refers to the same array. b[0] = 1; // Mutate the array referred to by variable b. a[0] // =\u003e 1: the change is also visible through variable a. a === b // =\u003e true: a and b refer to the same object, so they are equal. As you can see from this code, assigning an object (or array) to a variable simply assigns the reference: it does not create a new copy of the object. If you want to make a new copy of an object or array, you must explicitly copy the properties of the object or the elements of the array. This example demonstrates using a for loop (§5.4.3): 就像你刚看到的如上代码，将对象（或数组）赋值给一个变量，仅仅是赋值的引用值：对象本身并没有复制一次。如果你想得到一个对象或数组的副本，则必须显式复制对象的每个属性或数组的每个元素。下面这个例子则是通过循环来完成数组复制（§5.4.3）： let a = [\"a\",\"b\",\"c\"]; // An array we want to copy let b = []; // A distinct array we'll copy into for(let i = 0; i \u003c a.length; i++) { // For each index of a[] b[i] = a[i]; // Copy an element of a into ","date":"2020-11-02","objectID":"/posts/ch3/:8:0","tags":null,"title":"第 3 章 类型、值和变量","uri":"/posts/ch3/"},{"categories":null,"content":"3.9 Type Conversions JavaScript is very flexible about the types of values it requires. We’ve seen this for booleans: when JavaScript expects a boolean value, you may supply a value of any type, and JavaScript will convert it as needed. Some values (“truthy” values) convert to true and others (“falsy” values) convert to false. The same is true for other types: if JavaScript wants a string, it will convert whatever value you give it to a string. If JavaScript wants a number, it will try to convert the value you give it to a number (or to NaN if it cannot perform a meaningful conversion). JavaScript 中取值所需类型非常灵活。从布尔值上就能看出这一点：当 JavaScript 需要一个布尔值时，你可以提供任何类型的值，JavaScript 会根据需要进行转换。一些值（真值）转换为 true，其他值（假值）转换为 false。这在 其他类型中同样适用：如果 JavaScript 期望使用一个字符串，它把给定的值将转换为字符串。如果 JavaScript 期望使用一个数字，它把给定的值将转换为数字（如果转换结果无意义的话将返回NaN）。 Some examples: 一些例子如下: 10 + \" objects\" // =\u003e \"10 objects\": Number 10 converts to a string \"7\" * \"4\" // =\u003e 28: both strings convert to numbers let n = 1 - \"x\"; // n == NaN; string \"x\" can't convert to a number n + \" objects\" // =\u003e \"NaN objects\": NaN converts to string \"NaN\" Table 3-2 summarizes how values convert from one type to another in JavaScript. Bold entries in the table highlight conversions that you may find surprising. Empty cells indicate that no conversion is necessary and none is performed. 表 3-2 简要说明了在 JavaScript 中如何进行类型转换。表 3-2 中的粗体部分突出显示了那些让你倍感意外的类型转换。空单元格表示不必要也没有执行转换。 Table 3-2. JavaScript type conversions 表 3-2 JavaScript类型转换 Value to String to Number to Boolean undefined “undefined” NaN false null “null” 0 false true “true” 1 false “false” 0 \"” (empty string) 0 false “1.2” (nonempty, numeric) 1.2 true “one” (nonempty, non-numeric) NaN true 0 “0” false -0 “0” false 1 (finite, non-zero) “1” true Infinity “Infinity” true -Infinity “-Infinity” true NaN “NaN” false {} (any object) see §3.9.3 see §3.9.3 true [] (empty array) \"\" 0 true [9] (one numeric element) “9” 9 true [‘a’] (any other array) use join() method NaN true function(){} (any function) see §3.9.3 NaN true The primitive-to-primitive conversions shown in the table are relatively straightforward. Conversion to boolean was already discussed in §3.4. Conversion to strings is well defined for all primitive values. Conversion to numbers is just a little trickier. Strings that can be parsed as numbers convert to those numbers. Leading and trailing spaces are allowed, but any leading or trailing nonspace characters that are not part of a numeric literal cause the string-to-number conversion to produce NaN. Some numeric conversions may seem surprising: true converts to 1, and false and the empty string convert to 0. 表中提到的原始值到原始值的转换相对简单，我们已经在 §3.4 讨论过转换为布尔值的情况了。所有原始值转换为字符串的情形也已经明确定义。转换为数字的情形比较微妙。那些以数字表示的字符串可以直接转换为数字，也允许在开始和结尾处带有空格。但在开始和结尾处的任意非空格字符都不会被当成数字直接量的一部分，进而造成字符串转换为数字的结果为 NaN。有一些数字转换看起来让人奇怪：true 转换为 1，false、空字符串 ”” 转换为 0。 Object-to-primitive conversion is somewhat more complicated, and it is the subject of §3.9.3. 对象到原始值的转换要复杂一些，它是 §3.9.3 的主题。 ","date":"2020-11-02","objectID":"/posts/ch3/:9:0","tags":null,"title":"第 3 章 类型、值和变量","uri":"/posts/ch3/"},{"categories":null,"content":"3.9.1 Conversions and Equality JavaScript has two operators that test whether two values are equal. The “strict equality operator,” ===, does not consider its operands to be equal if they are not of the same type, and this is almost always the right operator to use when coding. But because JavaScript is so flexible with type conversions, it also defines the == operator with a flexible definition of equality. All of the following comparisons are true, for example: JavaScript 有两个运算符来测试两个值是否相等。“严格的相等运算符”=== 的操作数不是同一类型则不认为它们是相等的，在编码时，这几乎总是正确的运算符。但是，由于 JavaScript 在类型转换方面非常灵活，所以它还定义了灵活相等运算符 ==。下面所有的比较都是正确的，例如： null == undefined // =\u003e true: These two values are treated as equal. \"0\" == 0 // =\u003e true: String converts to a number before comparing. 0 == false // =\u003e true: Boolean converts to number before comparing. \"0\" == false // =\u003e true: Both operands convert to 0 before comparing! §4.9.1 explains exactly what conversions are performed by the == operator in order to determine whether two values should be considered equal. §4.9.1 详细说明了 == 运算符执行什么转换来确定两个值是否应该被认为相等。 Keep in mind that convertibility of one value to another does not imply equality of those two values. If undefined is used where a boolean value is expected, for example, it will convert to false. But this does not mean that undefined == false. JavaScript operators and statements expect values of various types and perform conversions to those types. The if statement converts undefined to false, but the == operator never attempts to convert its operands to booleans. 需要特别注意的是，一个值转换为另一个值并不意味着两个值相等。比如，如果在期望使用布尔值的地方使用了 undefined，它将会转换为 false，但这并不表明 undefined == false。JavaScript 运算符和语句期望使用多样化的数据类型，并可以相互转换。if 语句将 undefined 转换为 false，但“==”运算符从不试图将其操作数转换为布尔值。 ","date":"2020-11-02","objectID":"/posts/ch3/:9:1","tags":null,"title":"第 3 章 类型、值和变量","uri":"/posts/ch3/"},{"categories":null,"content":"3.9.2 Explicit Conversions Although JavaScript performs many type conversions automatically, you may sometimes need to perform an explicit conversion, or you may prefer to make the conversions explicit to keep your code clearer. 尽管 JavaScript 可以自动做许多类型转换，但有时仍需要做显式转换，或者为了使代码变得清晰易读而做显式转换。 The simplest way to perform an explicit type conversion is to use the Boolean(), Number(), and String() functions: 执行显式类型转换的最简单方法是使用 Boolean()、Number() 和 String() 函数: Number(\"3\") // =\u003e 3 String(false) // =\u003e \"false\": Or use false.toString() Boolean([]) // =\u003e true Any value other than null or undefined has a toString() method, and the result of this method is usually the same as that returned by the String() function. 除null或undefined之外的任何值都有toString()方法，该方法的结果通常与String()函数返回的结果相同。 As an aside, note that the Boolean(), Number(), and String() functions can also be invoked—with new—as constructor. If you use them this way, you’ll get a “wrapper” object that behaves just like a primitive boolean, number, or string value. These wrapper objects are a historical leftover from the earliest days of JavaScript, and there is never really any good reason to use them. 顺便说一下，Boolean()、Number() 和 String() 函数可以作为构造函数调用（用 new 关键字）。如果以这种方式调用它们，就会得到一个行为类似原始布尔值、数字或字符串值的“包装器”对象。这些包装器对象是 JavaScript 早期遗留下来的，并且从来没有一个好的场景来使用他们。 Certain JavaScript operators perform implicit type conversions and are sometimes used explicitly for the purpose of type conversion. If one operand of the + operator is a string, it converts the other one to a string. The unary + operator converts its operand to a number. And the unary ! operator converts its operand to a boolean and negates it. These facts lead to the following type conversion idioms that you may see in some code: JavaScript 中的某些运算符会做隐式的类型转换，有时用于类型转换。如果“+”运算符的一个操作数是字符串，它将会把另外一个操作数转换为字符串。一元“+”运算符将其操作数转换为数字。同样，一元“！”运算符将其操作数转换为布尔值并取反。在代码中会经常见到这种类型转换的惯用法： x + \"\" // =\u003e String(x) +x // =\u003e Number(x) x-0 // =\u003e Number(x) !!x // =\u003e Boolean(x): Note double ! Formatting and parsing numbers are common tasks in computer programs, and JavaScript has specialized functions and methods that provide more precise control over number-to-string and string-to-number conversions. 在计算机程序中数字的解析和格式化是非常普通的工作，JavaScript 中提供了专门的函数和方法用来做更加精确的数字到字符串和字符串到数字的转换。 The toString() method defined by the Number class accepts an optional argument that specifies a radix, or base, for the conversion. If you do not specify the argument, the conversion is done in base 10. However, you can also convert numbers in other bases (between 2 and 36). For example: Number 类定义的 toString() 方法可以接收表示转换基数的可选实参，如果不指定此实参，转换规则将是基于十进制。同样，亦可以将数字转换为其他进制数（范围在2～36之间），例如： let n = 17; let binary = \"0b\" + n.toString(2); // binary == \"0b10001\" let octal = \"0o\" + n.toString(8); // octal == \"0o21\" let hex = \"0x\" + n.toString(16); // hex == \"0x11\" When working with financial or scientific data, you may want to convert numbers to strings in ways that give you control over the number of decimal places or the number of significant digits in the output, or you may want to control whether exponential notation is used. The Number class defines three methods for these kinds of number-to-string conversions. toFixed() converts a number to a string with a specified number of digits after the decimal point. It never uses exponential notation. toExponential() converts a number to a string using exponential notation, with one digit before the decimal point and a specified number of digits after the decimal point (which means that the number of significant digits is one larger than the value you specify). toPrecision() converts a number to a string with the number of significant digits you specify. It uses exponential notation if the number of significant digits is not large enough to display the entire integer portion of the number. Note that all three methods round the trailing digits or pad with zeros as appropriate. Consider the following examples: 当处理财务或科学数据的时候，在做数字到字符串的转换过程中，你期望自己控制输出中小数点位置和有效数字位数，或者决定是否需要指数记数","date":"2020-11-02","objectID":"/posts/ch3/:9:2","tags":null,"title":"第 3 章 类型、值和变量","uri":"/posts/ch3/"},{"categories":null,"content":"3.9.3 Object to Primitive Conversions The previous sections have explained how you can explicitly convert values of one type to another type and have explained JavaScript’s implicit conversions of values from one primitive type to another primitive type. This section covers the complicated rules that JavaScript uses to convert objects to primitive values. It is long and obscure, and if this is your first reading of this chapter, you should feel free to skip ahead to §3.10. 前几节说明了如何显式地将一种类型的值转换为另一种类型，并说明了 JavaScript 如何将值从一种原始类型隐式转换为另一种原始类型。本节介绍 JavaScript 用于将对象转换为原始值的复杂规则。它很长，晦涩难懂，如果这是你第一次阅读这一章，你可以直接跳到 §3.10。 One reason for the complexity of JavaScript’s object-to-primitive conversions is that some types of objects have more than one primitive representation. Date objects, for example, can be represented as strings or as numeric timestamps. The JavaScript specification defines three fundamental algorithms for converting objects to primitive values: JavaScript 的对象到原始值转换复杂的一个原因是某些类型的对象有不止一个原始表现。例如，日期对象可以表示为字符串或数字时间戳。JavaScript 规范定义了将对象转换为基本值的三种基本算法： prefer-string This algorithm returns a primitive value, preferring a string value, if a conversion to string is possible. 偏好字符串 prefer-string 如果可以转换成字符串，这个算法会返回一个原始值，提供一个字符串。 prefer-number This algorithm returns a primitive value, preferring a number, if such a conversion is possible. 偏好数字 prefer-number 如果可以转换，这个算法会返回一个原始值，提供一个数字。 no-preference This algorithm expresses no preference about what type of primitive value is desired, and classes can define their own conversions. Of the built-in JavaScript types, all except Date implement this algorithm as prefer-number. The Date class implements this algorithm as prefer-string. 无偏好 no-preference 此算法表示不对任何类型原始值有偏好，并且可以定义自己的转换。在内置的 JavaScript 类型中，除 Date 之外，其他所有类型都将此算法实现为偏好数字。Date 类将偏好字符串作为无偏好转换算法。 The implementation of these object-to-primitive conversion algorithms is explained at the end of this section. First, however, we explain how the algorithms are used in JavaScript. 这些对象到原语转换算法的实现将在本节的末尾进行解释。但是，我们首先解释如何在JavaScript中使用这些算法。 OBJECT-TO-BOOLEAN CONVERSIONS Object-to-boolean conversions are trivial: all objects convert to true. Notice that this conversion does not require the use of the object-to-primitive algorithms described, and that it literally applies to all objects, including empty arrays and even the wrapper object new Boolean(false). 对象到布尔的转换很简单：所有对象都转换为true。注意，这种转换不需要使用前面所描述的对象到原始值算法，它实际上适用于所有对象，包括空数组，甚至包装器对象 new Boolean(false)。 OBJECT-TO-STRING CONVERSIONS When an object needs to be converted to a string, JavaScript first converts it to a primitive using the prefer-string algorithm, then converts the resulting primitive value to a string, if necessary, following the rules in Table 3-2. 当一个对象需要转换为字符串时，JavaScript 首先使用 prefer-string 算法将其转换为原始值，然后根据表 3-2 的规则将得到的原语值转换为字符串。 This kind of conversion happens, for example, if you pass an object to a built-in function that expects a string argument, if you call String() as a conversion function, and when you interpolate objects into template literals (§3.3.4). 例如，如果你将一个对象传递给一个需要 string 实参的内置函数，如果你调用 String() 作为一个转换函数，以及当你将对象插入到模板字面量（§3.3.4）时，这种转换就会发生。 OBJECT-TO-NUMBER CONVERSIONS When an object needs to be converted to a number, JavaScript first converts it to a primitive value using the prefer-number algorithm, then converts the resulting primitive value to a number, if necessary, following the rules in Table 3-2. 当一个对象需要转换为数字时，JavaScript首先使用prefer-number算法将其转换为一个原始值，然后根据表3-2的规则将结果原始值转换为数字。 Built-in JavaScript functions and methods that expect numeric arguments convert object arguments to numbers in this way, and most (see the exceptions that follow) JavaScript operators that expect numeric operands convert objects to numbers in this way as well. 期望数字实参的内置JavaScript函数和方法以这种方式将对象实参转换为数字，大多数期望数字操作数的JavaScript运算符(参见后面的异常)也以这种方式将对象转换为数字。 SPECIAL CASE OPERATOR CONVERSIONS Operators are covered in detail in Chapter 4. Here, we explain the special case operators that do not use the basic object","date":"2020-11-02","objectID":"/posts/ch3/:9:3","tags":null,"title":"第 3 章 类型、值和变量","uri":"/posts/ch3/"},{"categories":null,"content":"3.10 Variable Declaration and Assignment One of the most fundamental techniques of computer programming is the use of names—or identifiers—to represent values. Binding a name to a value gives us a way to refer to that value and use it in the programs we write. When we do this, we typically say that we are assigning a value to a variable. The term “variable” implies that new values can be assigned: that the value associated with the variable may vary as our program runs. If we permanently assign a value to a name, then we call that name a constant instead of a variable. 计算机编程最基本的技术之一是使用名称或标识符来表示值。将名称绑定到一个值提供了一种引用该值并在编写的程序中使用它的方法。当我们这样做的时候，我们通常说我们给一个变量赋值。术语“变量”意味着可以分配新值:与变量相关的值可能随着程序运行而变化。如果我们将一个值永久地赋给一个名称，那么我们将该名称称为常量而不是变量。 Before you can use a variable or constant in a JavaScript program, you must declare it. In ES6 and later, this is done with the let and const keywords, which we explain next. Prior to ES6, variables were declared with var, which is more idiosyncratic and is explained later on in this section. 在JavaScript程序中使用变量或常量之前，必须声明它。在ES6及以后的版本中，这是通过let和const关键字来完成的，我们将在下文中解释。在ES6之前，变量是用var声明的，var更特殊，在本节后面解释。 ","date":"2020-11-02","objectID":"/posts/ch3/:10:0","tags":null,"title":"第 3 章 类型、值和变量","uri":"/posts/ch3/"},{"categories":null,"content":"3.10.1 Declarations with let and const In modern JavaScript (ES6 and later), variables are declared with the let keyword, like this: 在现代JavaScript (ES6及以后的版本)中，变量是用let关键字声明的，就像这样: let i; let sum; You can also declare multiple variables in a single let statement: 你也可以在一个let语句中声明多个变量: let i, sum; It is a good programming practice to assign an initial value to your variables when you declare them, when this is possible: 在声明变量时，给它们赋一个初始值是一个很好的编程实践，这是可能的: let message = \"hello\"; let i = 0, j = 0, k = 0; let x = 2, y = x*x; // Initializers can use previously declared variables If you don’t specify an initial value for a variable with the let statement, the variable is declared, but its value is undefined until your code assigns a value to it. 如果没有使用let语句为变量指定初始值，则声明变量，但在代码为其赋值之前，变量的值是未定义的。 To declare a constant instead of a variable, use const instead of let. const works just like let except that you must initialize the constant when you declare it: 要声明常量而不是变量，请使用const而不是let。const的工作方式与let类似，只是在声明常量时必须初始化它: const H0 = 74; // Hubble constant (km/s/Mpc) const C = 299792.458; // Speed of light in a vacuum (km/s) const AU = 1.496E8; // Astronomical Unit: distance to the sun (km) As the name implies, constants cannot have their values changed, and any attempt to do so causes a TypeError to be thrown. 顾名思义，常量不能改变它们的值，任何这样做的尝试都会引发TypeError。 It is a common (but not universal) convention to declare constants using names with all capital letters such as H0 or HTTP_NOT_FOUND as a way to distinguish them from variables. 通常(但不是通用的)约定是使用全大写字母(如H0或HTTP_NOT_FOUND)的名称来声明常量，以将它们与变量区分开来。 WHEN TO USE CONST There are two schools of thought about the use of the const keyword. One approach is to use const only for values that are fundamentally unchanging, like the physical constants shown, or program version numbers, or byte sequences used to identify file types, for example. Another approach recognizes that many of the so-called variables in our program don’t actually ever change as our program runs. In this approach, we declare everything with const, and then if we find that we do actually want to allow the value to vary, we switch the declaration to let. This may help prevent bugs by ruling out accidental changes to variables that we did not intend. 关于const关键字的使用有两种思想流派。一种方法是仅对基本不变的值使用const，例如所示的物理常量、程序版本号或用于标识文件类型的字节序列。另一种方法认为，程序中许多所谓的变量实际上不会随着程序的运行而改变。在这种方法中，我们用const声明所有内容，然后如果发现我们确实希望允许值变化，我们将声明切换为let。这可以通过排除我们无意中对变量的意外更改来防止错误。 In one approach, we use const only for values that must not change. In the other, we use const for any value that does not happen to change. I prefer the former approach in my own code. 在一种方法中，我们只对不能改变的值使用const。在另一种情况下，对于任何不会发生变化的值都使用const。在我自己的代码中，我更喜欢前一种方法。 In Chapter 5, we’ll learn about the for, for/in, and for/of loop statements in JavaScript. Each of these loops includes a loop variable that gets a new value assigned to it on each iteration of the loop. JavaScript allows us to declare the loop variable as part of the loop syntax itself, and this is another common way to use let: 在第五章，我们将学习JavaScript中的for、for/ In和for/of循环语句。每个循环都包含一个循环变量，该变量在循环的每次迭代中都赋给它一个新值。JavaScript允许我们将循环变量声明为循环语法本身的一部分，这是使用let的另一种常见方式: for(let i = 0, len = data.length; i \u003c len; i++) console.log(data[i]); for(let datum of data) console.log(datum); for(let property in object) console.log(property); It may seem surprising, but you can also use const to declare the loop “variables” for for/in and for/of loops, as long as the body of the loop does not reassign a new value. In this case, the const declaration is just saying that the value is constant for the duration of one loop iteration: 你可能会觉得奇怪，但是你也可以使用const来声明for/in和for/of循环的循环“变量”，只要循环体不重新赋值。在这种情况下，const声明只是表示该值在循环迭代的持续时间内为常量: for(const datum of data) console.log(datum); for(const property in object) console.log(property); VARIABLE AND CONSTANT SCOPE The scope of a variable is the region of your program source code in which it is defined. Variables and constants declared with let and const are block ","date":"2020-11-02","objectID":"/posts/ch3/:10:1","tags":null,"title":"第 3 章 类型、值和变量","uri":"/posts/ch3/"},{"categories":null,"content":"3.10.2 Variable Declarations with var In versions of JavaScript before ES6, the only way to declare a variable is with the var keyword, and there is no way to declare constants. The syntax of var is just like the syntax of let: 在ES6之前的JavaScript版本中，声明变量的唯一方法是使用var关键字，而没有方法声明常量。var的语法就像let的语法一样: var x; var data = [], count = data.length; for(var i = 0; i \u003c count; i++) console.log(data[i]); Although var and let have the same syntax, there are important differences in the way they work: 虽然var和let有相同的语法，但它们的工作方式有重要的不同: Variables declared with var do not have block scope. Instead, they are scoped to the body of the containing function no matter how deeply nested they are inside that function. If you use var outside of a function body, it declares a global variable. But global variables declared with var differ from globals declared with let in an important way. Globals declared with var are implemented as properties of the global object (§3.7). The global object can be referenced as globalThis. So if you write var x = 2; outside of a function, it is like you wrote globalThis.x = 2;. Note however, that the analogy is not perfect: the properties created with global var declarations cannot be deleted with the delete operator (§4.13.4). Global variables and constants declared with let and const are not properties of the global object. Unlike variables declared with let, it is legal to declare the same variable multiple times with var. And because var variables have function scope instead of block scope, it is actually common to do this kind of redeclaration. The variable i is frequently used for integer values, and especially as the index variable of for loops. In a function with multiple for loops, it is typical for each one to begin for(var i = 0; …. Because var does not scope these variables to the loop body, each of these loops is (harmlessly) re-declaring and re-initializing the same variable. One of the most unusual features of var declarations is known as hoisting. When a variable is declared with var, the declaration is lifted up (or “hoisted”) to the top of the enclosing function. The initialization of the variable remains where you wrote it, but the definition of the variable moves to the top of the function. So variables declared with var can be used, without error, anywhere in the enclosing function. If the initialization code has not run yet, then the value of the variable may be undefined, but you won’t get an error if you use the variable before it is initialized. (This can be a source of bugs and is one of the important misfeatures that let corrects: if you declare a variable with let but attempt to use it before the let statement runs, you will get an actual error instead of just seeing an undefined value.) 用var声明的变量没有块作用域。相反，它们的作用域是包含函数的主体，无论它们嵌套在函数内部有多深。 如果你在函数体之外使用var，它会声明一个全局变量。但是用var声明的全局变量与用let声明的全局变量在一个重要的方面不同。用var声明的全局变量是作为全局对象的属性实现的(§3.7)。全局对象可以引用为globalThis。如果你写var x = 2;在函数之外，它就像你写的globalThis。x = 2,。但是注意，这个类比并不完美:用全局var声明创建的属性不能用delete运算符删除(§4.13.4)。用let和const声明的全局变量和常量不是全局对象的属性。 与用let声明的变量不同，用var多次声明同一个变量是合法的。而且因为var变量具有函数作用域而不是块作用域，所以这种类型的重声明实际上是很常见的。变量i经常被用来表示整数值，特别是作为for循环的索引变量。在有多个for循环的函数中，每个循环都以for(var i = 0;…因为var没有将这些变量作用域限定在循环体中，所以每个循环都(无害地)重新声明并初始化同一个变量。 var声明最不寻常的特性之一就是吊装。当用var声明一个变量时，这个声明会被提升(或“悬挂”)到外围函数的顶部。变量的初始化保持在编写它的地方，但变量的定义移到函数的顶部。因此，用var声明的变量可以在外围函数的任何位置使用，不会出错。如果初始化代码还没有运行，那么变量的值可能是未定义的，但如果在变量初始化之前使用它，则不会出现错误。(这可能是bug的来源，也是let纠正的重要错误特性之一:如果你用let声明了一个变量，但试图在let语句运行之前使用它，你将得到一个实际的错误，而不仅仅是看到一个未定义的值。) USING UNDECLARED VARIABLES In strict mode (§5.6.3), if you attempt to use an undeclared variable, you’ll get a reference error when you run your code. Outside of strict mode, however, if you assign a value to a name that has not been declared with let, const, or var, you’ll end up creating a new global variable. It will be a global no matter now deeply nested within functions and blocks your code is, which is almost certainly not what you want, is bug-prone, and is one of the best reasons for u","date":"2020-11-02","objectID":"/posts/ch3/:10:2","tags":null,"title":"第 3 章 类型、值和变量","uri":"/posts/ch3/"},{"categories":null,"content":"3.10.3 Destructuring Assignment ES6 implements a kind of compound declaration and assignment syntax known as destructuring assignment. In a destructuring assignment, the value on the righthand side of the equals sign is an array or object (a “structured” value), and the lefthand side specifies one or more variable names using a syntax that mimics array and object literal syntax. When a destructuring assignment occurs, one or more values are extracted (“destructured”) from the value on the right and stored into the variables named on the left. Destructuring assignment is perhaps most commonly used to initialize variables as part of a const, let, or var declaration statement, but it can also be done in regular assignment expressions (with variables that have already been declared). And, as we’ll see in §8.3.5, destructuring can also be used when defining the parameters to a function. ES6 实现了一种复合声明和赋值语法，称为解构赋值。在解构赋值中，等号右边的值是一个数组或对象（“结构化的”值），左边使用模仿数组和对象字面量语法的语法指定一个或多个变量名。当发生解构赋值时，将从右边的值中提取一个或多个值（“解构”），并存储到左边命名的变量中。解构赋值可能常用来初始化 const、let 或 var 的声明，但它也可以用在正则赋值表达式中（使用已经声明的变量）。而且，我们将在 §8.3.5 中看到的，解构也可以用于定义函数的形参。 Here are simple destructuring assignments using arrays of values: 下面是使用数组值的简单解构赋值： let [x,y] = [1,2]; // Same as let x=1, y=2 [x,y] = [x+1,y+1]; // Same as x = x + 1, y = y + 1 [x,y] = [y,x]; // Swap the value of the two variables [x,y] // =\u003e [3,2]: the incremented and swapped values Notice how destructuring assignment makes it easy to work with functions that return arrays of values: 请注意，解构赋值使返回数组值的函数变得很容易： // Convert [x,y] coordinates to [r,theta] polar coordinates function toPolar(x, y) { return [Math.sqrt(x*x+y*y), Math.atan2(y,x)]; } // Convert polar to Cartesian coordinates function toCartesian(r, theta) { return [r*Math.cos(theta), r*Math.sin(theta)]; } let [r,theta] = toPolar(1.0, 1.0); // r == Math.sqrt(2); theta == Math.PI/4 let [x,y] = toCartesian(r,theta); // [x, y] == [1.0, 1,0] We saw that variables and constants can be declared as part of JavaScript’s various for loops. It is possible to use variable destructuring in this context as well. Here is a code that loops over the name/value pairs of all properties of an object and uses destructuring assignment to convert those pairs from two-element arrays into individual variables: 我们看到变量和常量可以声明为 JavaScript 的各种 for 循环的一部分。在这个上下文中也可以使用变量解构。下面的代码循环遍历对象的所有属性的名称/值对，并使用解构赋值将这些对从两个元素数组转换为单独的变量： let o = { x: 1, y: 2 }; // The object we'll loop over for(const [name, value] of Object.entries(o)) { console.log(name, value); // Prints \"x 1\" and \"y 2\" } The number of variables on the left of a destructuring assignment does not have to match the number of array elements on the right. Extra variables on the left are set to undefined, and extra values on the right are ignored. The list of variables on the left can include extra commas to skip certain values on the right: 解构赋值左边的变量数量不必与右边的数组元素数量相匹配。左边的额外变量被设置为 undefined，右边的额外值被忽略。左边的变量列表可以包含额外的逗号，以跳过右边的某些值： let [x,y] = [1]; // x == 1; y == undefined [x,y] = [1,2,3]; // x == 1; y == 2 [,x,,y] = [1,2,3,4]; // x == 2; y == 4 If you want to collect all unused or remaining values into a single variable when destructuring an array, use three dots (…) before the last variable name on the left-hand side: 如果你想在解构数组时将所有未使用的或剩余的值收集到一个变量中，在左边最后一个变量名之前使用三个点（…）： let [x, ...y] = [1,2,3,4]; // y == [2,3,4] We’ll see three dots used this way again in §8.3.2, where they are used to indicate that all remaining function arguments should be collected into a single array. 在 §8.3.2 中，我们将再次看到以这种方式使用的三个点，它们用于指示所有剩余的函数实参收集到一个数组中。 Destructuring assignment can be used with nested arrays. In this case, the lefthand side of the assignment should look like a nested array literal: 解构赋值可用于嵌套数组。在这种情况下，赋值的左边应该看起来像一个嵌套的数组字面量： let [a, [b, c]] = [1, [2,2.5], 3]; // a == 1; b == 2; c == 2.5 A powerful feature of array destructuring is that it does not actually require an array! You can use any iterable object (Chapter 12) on the righthand side of the assignment; any objec","date":"2020-11-02","objectID":"/posts/ch3/:10:3","tags":null,"title":"第 3 章 类型、值和变量","uri":"/posts/ch3/"},{"categories":null,"content":"3.11 Summary Some key points to remember about this chapter: 关于本章需要记住的一些要点: How to write and manipulate numbers and strings of text in JavaScript. How to work with JavaScript’s other primitive types: booleans, Symbols, null, and undefined. The differences between immutable primitive types and mutable reference types. How JavaScript converts values implicitly from one type to another and how you can do so explicitly in your programs. How to declare and initialize constants and variables (including with destructuring assignment) and the lexical scope of the variables and constants you declare. 如何在JavaScript中编写和操作数字和文本字符串。 如何使用JavaScript的其他原始类型:布尔型，符号，空，和未定义。 不可变基元类型和可变引用类型的区别。 JavaScript如何隐式地将值从一种类型转换为另一种类型，以及你如何在你的程序中显式地这样做。 如何声明和初始化常量和变量(包括解构赋值)和变量和常量的词法范围你声明。 This is the format for numbers of type double in Java, C++, and most modern programming languages. There are JavaScript extensions, such as TypeScript and Flow (§17.8), that allow types to be specified as part of variable declarations with syntax like let x: number = 0;. ","date":"2020-11-02","objectID":"/posts/ch3/:11:0","tags":null,"title":"第 3 章 类型、值和变量","uri":"/posts/ch3/"},{"categories":null,"content":"This chapter documents JavaScript expressions and the operators with which many of those expressions are built. An expression is a phrase of JavaScript that can be evaluated to produce a value. A constant embedded literally in your program is a very simple kind of expression. A variable name is also a simple expression that evaluates to whatever value has been assigned to that variable. Complex expressions are built from simpler expressions. An array access expression, for example, consists of one expression that evaluates to an array followed by an open square bracket, an expression that evaluates to an integer, and a close square bracket. This new, more complex expression evaluates to the value stored at the specified index of the specified array. Similarly, a function invocation expression consists of one expression that evaluates to a function object and zero or more additional expressions that are used as the arguments to the function. 本章介绍了JavaScript表达式和用于构建这些表达式的运算符。表达式是JavaScript的一个短语，可以计算它来产生一个值。在程序中嵌入的常量是一种非常简单的表达式。变量名也是一个简单的表达式，计算结果为分配给该变量的任何值。复杂的表达式是由简单的表达式构建的。例如，数组访问表达式由一个计算结果为数组的表达式、一个计算结果为整数的表达式和一个右方括号组成。这个新的更复杂的表达式计算为存储在指定数组的指定索引处的值。类似地，函数调用表达式由计算为函数对象的一个表达式和用作函数参数的零个或多个附加表达式组成。 The most common way to build a complex expression out of simpler expressions is with an operator. An operator combines the values of its operands (usually two of them) in some way and evaluates to a new value. The multiplication operator * is a simple example. The expression x * y evaluates to the product of the values of the expressions x and y. For simplicity, we sometimes say that an operator returns a value rather than “evaluates to” a value. 从较简单的表达式构建复杂表达式的最常见方法是使用运算符。运算符以某种方式组合其操作数的值(通常是两个)并计算为一个新值。乘法运算符*是一个简单的示例。表达式x * y的值是表达式x和y的值的乘积。为了简单起见，我们有时说运算符返回一个值，而不是“求值”一个值。 This chapter documents all of JavaScript’s operators, and it also explains expressions (such as array indexing and function invocation) that do not use operators. If you already know another programming language that uses C-style syntax, you’ll find that the syntax of most of JavaScript’s expressions and operators is already familiar to you. 这一章记录了所有的JavaScript运算符，也解释了不使用运算符的表达式(比如数组索引和函数调用)。如果您已经知道另一种使用c风格语法的编程语言，那么您会发现JavaScript的大多数表达式和运算符的语法对您来说已经很熟悉了。 ","date":"2020-11-02","objectID":"/posts/ch4/:0:0","tags":null,"title":"第 4 章 表达式和运算符","uri":"/posts/ch4/"},{"categories":null,"content":"4.1 Primary Expressions The simplest expressions, known as primary expressions, are those that stand alone—they do not include any simpler expressions. Primary expressions in JavaScript are constant or literal values, certain language keywords, and variable references. 最简单的表达式被称为基本表达式，是那些独立的表达式——它们不包括任何更简单的表达式。JavaScript中的主表达式是常量或文字值、某些语言关键字和变量引用。 Literals are constant values that are embedded directly in your program. They look like these: 文本是直接嵌入到程序中的常数值。它们看起来是这样的: 1.23 // A number literal \"hello\" // A string literal /pattern/ // A regular expression literal JavaScript syntax for number literals was covered in §3.2. String literals were documented in §3.3. The regular expression literal syntax was introduced in §3.3.5 and will be documented in detail in §11.3. 在§3.2中介绍了用于数字文字的JavaScript语法。在§3.3中记录了字符串文字。正则表达式字面语法是在§3.3.5中介绍的，并将在§11.3中详细说明。 Some of JavaScript’s reserved words are primary expressions: 一些JavaScript的保留字是主要的表达式: true // Evalutes to the boolean true value false // Evaluates to the boolean false value null // Evaluates to the null value this // Evaluates to the \"current\" object We learned about true, false, and null in §3.4 and §3.5. Unlike the other keywords, this is not a constant—it evaluates to different values in different places in the program. The this keyword is used in object-oriented programming. Within the body of a method, this evaluates to the object on which the method was invoked. See §4.5, Chapter 8 (especially §8.2.2), and Chapter 9 for more on this. 我们在§3.4和§3.5中学习了真、假和空。与其他关键字不同，这不是常量—它在程序的不同位置计算不同的值。关键字this用于面向对象编程。在方法体中，这将计算为调用该方法的对象。请参阅§4.5，第 8 章(特别是§8.2.2)和第 9 章来了解更多这方面的内容。 Finally, the third type of primary expression is a reference to a variable, constant, or property of the global object: 最后，第三种类型的主表达式是对全局对象的变量、常量或属性的引用: i // Evaluates to the value of the variable i. sum // Evaluates to the value of the variable sum. undefined // The value of the \"undefined\" property of the global object When any identifier appears by itself in a program, JavaScript assumes it is a variable or constant or property of the global object and looks up its value. If no variable with that name exists, an attempt to evaluate a nonexistent variable throws a ReferenceError instead. 当任何标识符在程序中单独出现时，JavaScript假定它是全局对象的变量、常量或属性，并查找其值。如果不存在具有该名称的变量，则尝试对不存在的变量求值会抛出一个ReferenceError。 ","date":"2020-11-02","objectID":"/posts/ch4/:1:0","tags":null,"title":"第 4 章 表达式和运算符","uri":"/posts/ch4/"},{"categories":null,"content":"4.2 Object and Array Initializers Object and array initializers are expressions whose value is a newly created object or array. These initializer expressions are sometimes called object literals and array literals. Unlike true literals, however, they are not primary expressions, because they include a number of subexpressions that specify property and element values. Array initializers have a slightly simpler syntax, and we’ll begin with those. 对象和数组初始化器是其值为新创建的对象或数组的表达式。这些初始化器表达式有时被称为对象字面量和数组字面量。然而，与真正的字面值不同，它们不是主表达式，因为它们包括许多指定属性和元素值的子表达式。数组初始化器的语法稍微简单一些，我们将从这些开始。 An array initializer is a comma-separated list of expressions contained within square brackets. The value of an array initializer is a newly created array. The elements of this new array are initialized to the values of the comma-separated expressions: 数组初始化器是包含在方括号内的以逗号分隔的表达式列表。数组初始化器的值是一个新创建的数组。这个新数组的元素被初始化为逗号分隔的表达式的值: [] // An empty array: no expressions inside brackets means no elements [1+2,3+4] // A 2-element array. First element is 3, second is 7 The element expressions in an array initializer can themselves be array initializers, which means that these expressions can create nested arrays: 数组初始化器中的元素表达式本身可以是数组初始化器，这意味着这些表达式可以创建嵌套数组: let matrix = [[1,2,3], [4,5,6], [7,8,9]]; The element expressions in an array initializer are evaluated each time the array initializer is evaluated. This means that the value of an array initializer expression may be different each time it is evaluated. 数组初始化式中的元素表达式在每次求值数组初始化式时都会求值。这意味着数组初始化器表达式的值在每次求值时可能不同。 Undefined elements can be included in an array literal by simply omitting a value between commas. For example, the following array contains five elements, including three undefined elements: 只需在逗号之间省略一个值，就可以将未定义的元素包含在数组字面量中。例如，下面的数组包含5个元素，其中3个是未定义的元素: let sparseArray = [1,,,,5]; A single trailing comma is allowed after the last expression in an array initializer and does not create an undefined element. However, any array access expression for an index after that of the last expression will necessarily evaluate to undefined. 在数组初始化器的最后一个表达式后面可以使用一个逗号，并且不会创建未定义的元素。然而，在最后一个表达式的索引之后的任何数组访问表达式都必须求值为undefined。 Object initializer expressions are like array initializer expressions, but the square brackets are replaced by curly brackets, and each subexpression is prefixed with a property name and a colon: 对象初始化器表达式与数组初始化器表达式类似，但方括号被花括号替换，每个子表达式前面都有属性名和冒号: let p = { x: 2.3, y: -1.2 }; // An object with 2 properties let q = {}; // An empty object with no properties q.x = 2.3; q.y = -1.2; // Now q has the same properties as p In ES6, object literals have a much more feature-rich syntax (you can find details in §6.10). Object literals can be nested. For example: 在ES6中，对象字面量有更丰富的语法特性(你可以在§6.10中找到细节)。对象字面量可以嵌套。例如: let rectangle = { upperLeft: { x: 2, y: 2 }, lowerRight: { x: 4, y: 5 } }; We’ll see object and array initializers again in Chapters 6 and 7. 我们将在第 6 章和第 7 章再次看到对象和数组初始化器。 ","date":"2020-11-02","objectID":"/posts/ch4/:2:0","tags":null,"title":"第 4 章 表达式和运算符","uri":"/posts/ch4/"},{"categories":null,"content":"4.3 Function Definition Expressions A function definition expression defines a JavaScript function, and the value of such an expression is the newly defined function. In a sense, a function definition expression is a “function literal” in the same way that an object initializer is an “object literal.” A function definition expression typically consists of the keyword function followed by a comma-separated list of zero or more identifiers (the parameter names) in parentheses and a block of JavaScript code (the function body) in curly braces. For example: 函数定义表达式定义一个JavaScript函数，这种表达式的值是新定义的函数。在某种意义上，函数定义表达式是“函数字面量”，就像对象初始化器是“对象字面量”一样。一个函数定义表达式通常由关键字function和一个以逗号分隔的列表组成，列表中包含0个或多个标识符(参数名)和一个JavaScript代码块(函数体)(花括号)。例如: // This function returns the square of the value passed to it. let square = function(x) { return x * x; }; A function definition expression can also include a name for the function. Functions can also be defined using a function statement rather than a function expression. And in ES6 and later, function expressions can use a compact new “arrow function” syntax. Complete details on function definition are in Chapter 8. 函数定义表达式还可以包含函数的名称。函数也可以使用函数语句而不是函数表达式来定义。在ES6及以后的版本中，函数表达式可以使用一种紧凑的新“箭头函数”语法。关于函数定义的完整细节见第 8 章。 ","date":"2020-11-02","objectID":"/posts/ch4/:3:0","tags":null,"title":"第 4 章 表达式和运算符","uri":"/posts/ch4/"},{"categories":null,"content":"4.4 Property Access Expressions A property access expression evaluates to the value of an object property or an array element. JavaScript defines two syntaxes for property access: 属性访问表达式的计算结果为对象属性或数组元素的值。JavaScript为属性访问定义了两种语法: expression . identifier expression [ expression ] The first style of property access is an expression followed by a period and an identifier. The expression specifies the object, and the identifier specifies the name of the desired property. The second style of property access follows the first expression (the object or array) with another expression in square brackets. This second expression specifies the name of the desired property or the index of the desired array element. Here are some concrete examples: 属性访问的第一种样式是一个表达式，后面跟着句点和标识符。表达式指定对象，标识符指定所需属性的名称。第二种类型的属性访问跟在第一个表达式(对象或数组)后面，方括号中还有另一个表达式。第二个表达式指定所需属性的名称或所需数组元素的索引。以下是一些具体的例子: let o = {x: 1, y: {z: 3}}; // An example object let a = [o, 4, [5, 6]]; // An example array that contains the object o.x // =\u003e 1: property x of expression o o.y.z // =\u003e 3: property z of expression o.y o[\"x\"] // =\u003e 1: property x of object o a[1] // =\u003e 4: element at index 1 of expression a a[2][\"1\"] // =\u003e 6: element at index 1 of expression a[2] a[0].x // =\u003e 1: property x of expression a[0] With either type of property access expression, the expression before the . or [ is first evaluated. If the value is null or undefined, the expression throws a TypeError, since these are the two JavaScript values that cannot have properties. If the object expression is followed by a dot and an identifier, the value of the property named by that identifier is looked up and becomes the overall value of the expression. If the object expression is followed by another expression in square brackets, that second expression is evaluated and converted to a string. The overall value of the expression is then the value of the property named by that string. In either case, if the named property does not exist, then the value of the property access expression is undefined. 使用任一类型的属性访问表达式时，前面的表达式。or[首先被求值。如果值为null或未定义，则表达式抛出TypeError，因为这两个JavaScript值不能具有属性。如果对象表达式后面跟着点和标识符，则该标识符命名的属性的值将被查找并成为表达式的整体值。如果对象表达式后面跟着方括号中的另一个表达式，则计算第二个表达式并将其转换为字符串。表达式的整体值就是由该字符串命名的属性的值。在这两种情况下，如果命名的属性不存在，那么属性访问表达式的值是未定义的。 The .identifier syntax is the simpler of the two property access options, but notice that it can only be used when the property you want to access has a name that is a legal identifier, and when you know the name when you write the program. If the property name includes spaces or punctuation characters, or when it is a number (for arrays), you must use the square bracket notation. Square brackets are also used when the property name is not static but is itself the result of a computation (see §6.3.1 for an example). identifier语法是两种属性访问选项中比较简单的一种，但请注意，只有当您想要访问的属性具有合法标识符的名称，并且在编写程序时知道该名称时，才可以使用它。如果属性名包含空格或标点字符，或者是数字(用于数组)，则必须使用方括号表示法。方括号也用于属性名不是静态的，而是计算的结果(参看§6.3.1的例子)。 Objects and their properties are covered in detail in Chapter 6, and arrays and their elements are covered in Chapter 7. 对象及其属性将在第 6 章详细介绍，数组及其元素将在第 7 章介绍。 ","date":"2020-11-02","objectID":"/posts/ch4/:4:0","tags":null,"title":"第 4 章 表达式和运算符","uri":"/posts/ch4/"},{"categories":null,"content":"4.4.1 Conditional Property Access ES2020 adds two new kinds of property access expressions: ES2020增加了两种新的属性访问表达式: expression ?. identifier expression ?.[ expression ] In JavaScript, the values null and undefined are the only two values that do not have properties. In a regular property access expression using . or [], you get a TypeError if the expression on the left evaluates to null or undefined. You can use ?. and ?.[] syntax to guard against errors of this type. 在JavaScript中，值null和undefined是仅有的两个没有属性的值。在正则属性访问表达式中使用。或者[]，如果左边的表达式计算为null或未定义，则会得到一个TypeError。你可以用?和?。[]语法防止此类错误。 Consider the expression a?.b. If a is null or undefined, then the expression evaluates to undefined without any attempt to access the property b. If a is some other value, then a?.b evaluates to whatever a.b would evaluate to (and if a does not have a property named b, then the value will again be undefined). 考虑一下a? b这个表达式。如果a是null或undefined，则表达式计算为undefined，而没有尝试访问属性b。如果a是其他值，则a?b的值等于a.b的值(如果a没有名为b的属性，那么这个值也将是未定义的)。 This form of property access expression is sometimes called “optional chaining” because it also works for longer “chained” property access expressions like this one: let a = { b: null }; a.b?.c.d // =\u003e undefined a is an object, so a.b is a valid property access expression. But the value of a.b is null, so a.b.c would throw a TypeError. By using ?. instead of . we avoid the TypeError, and a.b?.c evaluates to undefined. This means that (a.b?.c).d will throw a TypeError, because that expression attempts to access a property of the value undefined. But—and this is a very important part of “optional chaining”—a.b?.c.d (without the parentheses) simply evaluates to undefined and does not throw an error. This is because property access with ?. is “short-circuiting”: if the subexpression to the left of ?. evaluates to null or undefined, then the entire expression immediately evaluates to undefined without any further property access attempts. Of course, if a.b is an object, and if that object has no property named c, then a.b?.c.d will again throw a TypeError, and we will want to use another conditional property access: let a = { b: {} }; a.b?.c?.d // =\u003e undefined Conditional property access is also possible using ?.[] instead of []. In the expression a?.[b][c], if the value of a is null or undefined, then the entire expression immediately evaluates to undefined, and subexpressions b and c are never even evaluated. If either of those expressions has side effects, the side effect will not occur if a is not defined: let a; // Oops, we forgot to initialize this variable! let index = 0; try { a[index++]; // Throws TypeError } catch(e) { index // =\u003e 1: increment occurs before TypeError is thrown } a?.[index++] // =\u003e undefined: because a is undefined index // =\u003e 1: not incremented because ?.[] short-circuits a[index++] // !TypeError: can't index undefined. Conditional property access with ?. and ?.[] is one of the newest features of JavaScript. As of early 2020, this new syntax is supported in the current or beta versions of most major browsers. ","date":"2020-11-02","objectID":"/posts/ch4/:4:1","tags":null,"title":"第 4 章 表达式和运算符","uri":"/posts/ch4/"},{"categories":null,"content":"4.5 Invocation Expressions An invocation expression is JavaScript’s syntax for calling (or executing) a function or method. It starts with a function expression that identifies the function to be called. The function expression is followed by an open parenthesis, a comma-separated list of zero or more argument expressions, and a close parenthesis. Some examples: f(0) // f is the function expression; 0 is the argument expression. Math.max(x,y,z) // Math.max is the function; x, y, and z are the arguments. a.sort() // a.sort is the function; there are no arguments. When an invocation expression is evaluated, the function expression is evaluated first, and then the argument expressions are evaluated to produce a list of argument values. If the value of the function expression is not a function, a TypeError is thrown. Next, the argument values are assigned, in order, to the parameter names specified when the function was defined, and then the body of the function is executed. If the function uses a return statement to return a value, then that value becomes the value of the invocation expression. Otherwise, the value of the invocation expression is undefined. Complete details on function invocation, including an explanation of what happens when the number of argument expressions does not match the number of parameters in the function definition, are in Chapter 8. Every invocation expression includes a pair of parentheses and an expression before the open parenthesis. If that expression is a property access expression, then the invocation is known as a method invocation. In method invocations, the object or array that is the subject of the property access becomes the value of the this keyword while the body of the function is being executed. This enables an object-oriented programming paradigm in which functions (which we call “methods” when used this way) operate on the object of which they are part. See Chapter 9 for details. ","date":"2020-11-02","objectID":"/posts/ch4/:5:0","tags":null,"title":"第 4 章 表达式和运算符","uri":"/posts/ch4/"},{"categories":null,"content":"4.5.1 Conditional Invocation In ES2020, you can also invoke a function using ?.() instead of (). Normally when you invoke a function, if the expression to the left of the parentheses is null or undefined or any other non-function, a TypeError is thrown. With the new ?.() invocation syntax, if the expression to the left of the ?. evaluates to null or undefined, then the entire invocation expression evaluates to undefined and no exception is thrown. Array objects have a sort() method that can optionally be passed a function argument that defines the desired sorting order for the array elements. Before ES2020, if you wanted to write a method like sort() that takes an optional function argument, you would typically use an if statement to check that the function argument was defined before invoking it in the body of the if: function square(x, log) { // The second argument is an optional function if (log) { // If the optional function is passed log(x); // Invoke it } return x * x; // Return the square of the argument } With this conditional invocation syntax of ES2020, however, you can simply write the function invocation using ?.(), knowing that invocation will only happen if there is actually a value to be invoked: function square(x, log) { // The second argument is an optional function log?.(x); // Call the function if there is one return x * x; // Return the square of the argument } Note, however, that ?.() only checks whether the lefthand side is null or undefined. It does not verify that the value is actually a function. So the square() function in this example would still throw an exception if you passed two numbers to it, for example. Like conditional property access expressions (§4.4.1), function invocation with ?.() is short-circuiting: if the value to the left of ?. is null or undefined, then none of the argument expressions within the parentheses are evaluated: let f = null, x = 0; try { f(x++); // Throws TypeError because f is null } catch(e) { x // =\u003e 1: x gets incremented before the exception is thrown } f?.(x++) // =\u003e undefined: f is null, but no exception thrown x // =\u003e 1: increment is skipped because of short-circuiting Conditional invocation expressions with ?.() work just as well for methods as they do for functions. But because method invocation also involves property access, it is worth taking a moment to be sure you understand the differences between the following expressions: o.m() // Regular property access, regular invocation o?.m() // Conditional property access, regular invocation o.m?.() // Regular property access, conditional invocation In the first expression, o must be an object with a property m and the value of that property must be a function. In the second expression, if o is null or undefined, then the expression evaluates to undefined. But if o has any other value, then it must have a property m whose value is a function. And in the third expression, o must not be null or undefined. If it does not have a property m, or if the value of that property is null, then the entire expression evaluates to undefined. Conditional invocation with ?.() is one of the newest features of JavaScript. As of the first months of 2020, this new syntax is supported in the current or beta versions of most major browsers. ","date":"2020-11-02","objectID":"/posts/ch4/:5:1","tags":null,"title":"第 4 章 表达式和运算符","uri":"/posts/ch4/"},{"categories":null,"content":"4.6 Object Creation Expressions An object creation expression creates a new object and invokes a function (called a constructor) to initialize the properties of that object. Object creation expressions are like invocation expressions except that they are prefixed with the keyword new: new Object() new Point(2,3) If no arguments are passed to the constructor function in an object creation expression, the empty pair of parentheses can be omitted: new Object new Date The value of an object creation expression is the newly created object. Constructors are explained in more detail in Chapter 9. ","date":"2020-11-02","objectID":"/posts/ch4/:6:0","tags":null,"title":"第 4 章 表达式和运算符","uri":"/posts/ch4/"},{"categories":null,"content":"4.7 Operator Overview Operators are used for JavaScript’s arithmetic expressions, comparison expressions, logical expressions, assignment expressions, and more. Table 4-1 summarizes the operators and serves as a convenient reference. Note that most operators are represented by punctuation characters such as + and =. Some, however, are represented by keywords such as delete and instanceof. Keyword operators are regular operators, just like those expressed with punctuation; they simply have a less succinct syntax. Table 4-1 is organized by operator precedence. The operators listed first have higher precedence than those listed last. Operators separated by a horizontal line have different precedence levels. The column labeled A gives the operator associativity, which can be L (left-to-right) or R (right-to-left), and the column N specifies the number of operands. The column labeled Types lists the expected types of the operands and (after the → symbol) the result type for the operator. The subsections that follow the table explain the concepts of precedence, associativity, and operand type. The operators themselves are individually documented following that discussion. Table 4-1. JavaScript operators Operator Operation A N Types ++ Pre- or post-increment R 1 lval→num – Pre- or post-decrement R 1 lval→num - Negate number R 1 num→num + Convert to number R 1 any→num ~ Invert bits R 1 int→int ! Invert boolean value R 1 bool→bool delete Remove a property R 1 lval→bool typeof Determine type of operand R 1 any→str void Return undefined value R 1 any→undef ** Exponentiate R 2 num,num→num *, /, % Multiply, divide, remainder L 2 num,num→num +, - Add, subtract L 2 num,num→num + Concatenate strings L 2 str,str→str « Shift left L 2 int,int→int \u003e\u003e Shift right with sign extension L 2 int,int→int \u003e\u003e\u003e Shift right with zero extension L 2 int,int→int \u003c, \u003c=,\u003e, \u003e= Compare in numeric order L 2 num,num→bool \u003c, \u003c=,\u003e, \u003e= Compare in alphabetical order L 2 str,str→bool instanceof Test object class L 2 obj,func→bool in Test whether property exists L 2 any,obj→bool == Test for non-strict equality L 2 any,any→bool != Test for non-strict inequality L 2 any,any→bool === Test for strict equality L 2 any,any→bool !== Test for strict inequality L 2 any,any→bool \u0026 Compute bitwise AND L 2 int,int→int ^ Compute bitwise XOR L 2 int,int→int | Compute bitwise OR L 2 int,int→int \u0026\u0026 Compute logical AND L 2 any,any→any || Compute logical OR L 2 any,any→any ?? Choose 1st defined operand L 2 any,any→any ?: Choose 2nd or 3rd operand R 3 bool,any,any→any = Assign to a variable or property R 2 lval,any→any **=, *=, /=, %=, Operate and assign R 2 lval,any→any +=, -=, \u0026=, ^=, |=, \u003c\u003c=, \u003e\u003e=, \u003e\u003e\u003e= , Discard 1st operand, return 2nd L 2 any,any→any ","date":"2020-11-02","objectID":"/posts/ch4/:7:0","tags":null,"title":"第 4 章 表达式和运算符","uri":"/posts/ch4/"},{"categories":null,"content":"4.7.1 Number of Operands Operators can be categorized based on the number of operands they expect (their arity). Most JavaScript operators, like the * multiplication operator, are binary operators that combine two expressions into a single, more complex expression. That is, they expect two operands. JavaScript also supports a number of unary operators, which convert a single expression into a single, more complex expression. The − operator in the expression −x is a unary operator that performs the operation of negation on the operand x. Finally, JavaScript supports one ternary operator, the conditional operator ?:, which combines three expressions into a single expression. ","date":"2020-11-02","objectID":"/posts/ch4/:7:1","tags":null,"title":"第 4 章 表达式和运算符","uri":"/posts/ch4/"},{"categories":null,"content":"4.7.2 Operand and Result Type Some operators work on values of any type, but most expect their operands to be of a specific type, and most operators return (or evaluate to) a value of a specific type. The Types column in Table 4-1 specifies operand types (before the arrow) and result type (after the arrow) for the operators. JavaScript operators usually convert the type (see §3.9) of their operands as needed. The multiplication operator * expects numeric operands, but the expression “3” * “5” is legal because JavaScript can convert the operands to numbers. The value of this expression is the number 15, not the string “15”, of course. Remember also that every JavaScript value is either “truthy” or “falsy,” so operators that expect boolean operands will work with an operand of any type. Some operators behave differently depending on the type of the operands used with them. Most notably, the + operator adds numeric operands but concatenates string operands. Similarly, the comparison operators such as \u003c perform comparison in numerical or alphabetical order depending on the type of the operands. The descriptions of individual operators explain their type-dependencies and specify what type conversions they perform. Notice that the assignment operators and a few of the other operators listed in Table 4-1 expect an operand of type lval. lvalue is a historical term that means “an expression that can legally appear on the left side of an assignment expression.” In JavaScript, variables, properties of objects, and elements of arrays are lvalues. ","date":"2020-11-02","objectID":"/posts/ch4/:7:2","tags":null,"title":"第 4 章 表达式和运算符","uri":"/posts/ch4/"},{"categories":null,"content":"4.7.3 Operator Side Effects Evaluating a simple expression like 2 * 3 never affects the state of your program, and any future computation your program performs will be unaffected by that evaluation. Some expressions, however, have side effects, and their evaluation may affect the result of future evaluations. The assignment operators are the most obvious example: if you assign a value to a variable or property, that changes the value of any expression that uses that variable or property. The ++ and – increment and decrement operators are similar, since they perform an implicit assignment. The delete operator also has side effects: deleting a property is like (but not the same as) assigning undefined to the property. No other JavaScript operators have side effects, but function invocation and object creation expressions will have side effects if any of the operators used in the function or constructor body have side effects. ","date":"2020-11-02","objectID":"/posts/ch4/:7:3","tags":null,"title":"第 4 章 表达式和运算符","uri":"/posts/ch4/"},{"categories":null,"content":"4.7.4 Operator Precedence The operators listed in Table 4-1 are arranged in order from high precedence to low precedence, with horizontal lines separating groups of operators at the same precedence level. Operator precedence controls the order in which operations are performed. Operators with higher precedence (nearer the top of the table) are performed before those with lower precedence (nearer to the bottom). Consider the following expression: w = x + y*z; The multiplication operator * has a higher precedence than the addition operator +, so the multiplication is performed before the addition. Furthermore, the assignment operator = has the lowest precedence, so the assignment is performed after all the operations on the right side are completed. Operator precedence can be overridden with the explicit use of parentheses. To force the addition in the previous example to be performed first, write: w = (x + y)*z; Note that property access and invocation expressions have higher precedence than any of the operators listed in Table 4-1. Consider this expression: // my is an object with a property named functions whose value is an // array of functions. We invoke function number x, passing it argument // y, and then we ask for the type of the value returned. typeof my.functions[x](y) Although typeof is one of the highest-priority operators, the typeof operation is performed on the result of the property access, array index, and function invocation, all of which have higher priority than operators. In practice, if you are at all unsure about the precedence of your operators, the simplest thing to do is to use parentheses to make the evaluation order explicit. The rules that are important to know are these: multiplication and division are performed before addition and subtraction, and assignment has very low precedence and is almost always performed last. When new operators are added to JavaScript, they do not always fit naturally into this precedence scheme. The ?? operator (§4.13.2) is shown in the table as lower-precedence than || and \u0026\u0026, but, in fact, its precedence relative to those operators is not defined, and ES2020 requires you to explicitly use parentheses if you mix ?? with either || or \u0026\u0026. Similarly, the new ** exponentiation operator does not have a well-defined precedence relative to the unary negation operator, and you must use parentheses when combining negation with exponentiation. ","date":"2020-11-02","objectID":"/posts/ch4/:7:4","tags":null,"title":"第 4 章 表达式和运算符","uri":"/posts/ch4/"},{"categories":null,"content":"4.7.5 Operator Associativity In Table 4-1, the column labeled A specifies the associativity of the operator. A value of L specifies left-to-right associativity, and a value of R specifies right-to-left associativity. The associativity of an operator specifies the order in which operations of the same precedence are performed. Left-to-right associativity means that operations are performed from left to right. For example, the subtraction operator has left-to-right associativity, so: w = x - y - z; is the same as: w = ((x - y) - z); On the other hand, the following expressions: y = a ** b ** c; x = ~-y; w = x = y = z; q = a?b:c?d:e?f:g; are equivalent to: y = (a ** (b ** c)); x = ~(-y); w = (x = (y = z)); q = a?b:(c?d:(e?f:g)); because the exponentiation, unary, assignment, and ternary conditional operators have right-to-left associativity. ","date":"2020-11-02","objectID":"/posts/ch4/:7:5","tags":null,"title":"第 4 章 表达式和运算符","uri":"/posts/ch4/"},{"categories":null,"content":"4.7.6 Order of Evaluation Operator precedence and associativity specify the order in which operations are performed in a complex expression, but they do not specify the order in which the subexpressions are evaluated. JavaScript always evaluates expressions in strictly left-to-right order. In the expression w = x + y * z, for example, the subexpression w is evaluated first, followed by x, y, and z. Then the values of y and z are multiplied, added to the value of x, and assigned to the variable or property specified by expression w. Adding parentheses to the expressions can change the relative order of the multiplication, addition, and assignment, but not the left-to-right order of evaluation. Order of evaluation only makes a difference if any of the expressions being evaluated has side effects that affect the value of another expression. If expression x increments a variable that is used by expression z, then the fact that x is evaluated before z is important. ","date":"2020-11-02","objectID":"/posts/ch4/:7:6","tags":null,"title":"第 4 章 表达式和运算符","uri":"/posts/ch4/"},{"categories":null,"content":"4.8 Arithmetic Expressions This section covers the operators that perform arithmetic or other numerical manipulations on their operands. The exponentiation, multiplication, division, and subtraction operators are straightforward and are covered first. The addition operator gets a subsection of its own because it can also perform string concatenation and has some unusual type conversion rules. The unary operators and the bitwise operators are also covered in subsections of their own. Most of these arithmetic operators (except as noted as follows) can be used with BigInt (see §3.2.5) operands or with regular numbers, as long as you don’t mix the two types. The basic arithmetic operators are ** (exponentiation), * (multiplication), / (division), % (modulo: remainder after division), + (addition), and - (subtraction). As noted, we’ll discuss the + operator in a section of its own. The other five basic operators simply evaluate their operands, convert the values to numbers if necessary, and then compute the power, product, quotient, remainder, or difference. Non-numeric operands that cannot convert to numbers convert to the NaN value. If either operand is (or converts to) NaN, the result of the operation is (almost always) NaN. The ** operator has higher precedence than *, /, and % (which in turn have higher precedence than + and -). Unlike the other operators, ** works right-to-left, so 2**2**3 is the same as 2**8, not 4**3. There is a natural ambiguity to expressions like -3**2. Depending on the relative precedence of unary minus and exponentiation, that expression could mean (-3)**2 or -(3**2). Different languages handle this differently, and rather than pick sides, JavaScript simply makes it a syntax error to omit parentheses in this case, forcing you to write an unambiguous expression. ** is JavaScript’s newest arithmetic operator: it was added to the language with ES2016. The Math.pow() function has been available since the earliest versions of JavaScript, however, and it performs exactly the same operation as the ** operator. The / operator divides its first operand by its second. If you are used to programming languages that distinguish between integer and floating-point numbers, you might expect to get an integer result when you divide one integer by another. In JavaScript, however, all numbers are floating-point, so all division operations have floating-point results: 5/2 evaluates to 2.5, not 2. Division by zero yields positive or negative infinity, while 0/0 evaluates to NaN: neither of these cases raises an error. The % operator computes the first operand modulo the second operand. In other words, it returns the remainder after whole-number division of the first operand by the second operand. The sign of the result is the same as the sign of the first operand. For example, 5 % 2 evaluates to 1, and -5 % 2 evaluates to -1. While the modulo operator is typically used with integer operands, it also works for floating-point values. For example, 6.5 % 2.1 evaluates to 0.2. ","date":"2020-11-02","objectID":"/posts/ch4/:8:0","tags":null,"title":"第 4 章 表达式和运算符","uri":"/posts/ch4/"},{"categories":null,"content":"4.8.1 The + Operator The binary + operator adds numeric operands or concatenates string operands: 1 + 2 // =\u003e 3 \"hello\" + \" \" + \"there\" // =\u003e \"hello there\" \"1\" + \"2\" // =\u003e \"12\" When the values of both operands are numbers, or are both strings, then it is obvious what the + operator does. In any other case, however, type conversion is necessary, and the operation to be performed depends on the conversion performed. The conversion rules for + give priority to string concatenation: if either of the operands is a string or an object that converts to a string, the other operand is converted to a string and concatenation is performed. Addition is performed only if neither operand is string-like. Technically, the + operator behaves like this: If either of its operand values is an object, it converts it to a primitive using the object-to-primitive algorithm described in §3.9.3. Date objects are converted by their toString() method, and all other objects are converted via valueOf(), if that method returns a primitive value. However, most objects do not have a useful valueOf() method, so they are converted via toString() as well. After object-to-primitive conversion, if either operand is a string, the other is converted to a string and concatenation is performed. Otherwise, both operands are converted to numbers (or to NaN) and addition is performed. Here are some examples: 1 + 2 // =\u003e 3: addition \"1\" + \"2\" // =\u003e \"12\": concatenation \"1\" + 2 // =\u003e \"12\": concatenation after number-to-string 1 + {} // =\u003e \"1[object Object]\": concatenation after object-to-string true + true // =\u003e 2: addition after boolean-to-number 2 + null // =\u003e 2: addition after null converts to 0 2 + undefined // =\u003e NaN: addition after undefined converts to NaN Finally, it is important to note that when the + operator is used with strings and numbers, it may not be associative. That is, the result may depend on the order in which operations are performed. For example: 1 + 2 + \" blind mice\" // =\u003e \"3 blind mice\" 1 + (2 + \" blind mice\") // =\u003e \"12 blind mice\" The first line has no parentheses, and the + operator has left-to-right associativity, so the two numbers are added first, and their sum is concatenated with the string. In the second line, parentheses alter this order of operations: the number 2 is concatenated with the string to produce a new string. Then the number 1 is concatenated with the new string to produce the final result. ","date":"2020-11-02","objectID":"/posts/ch4/:8:1","tags":null,"title":"第 4 章 表达式和运算符","uri":"/posts/ch4/"},{"categories":null,"content":"4.8.2 Unary Arithmetic Operators Unary operators modify the value of a single operand to produce a new value. In JavaScript, the unary operators all have high precedence and are all right-associative. The arithmetic unary operators described in this section (+, -, ++, and –) all convert their single operand to a number, if necessary. Note that the punctuation characters + and - are used as both unary and binary operators. The unary arithmetic operators are the following: Unary plus (+) The unary plus operator converts its operand to a number (or to NaN) and returns that converted value. When used with an operand that is already a number, it doesn’t do anything. This operator may not be used with BigInt values, since they cannot be converted to regular numbers. Unary minus (-) When - is used as a unary operator, it converts its operand to a number, if necessary, and then changes the sign of the result. Increment (++) The ++ operator increments (i.e., adds 1 to) its single operand, which must be an lvalue (a variable, an element of an array, or a property of an object). The operator converts its operand to a number, adds 1 to that number, and assigns the incremented value back into the variable, element, or property. The return value of the ++ operator depends on its position relative to the operand. When used before the operand, where it is known as the pre-increment operator, it increments the operand and evaluates to the incremented value of that operand. When used after the operand, where it is known as the post-increment operator, it increments its operand but evaluates to the unincremented value of that operand. Consider the difference between these two lines of code: let i = 1, j = ++i; // i and j are both 2 let n = 1, m = n++; // n is 2, m is 1 Note that the expression x++ is not always the same as x=x+1. The ++ operator never performs string concatenation: it always converts its operand to a number and increments it. If x is the string “1”, ++x is the number 2, but x+1 is the string “11”. Also note that, because of JavaScript’s automatic semicolon insertion, you cannot insert a line break between the post-increment operator and the operand that precedes it. If you do so, JavaScript will treat the operand as a complete statement by itself and insert a semicolon before it. This operator, in both its pre- and post-increment forms, is most commonly used to increment a counter that controls a for loop (§5.4.3). Decrement (–) The – operator expects an lvalue operand. It converts the value of the operand to a number, subtracts 1, and assigns the decremented value back to the operand. Like the ++ operator, the return value of – depends on its position relative to the operand. When used before the operand, it decrements and returns the decremented value. When used after the operand, it decrements the operand but returns the undecremented value. When used after its operand, no line break is allowed between the operand and the operator. ","date":"2020-11-02","objectID":"/posts/ch4/:8:2","tags":null,"title":"第 4 章 表达式和运算符","uri":"/posts/ch4/"},{"categories":null,"content":"4.8.3 Bitwise Operators The bitwise operators perform low-level manipulation of the bits in the binary representation of numbers. Although they do not perform traditional arithmetic operations, they are categorized as arithmetic operators here because they operate on numeric operands and return a numeric value. Four of these operators perform Boolean algebra on the individual bits of the operands, behaving as if each bit in each operand were a boolean value (1=true, 0=false). The other three bitwise operators are used to shift bits left and right. These operators are not commonly used in JavaScript programming, and if you are not familiar with the binary representation of integers, including the two’s complement representation of negative integers, you can probably skip this section. The bitwise operators expect integer operands and behave as if those values were represented as 32-bit integers rather than 64-bit floating-point values. These operators convert their operands to numbers, if necessary, and then coerce the numeric values to 32-bit integers by dropping any fractional part and any bits beyond the 32nd. The shift operators require a right-side operand between 0 and 31. After converting this operand to an unsigned 32-bit integer, they drop any bits beyond the 5th, which yields a number in the appropriate range. Surprisingly, NaN, Infinity, and -Infinity all convert to 0 when used as operands of these bitwise operators. All of these bitwise operators except »\u003e can be used with regular number operands or with BigInt (see §3.2.5) operands. Bitwise AND (\u0026) The \u0026 operator performs a Boolean AND operation on each bit of its integer arguments. A bit is set in the result only if the corresponding bit is set in both operands. For example, 0x1234 \u0026 0x00FF evaluates to 0x0034. Bitwise OR (|) The | operator performs a Boolean OR operation on each bit of its integer arguments. A bit is set in the result if the corresponding bit is set in one or both of the operands. For example, 0x1234 | 0x00FF evaluates to 0x12FF. Bitwise XOR (^) The ^ operator performs a Boolean exclusive OR operation on each bit of its integer arguments. Exclusive OR means that either operand one is true or operand two is true, but not both. A bit is set in this operation’s result if a corresponding bit is set in one (but not both) of the two operands. For example, 0xFF00 ^ 0xF0F0 evaluates to 0x0FF0. Bitwise NOT (~) The ~ operator is a unary operator that appears before its single integer operand. It operates by reversing all bits in the operand. Because of the way signed integers are represented in JavaScript, applying the ~ operator to a value is equivalent to changing its sign and subtracting 1. For example, ~0x0F evaluates to 0xFFFFFFF0, or −16. Shift left («) The « operator moves all bits in its first operand to the left by the number of places specified in the second operand, which should be an integer between 0 and 31. For example, in the operation a « 1, the first bit (the ones bit) of a becomes the second bit (the twos bit), the second bit of a becomes the third, etc. A zero is used for the new first bit, and the value of the 32nd bit is lost. Shifting a value left by one position is equivalent to multiplying by 2, shifting two positions is equivalent to multiplying by 4, and so on. For example, 7 « 2 evaluates to 28. Shift right with sign (») The » operator moves all bits in its first operand to the right by the number of places specified in the second operand (an integer between 0 and 31). Bits that are shifted off the right are lost. The bits filled in on the left depend on the sign bit of the original operand, in order to preserve the sign of the result. If the first operand is positive, the result has zeros placed in the high bits; if the first operand is negative, the result has ones placed in the high bits. Shifting a positive value right one place is equivalent to dividing by 2 (discarding the remainder), shifting right two places is equivalent","date":"2020-11-02","objectID":"/posts/ch4/:8:3","tags":null,"title":"第 4 章 表达式和运算符","uri":"/posts/ch4/"},{"categories":null,"content":"4.9 Relational Expressions This section describes JavaScript’s relational operators. These operators test for a relationship (such as “equals,” “less than,” or “property of”) between two values and return true or false depending on whether that relationship exists. Relational expressions always evaluate to a boolean value, and that value is often used to control the flow of program execution in if, while, and for statements (see Chapter 5). The subsections that follow document the equality and inequality operators, the comparison operators, and JavaScript’s other two relational operators, in and instanceof. ","date":"2020-11-02","objectID":"/posts/ch4/:9:0","tags":null,"title":"第 4 章 表达式和运算符","uri":"/posts/ch4/"},{"categories":null,"content":"4.9.1 Equality and Inequality Operators The == and === operators check whether two values are the same, using two different definitions of sameness. Both operators accept operands of any type, and both return true if their operands are the same and false if they are different. The === operator is known as the strict equality operator (or sometimes the identity operator), and it checks whether its two operands are “identical” using a strict definition of sameness. The == operator is known as the equality operator; it checks whether its two operands are “equal” using a more relaxed definition of sameness that allows type conversions. The != and !== operators test for the exact opposite of the == and === operators. The != inequality operator returns false if two values are equal to each other according to == and returns true otherwise. The !== operator returns false if two values are strictly equal to each other and returns true otherwise. As you’ll see in §4.10, the ! operator computes the Boolean NOT operation. This makes it easy to remember that != and !== stand for “not equal to” and “not strictly equal to.” THE =, ==, AND === OPERATORS JavaScript supports =, ==, and === operators. Be sure you understand the differences between these assignment, equality, and strict equality operators, and be careful to use the correct one when coding! Although it is tempting to read all three operators as “equals,” it may help to reduce confusion if you read “gets” or “is assigned” for =, “is equal to” for ==, and “is strictly equal to” for ===. The == operator is a legacy feature of JavaScript and is widely considered to be a source of bugs. You should almost always use === instead of ==, and !== instead of !=. As mentioned in §3.8, JavaScript objects are compared by reference, not by value. An object is equal to itself, but not to any other object. If two distinct objects have the same number of properties, with the same names and values, they are still not equal. Similarly, two arrays that have the same elements in the same order are not equal to each other. STRICT EQUALITY The strict equality operator === evaluates its operands, then compares the two values as follows, performing no type conversion: If the two values have different types, they are not equal. If both values are null or both values are undefined, they are equal. If both values are the boolean value true or both are the boolean value false, they are equal. If one or both values is NaN, they are not equal. (This is surprising, but the NaN value is never equal to any other value, including itself! To check whether a value x is NaN, use x !== x, or the global isNaN() function.) If both values are numbers and have the same value, they are equal. If one value is 0 and the other is -0, they are also equal. If both values are strings and contain exactly the same 16-bit values (see the sidebar in §3.3) in the same positions, they are equal. If the strings differ in length or content, they are not equal. Two strings may have the same meaning and the same visual appearance, but still be encoded using different sequences of 16-bit values. JavaScript performs no Unicode normalization, and a pair of strings like this is not considered equal to the === or == operators. If both values refer to the same object, array, or function, they are equal. If they refer to different objects, they are not equal, even if both objects have identical properties. EQUALITY WITH TYPE CONVERSION The equality operator == is like the strict equality operator, but it is less strict. If the values of the two operands are not the same type, it attempts some type conversions and tries the comparison again: If the two values have the same type, test them for strict equality as described previously. If they are strictly equal, they are equal. If they are not strictly equal, they are not equal. If the two values do not have the same type, the == operator may still consider them equal. It uses the following rules and","date":"2020-11-02","objectID":"/posts/ch4/:9:1","tags":null,"title":"第 4 章 表达式和运算符","uri":"/posts/ch4/"},{"categories":null,"content":"4.9.2 Comparison Operators The comparison operators test the relative order (numerical or alphabetical) of their two operands: Less than (\u003c) The \u003c operator evaluates to true if its first operand is less than its second operand; otherwise, it evaluates to false. Greater than (\u003e) The \u003e operator evaluates to true if its first operand is greater than its second operand; otherwise, it evaluates to false. Less than or equal (\u003c=) The \u003c= operator evaluates to true if its first operand is less than or equal to its second operand; otherwise, it evaluates to false. Greater than or equal (\u003e=) The \u003e= operator evaluates to true if its first operand is greater than or equal to its second operand; otherwise, it evaluates to false. The operands of these comparison operators may be of any type. Comparison can be performed only on numbers and strings, however, so operands that are not numbers or strings are converted. Comparison and conversion occur as follows: If either operand evaluates to an object, that object is converted to a primitive value, as described at the end of §3.9.3; if its valueOf() method returns a primitive value, that value is used. Otherwise, the return value of its toString() method is used. If, after any required object-to-primitive conversion, both operands are strings, the two strings are compared, using alphabetical order, where “alphabetical order” is defined by the numerical order of the 16-bit Unicode values that make up the strings. If, after object-to-primitive conversion, at least one operand is not a string, both operands are converted to numbers and compared numerically. 0 and -0 are considered equal. Infinity is larger than any number other than itself, and -Infinity is smaller than any number other than itself. If either operand is (or converts to) NaN, then the comparison operator always returns false. Although the arithmetic operators do not allow BigInt values to be mixed with regular numbers, the comparison operators do allow comparisons between numbers and BigInts. Remember that JavaScript strings are sequences of 16-bit integer values, and that string comparison is just a numerical comparison of the values in the two strings. The numerical encoding order defined by Unicode may not match the traditional collation order used in any particular language or locale. Note in particular that string comparison is case-sensitive, and all capital ASCII letters are “less than” all lowercase ASCII letters. This rule can cause confusing results if you do not expect it. For example, according to the \u003c operator, the string “Zoo” comes before the string “aardvark”. For a more robust string-comparison algorithm, try the String.localeCompare() method, which also takes locale-specific definitions of alphabetical order into account. For case-insensitive comparisons, you can convert the strings to all lowercase or all uppercase using String.toLowerCase() or String.toUpperCase(). And, for a more general and better localized string comparison tool, use the Intl.Collator class described in §11.7.3. Both the + operator and the comparison operators behave differently for numeric and string operands. + favors strings: it performs concatenation if either operand is a string. The comparison operators favor numbers and only perform string comparison if both operands are strings: 1 + 2 // =\u003e 3: addition. \"1\" + \"2\" // =\u003e \"12\": concatenation. \"1\" + 2 // =\u003e \"12\": 2 is converted to \"2\". 11 \u003c 3 // =\u003e false: numeric comparison. \"11\" \u003c \"3\" // =\u003e true: string comparison. \"11\" \u003c 3 // =\u003e false: numeric comparison, \"11\" converted to 11. \"one\" \u003c 3 // =\u003e false: numeric comparison, \"one\" converted to NaN. Finally, note that the \u003c= (less than or equal) and \u003e= (greater than or equal) operators do not rely on the equality or strict equality operators for determining whether two values are “equal.” Instead, the less-than-or-equal operator is simply defined as “not greater than,” and the greater-than-or-equal operator is defined as “not less than.” The o","date":"2020-11-02","objectID":"/posts/ch4/:9:2","tags":null,"title":"第 4 章 表达式和运算符","uri":"/posts/ch4/"},{"categories":null,"content":"4.9.3 The in Operator The in operator expects a left-side operand that is a string, symbol, or value that can be converted to a string. It expects a right-side operand that is an object. It evaluates to true if the left-side value is the name of a property of the right-side object. For example: let point = {x: 1, y: 1}; // Define an object \"x\" in point // =\u003e true: object has property named \"x\" \"z\" in point // =\u003e false: object has no \"z\" property. \"toString\" in point // =\u003e true: object inherits toString method let data = [7,8,9]; // An array with elements (indices) 0, 1, and 2 \"0\" in data // =\u003e true: array has an element \"0\" 1 in data // =\u003e true: numbers are converted to strings 3 in data // =\u003e false: no element 3 ","date":"2020-11-02","objectID":"/posts/ch4/:9:3","tags":null,"title":"第 4 章 表达式和运算符","uri":"/posts/ch4/"},{"categories":null,"content":"4.9.4 The instanceof Operator The instanceof operator expects a left-side operand that is an object and a right-side operand that identifies a class of objects. The operator evaluates to true if the left-side object is an instance of the right-side class and evaluates to false otherwise. Chapter 9 explains that, in JavaScript, classes of objects are defined by the constructor function that initializes them. Thus, the right-side operand of instanceof should be a function. Here are examples: let d = new Date(); // Create a new object with the Date() constructor d instanceof Date // =\u003e true: d was created with Date() d instanceof Object // =\u003e true: all objects are instances of Object d instanceof Number // =\u003e false: d is not a Number object let a = [1, 2, 3]; // Create an array with array literal syntax a instanceof Array // =\u003e true: a is an array a instanceof Object // =\u003e true: all arrays are objects a instanceof RegExp // =\u003e false: arrays are not regular expressions Note that all objects are instances of Object. instanceof considers the “superclasses” when deciding whether an object is an instance of a class. If the left-side operand of instanceof is not an object, instanceof returns false. If the righthand side is not a class of objects, it throws a TypeError. In order to understand how the instanceof operator works, you must understand the “prototype chain.” This is JavaScript’s inheritance mechanism, and it is described in §6.3.2. To evaluate the expression o instanceof f, JavaScript evaluates f.prototype, and then looks for that value in the prototype chain of o. If it finds it, then o is an instance of f (or of a subclass of f) and the operator returns true. If f.prototype is not one of the values in the prototype chain of o, then o is not an instance of f and instanceof returns false. ","date":"2020-11-02","objectID":"/posts/ch4/:9:4","tags":null,"title":"第 4 章 表达式和运算符","uri":"/posts/ch4/"},{"categories":null,"content":"4.10 Logical Expressions The logical operators \u0026\u0026, ||, and ! perform Boolean algebra and are often used in conjunction with the relational operators to combine two relational expressions into one more complex expression. These operators are described in the subsections that follow. In order to fully understand them, you may want to review the concept of “truthy” and “falsy” values introduced in §3.4. ","date":"2020-11-02","objectID":"/posts/ch4/:10:0","tags":null,"title":"第 4 章 表达式和运算符","uri":"/posts/ch4/"},{"categories":null,"content":"4.10.1 Logical AND (\u0026\u0026) The \u0026\u0026 operator can be understood at three different levels. At the simplest level, when used with boolean operands, \u0026\u0026 performs the Boolean AND operation on the two values: it returns true if and only if both its first operand and its second operand are true. If one or both of these operands is false, it returns false. \u0026\u0026 is often used as a conjunction to join two relational expressions: x === 0 \u0026\u0026 y === 0 // true if, and only if, x and y are both 0 Relational expressions always evaluate to true or false, so when used like this, the \u0026\u0026 operator itself returns true or false. Relational operators have higher precedence than \u0026\u0026 (and ||), so expressions like these can safely be written without parentheses. But \u0026\u0026 does not require that its operands be boolean values. Recall that all JavaScript values are either “truthy” or “falsy.” (See §3.4 for details. The falsy values are false, null, undefined, 0, -0, NaN, and “”. All other values, including all objects, are truthy.) The second level at which \u0026\u0026 can be understood is as a Boolean AND operator for truthy and falsy values. If both operands are truthy, the operator returns a truthy value. Otherwise, one or both operands must be falsy, and the operator returns a falsy value. In JavaScript, any expression or statement that expects a boolean value will work with a truthy or falsy value, so the fact that \u0026\u0026 does not always return true or false does not cause practical problems. Notice that this description says that the operator returns “a truthy value” or “a falsy value” but does not specify what that value is. For that, we need to describe \u0026\u0026 at the third and final level. This operator starts by evaluating its first operand, the expression on its left. If the value on the left is falsy, the value of the entire expression must also be falsy, so \u0026\u0026 simply returns the value on the left and does not even evaluate the expression on the right. On the other hand, if the value on the left is truthy, then the overall value of the expression depends on the value on the righthand side. If the value on the right is truthy, then the overall value must be truthy, and if the value on the right is falsy, then the overall value must be falsy. So when the value on the left is truthy, the \u0026\u0026 operator evaluates and returns the value on the right: let o = {x: 1}; let p = null; o \u0026\u0026 o.x // =\u003e 1: o is truthy, so return value of o.x p \u0026\u0026 p.x // =\u003e null: p is falsy, so return it and don't evaluate p.x It is important to understand that \u0026\u0026 may or may not evaluate its right-side operand. In this code example, the variable p is set to null, and the expression p.x would, if evaluated, cause a TypeError. But the code uses \u0026\u0026 in an idiomatic way so that p.x is evaluated only if p is truthy—not null or undefined. The behavior of \u0026\u0026 is sometimes called short circuiting, and you may sometimes see code that purposely exploits this behavior to conditionally execute code. For example, the following two lines of JavaScript code have equivalent effects: if (a === b) stop(); // Invoke stop() only if a === b (a === b) \u0026\u0026 stop(); // This does the same thing In general, you must be careful whenever you write an expression with side effects (assignments, increments, decrements, or function invocations) on the righthand side of \u0026\u0026. Whether those side effects occur depends on the value of the lefthand side. Despite the somewhat complex way that this operator actually works, it is most commonly used as a simple Boolean algebra operator that works on truthy and falsy values. ","date":"2020-11-02","objectID":"/posts/ch4/:10:1","tags":null,"title":"第 4 章 表达式和运算符","uri":"/posts/ch4/"},{"categories":null,"content":"4.10.2 Logical OR (||) The || operator performs the Boolean OR operation on its two operands. If one or both operands is truthy, it returns a truthy value. If both operands are falsy, it returns a falsy value. Although the || operator is most often used simply as a Boolean OR operator, it, like the \u0026\u0026 operator, has more complex behavior. It starts by evaluating its first operand, the expression on its left. If the value of this first operand is truthy, it short-circuits and returns that truthy value without ever evaluating the expression on the right. If, on the other hand, the value of the first operand is falsy, then || evaluates its second operand and returns the value of that expression. As with the \u0026\u0026 operator, you should avoid right-side operands that include side effects, unless you purposely want to use the fact that the right-side expression may not be evaluated. An idiomatic usage of this operator is to select the first truthy value in a set of alternatives: // If maxWidth is truthy, use that. Otherwise, look for a value in // the preferences object. If that is not truthy, use a hardcoded constant. let max = maxWidth || preferences.maxWidth || 500; Note that if 0 is a legal value for maxWidth, then this code will not work correctly, since 0 is a falsy value. See the ?? operator (§4.13.2) for an alternative. Prior to ES6, this idiom is often used in functions to supply default values for parameters: // Copy the properties of o to p, and return p function copy(o, p) { p = p || {}; // If no object passed for p, use a newly created object. // function body goes here } In ES6 and later, however, this trick is no longer needed because the default parameter value could simply be written in the function definition itself: function copy(o, p={}) { … }. ","date":"2020-11-02","objectID":"/posts/ch4/:10:2","tags":null,"title":"第 4 章 表达式和运算符","uri":"/posts/ch4/"},{"categories":null,"content":"4.10.3 Logical NOT (!) The ! operator is a unary operator; it is placed before a single operand. Its purpose is to invert the boolean value of its operand. For example, if x is truthy, !x evaluates to false. If x is falsy, then !x is true. Unlike the \u0026\u0026 and || operators, the ! operator converts its operand to a boolean value (using the rules described in Chapter 3) before inverting the converted value. This means that ! always returns true or false and that you can convert any value x to its equivalent boolean value by applying this operator twice: !!x (see §3.9.2). As a unary operator, ! has high precedence and binds tightly. If you want to invert the value of an expression like p \u0026\u0026 q, you need to use parentheses: !(p \u0026\u0026 q). It is worth noting two laws of Boolean algebra here that we can express using JavaScript syntax: // DeMorgan's Laws !(p \u0026\u0026 q) === (!p || !q) // =\u003e true: for all values of p and q !(p || q) === (!p \u0026\u0026 !q) // =\u003e true: for all values of p and q ","date":"2020-11-02","objectID":"/posts/ch4/:10:3","tags":null,"title":"第 4 章 表达式和运算符","uri":"/posts/ch4/"},{"categories":null,"content":"4.11 Assignment Expressions JavaScript uses the = operator to assign a value to a variable or property. For example: i = 0; // Set the variable i to 0. o.x = 1; // Set the property x of object o to 1. The = operator expects its left-side operand to be an lvalue: a variable or object property (or array element). It expects its right-side operand to be an arbitrary value of any type. The value of an assignment expression is the value of the right-side operand. As a side effect, the = operator assigns the value on the right to the variable or property on the left so that future references to the variable or property evaluate to the value. Although assignment expressions are usually quite simple, you may sometimes see the value of an assignment expression used as part of a larger expression. For example, you can assign and test a value in the same expression with code like this: (a = b) === 0 If you do this, be sure you are clear on the difference between the = and === operators! Note that = has very low precedence, and parentheses are usually necessary when the value of an assignment is to be used in a larger expression. The assignment operator has right-to-left associativity, which means that when multiple assignment operators appear in an expression, they are evaluated from right to left. Thus, you can write code like this to assign a single value to multiple variables: i = j = k = 0; // Initialize 3 variables to 0 ","date":"2020-11-02","objectID":"/posts/ch4/:11:0","tags":null,"title":"第 4 章 表达式和运算符","uri":"/posts/ch4/"},{"categories":null,"content":"4.11.1 Assignment with Operation Besides the normal = assignment operator, JavaScript supports a number of other assignment operators that provide shortcuts by combining assignment with some other operation. For example, the += operator performs addition and assignment. The following expression: total += salesTax; is equivalent to this one: total = total + salesTax; As you might expect, the += operator works for numbers or strings. For numeric operands, it performs addition and assignment; for string operands, it performs concatenation and assignment. Similar operators include -=, *=, \u0026=, and so on. Table 4-2 lists them all. Table 4-2. Assignment operators Operator Example Equivalent += a += b a = a + b -= a -= b a = a - b *= a *= b a = a * b /= a /= b a = a / b %= a %= b a = a % b **= a **= b a = a ** b «= a «= b a = a « b »= a »= b a = a » b »\u003e= a »\u003e= b a = a »\u003e b \u0026= a \u0026= b a = a \u0026 b |= a |= b a = a | b ^= a ^= b a = a ^ b In most cases, the expression: a op= b where op is an operator, is equivalent to the expression: a = a op b In the first line, the expression a is evaluated once. In the second, it is evaluated twice. The two cases will differ only if a includes side effects such as a function call or an increment operator. The following two assignments, for example, are not the same: data[i++] *= 2; data[i++] = data[i++] * 2; ","date":"2020-11-02","objectID":"/posts/ch4/:11:1","tags":null,"title":"第 4 章 表达式和运算符","uri":"/posts/ch4/"},{"categories":null,"content":"4.12 Evaluation Expressions Like many interpreted languages, JavaScript has the ability to interpret strings of JavaScript source code, evaluating them to produce a value. JavaScript does this with the global function eval(): eval(\"3+2\") // =\u003e 5 Dynamic evaluation of strings of source code is a powerful language feature that is almost never necessary in practice. If you find yourself using eval(), you should think carefully about whether you really need to use it. In particular, eval() can be a security hole, and you should never pass any string derived from user input to eval(). With a language as complicated as JavaScript, there is no way to sanitize user input to make it safe to use with eval(). Because of these security issues, some web servers use the HTTP “Content-Security-Policy” header to disable eval() for an entire website. The subsections that follow explain the basic use of eval() and explain two restricted versions of it that have less impact on the optimizer. IS EVAL() A FUNCTION OR AN OPERATOR? eval() is a function, but it is included in this chapter on expressions because it really should have been an operator. The earliest versions of the language defined an eval() function, and ever since then, language designers and interpreter writers have been placing restrictions on it that make it more and more operator-like. Modern JavaScript interpreters perform a lot of code analysis and optimization. Generally speaking, if a function calls eval(), the interpreter cannot optimize that function. The problem with defining eval() as a function is that it can be given other names: let f = eval; let g = f; If this is allowed, then the interpreter can’t know for sure which functions call eval(), so it cannot optimize aggressively. This issue could have been avoided if eval() was an operator (and a reserved word). We’ll learn (in §4.12.2 and §4.12.3) about restrictions placed on eval() to make it more operator-like. ","date":"2020-11-02","objectID":"/posts/ch4/:12:0","tags":null,"title":"第 4 章 表达式和运算符","uri":"/posts/ch4/"},{"categories":null,"content":"4.12.1 eval() eval() expects one argument. If you pass any value other than a string, it simply returns that value. If you pass a string, it attempts to parse the string as JavaScript code, throwing a SyntaxError if it fails. If it successfully parses the string, then it evaluates the code and returns the value of the last expression or statement in the string or undefined if the last expression or statement had no value. If the evaluated string throws an exception, that exception propogates from the call to eval(). The key thing about eval() (when invoked like this) is that it uses the variable environment of the code that calls it. That is, it looks up the values of variables and defines new variables and functions in the same way that local code does. If a function defines a local variable x and then calls eval(“x”), it will obtain the value of the local variable. If it calls eval(“x=1”), it changes the value of the local variable. And if the function calls eval(“var y = 3;\"), it declares a new local variable y. On the other hand, if the evaluated string uses let or const, the variable or constant declared will be local to the evaluation and will not be defined in the calling environment. Similarly, a function can declare a local function with code like this: eval(\"function f() { return x+1; }\"); If you call eval() from top-level code, it operates on global variables and global functions, of course. Note that the string of code you pass to eval() must make syntactic sense on its own: you cannot use it to paste code fragments into a function. It makes no sense to write eval(“return;\"), for example, because return is only legal within functions, and the fact that the evaluated string uses the same variable environment as the calling function does not make it part of that function. If your string would make sense as a standalone script (even a very short one like x=0 ), it is legal to pass to eval(). Otherwise, eval() will throw a SyntaxError. ","date":"2020-11-02","objectID":"/posts/ch4/:12:1","tags":null,"title":"第 4 章 表达式和运算符","uri":"/posts/ch4/"},{"categories":null,"content":"4.12.2 Global eval() It is the ability of eval() to change local variables that is so problematic to JavaScript optimizers. As a workaround, however, interpreters simply do less optimization on any function that calls eval(). But what should a JavaScript interpreter do, however, if a script defines an alias for eval() and then calls that function by another name? The JavaScript specification declares that when eval() is invoked by any name other than “eval”, it should evaluate the string as if it were top-level global code. The evaluated code may define new global variables or global functions, and it may set global variables, but it will not use or modify any variables local to the calling function, and will not, therefore, interfere with local optimizations. A “direct eval” is a call to the eval() function with an expression that uses the exact, unqualified name “eval” (which is beginning to feel like a reserved word). Direct calls to eval() use the variable environment of the calling context. Any other call—an indirect call—uses the global object as its variable environment and cannot read, write, or define local variables or functions. (Both direct and indirect calls can define new variables only with var. Uses of let and const inside an evaluated string create variables and constants that are local to the evaluation and do not alter the calling or global environment.) The following code demonstrates: const geval = eval; // Using another name does a global eval let x = \"global\", y = \"global\"; // Two global variables function f() { // This function does a local eval let x = \"local\"; // Define a local variable eval(\"x += 'changed';\"); // Direct eval sets local variable return x; // Return changed local variable } function g() { // This function does a global eval let y = \"local\"; // A local variable geval(\"y += 'changed';\"); // Indirect eval sets global variable return y; // Return unchanged local variable } console.log(f(), x); // Local variable changed: prints \"localchanged global\": console.log(g(), y); // Global variable changed: prints \"local globalchanged\": Notice that the ability to do a global eval is not just an accommodation to the needs of the optimizer; it is actually a tremendously useful feature that allows you to execute strings of code as if they were independent, top-level scripts. As noted at the beginning of this section, it is rare to truly need to evaluate a string of code. But if you do find it necessary, you are more likely to want to do a global eval than a local eval. ","date":"2020-11-02","objectID":"/posts/ch4/:12:2","tags":null,"title":"第 4 章 表达式和运算符","uri":"/posts/ch4/"},{"categories":null,"content":"4.12.3 Strict eval() Strict mode (see §5.6.3) imposes further restrictions on the behavior of the eval() function and even on the use of the identifier “eval”. When eval() is called from strict-mode code, or when the string of code to be evaluated itself begins with a “use strict” directive, then eval() does a local eval with a private variable environment. This means that in strict mode, evaluated code can query and set local variables, but it cannot define new variables or functions in the local scope. Furthermore, strict mode makes eval() even more operator-like by effectively making “eval” into a reserved word. You are not allowed to overwrite the eval() function with a new value. And you are not allowed to declare a variable, function, function parameter, or catch block parameter with the name “eval”. ","date":"2020-11-02","objectID":"/posts/ch4/:12:3","tags":null,"title":"第 4 章 表达式和运算符","uri":"/posts/ch4/"},{"categories":null,"content":"4.13 Miscellaneous Operators JavaScript supports a number of other miscellaneous operators, described in the following sections. ","date":"2020-11-02","objectID":"/posts/ch4/:13:0","tags":null,"title":"第 4 章 表达式和运算符","uri":"/posts/ch4/"},{"categories":null,"content":"4.13.1 The Conditional Operator (?:) The conditional operator is the only ternary operator (three operands) in JavaScript and is sometimes actually called the ternary operator. This operator is sometimes written ?:, although it does not appear quite that way in code. Because this operator has three operands, the first goes before the ?, the second goes between the ? and the :, and the third goes after the :. It is used like this: x \u003e 0 ? x : -x // The absolute value of x The operands of the conditional operator may be of any type. The first operand is evaluated and interpreted as a boolean. If the value of the first operand is truthy, then the second operand is evaluated, and its value is returned. Otherwise, if the first operand is falsy, then the third operand is evaluated and its value is returned. Only one of the second and third operands is evaluated; never both. While you can achieve similar results using the if statement (§5.3.1), the ?: operator often provides a handy shortcut. Here is a typical usage, which checks to be sure that a variable is defined (and has a meaningful, truthy value) and uses it if so or provides a default value if not: greeting = \"hello \" + (username ? username : \"there\"); This is equivalent to, but more compact than, the following if statement: greeting = \"hello \"; if (username) { greeting += username; } else { greeting += \"there\"; } ","date":"2020-11-02","objectID":"/posts/ch4/:13:1","tags":null,"title":"第 4 章 表达式和运算符","uri":"/posts/ch4/"},{"categories":null,"content":"4.13.2 First-Defined (??) The first-defined operator ?? evaluates to its first defined operand: if its left operand is not null and not undefined, it returns that value. Otherwise, it returns the value of the right operand. Like the \u0026\u0026 and || operators, ?? is short-circuiting: it only evaluates its second operand if the first operand evaluates to null or undefined. If the expression a has no side effects, then the expression a ?? b is equivalent to: (a !== null \u0026\u0026 a !== undefined) ? a : b ?? is a useful alternative to || (§4.10.2) when you want to select the first defined operand rather than the first truthy operand. Although || is nominally a logical OR operator, it is also used idiomatically to select the first non-falsy operand with code like this: // If maxWidth is truthy, use that. Otherwise, look for a value in // the preferences object. If that is not truthy, use a hardcoded constant. let max = maxWidth || preferences.maxWidth || 500; The problem with this idiomatic use is that zero, the empty string, and false are all falsy values that may be perfectly valid in some circumstances. In this code example, if maxWidth is zero, that value will be ignored. But if we change the || operator to ??, we end up with an expression where zero is a valid value: // If maxWidth is defined, use that. Otherwise, look for a value in // the preferences object. If that is not defined, use a hardcoded constant. let max = maxWidth ?? preferences.maxWidth ?? 500; Here are more examples showing how ?? works when the first operand is falsy. If that operand is falsy but defined, then ?? returns it. It is only when the first operand is “nullish” (i.e., null or undefined) that this operator evaluates and returns the second operand: let options = { timeout: 0, title: \"\", verbose: false, n: null }; options.timeout ?? 1000 // =\u003e 0: as defined in the object options.title ?? \"Untitled\" // =\u003e \"\": as defined in the object options.verbose ?? true // =\u003e false: as defined in the object options.quiet ?? false // =\u003e false: property is not defined options.n ?? 10 // =\u003e 10: property is null Note that the timeout, title, and verbose expressions here would have different values if we used || instead of ??. The ?? operator is similar to the \u0026\u0026 and || operators but does not have higher precedence or lower precedence than they do. If you use it in an expression with either of those operators, you must use explicit parentheses to specify which operation you want to perform first: (a ?? b) || c // ?? first, then || a ?? (b || c) // || first, then ?? a ?? b || c // SyntaxError: parentheses are required The ?? operator is defined by ES2020, and as of early 2020, is newly supported by current or beta versions of all major browsers. This operator is formally called the “nullish coalescing” operator, but I avoid that term because this operator selects one of its operands but does not “coalesce” them in any way that I can see. ","date":"2020-11-02","objectID":"/posts/ch4/:13:2","tags":null,"title":"第 4 章 表达式和运算符","uri":"/posts/ch4/"},{"categories":null,"content":"4.13.3 The typeof Operator typeof is a unary operator that is placed before its single operand, which can be of any type. Its value is a string that specifies the type of the operand. Table 4-3 specifies the value of the typeof operator for any JavaScript value. Table 4-3. Values returned by the typeof operator x typeof x undefined “undefined” null “object” true or false “boolean” any number or NaN “number” any BigInt “bigint” any string “string” any symbol “symbol” any function “function” any nonfunction object “object” You might use the typeof operator in an expression like this: // If the value is a string, wrap it in quotes, otherwise, convert (typeof value === \"string\") ? \"'\" + value + \"'\" : value.toString() Note that typeof returns “object” if the operand value is null. If you want to distinguish null from objects, you’ll have to explicitly test for this special-case value. Although JavaScript functions are a kind of object, the typeof operator considers functions to be sufficiently different that they have their own return value. Because typeof evaluates to “object” for all object and array values other than functions, it is useful only to distinguish objects from other, primitive types. In order to distinguish one class of object from another, you must use other techniques, such as the instanceof operator (see §4.9.4), the class attribute (see §14.4.3), or the constructor property (see §9.2.2 and §14.3). ","date":"2020-11-02","objectID":"/posts/ch4/:13:3","tags":null,"title":"第 4 章 表达式和运算符","uri":"/posts/ch4/"},{"categories":null,"content":"4.13.4 The delete Operator delete is a unary operator that attempts to delete the object property or array element specified as its operand. Like the assignment, increment, and decrement operators, delete is typically used for its property deletion side effect and not for the value it returns. Some examples: let o = { x: 1, y: 2}; // Start with an object delete o.x; // Delete one of its properties \"x\" in o // =\u003e false: the property does not exist anymore let a = [1,2,3]; // Start with an array delete a[2]; // Delete the last element of the array 2 in a // =\u003e false: array element 2 doesn't exist anymore a.length // =\u003e 3: note that array length doesn't change, though Note that a deleted property or array element is not merely set to the undefined value. When a property is deleted, the property ceases to exist. Attempting to read a nonexistent property returns undefined, but you can test for the actual existence of a property with the in operator (§4.9.3). Deleting an array element leaves a “hole” in the array and does not change the array’s length. The resulting array is sparse (§7.3). delete expects its operand to be an lvalue. If it is not an lvalue, the operator takes no action and returns true. Otherwise, delete attempts to delete the specified lvalue. delete returns true if it successfully deletes the specified lvalue. Not all properties can be deleted, however: non-configurable properties (§14.1) are immune from deletion. In strict mode, delete raises a SyntaxError if its operand is an unqualified identifier such as a variable, function, or function parameter: it only works when the operand is a property access expression (§4.4). Strict mode also specifies that delete raises a TypeError if asked to delete any non-configurable (i.e., nondeleteable) property. Outside of strict mode, no exception occurs in these cases, and delete simply returns false to indicate that the operand could not be deleted. Here are some example uses of the delete operator: let o = {x: 1, y: 2}; delete o.x; // Delete one of the object properties; returns true. typeof o.x; // Property does not exist; returns \"undefined\". delete o.x; // Delete a nonexistent property; returns true. delete 1; // This makes no sense, but it just returns true. // Can't delete a variable; returns false, or SyntaxError in strict mode. delete o; // Undeletable property: returns false, or TypeError in strict mode. delete Object.prototype; We’ll see the delete operator again in §6.4. ","date":"2020-11-02","objectID":"/posts/ch4/:13:4","tags":null,"title":"第 4 章 表达式和运算符","uri":"/posts/ch4/"},{"categories":null,"content":"4.13.5 The await Operator await was introduced in ES2017 as a way to make asynchronous programming more natural in JavaScript. You will need to read Chapter 13 to understand this operator. Briefly, however, await expects a Promise object (representing an asynchronous computation) as its sole operand, and it makes your program behave as if it were waiting for the asynchronous computation to complete (but it does this without actually blocking, and it does not prevent other asynchronous operations from proceeding at the same time). The value of the await operator is the fulfillment value of the Promise object. Importantly, await is only legal within functions that have been declared asynchronous with the async keyword. Again, see Chapter 13 for full details. ","date":"2020-11-02","objectID":"/posts/ch4/:13:5","tags":null,"title":"第 4 章 表达式和运算符","uri":"/posts/ch4/"},{"categories":null,"content":"4.13.6 The void Operator void is a unary operator that appears before its single operand, which may be of any type. This operator is unusual and infrequently used; it evaluates its operand, then discards the value and returns undefined. Since the operand value is discarded, using the void operator makes sense only if the operand has side effects. The void operator is so obscure that it is difficult to come up with a practical example of its use. One case would be when you want to define a function that returns nothing but also uses the arrow function shortcut syntax (see §8.1.3) where the body of the function is a single expression that is evaluated and returned. If you are evaluating the expression solely for its side effects and do not want to return its value, then the simplest thing is to use curly braces around the function body. But, as an alternative, you could also use the void operator in this case: let counter = 0; const increment = () =\u003e void counter++; increment() // =\u003e undefined counter // =\u003e 1 ","date":"2020-11-02","objectID":"/posts/ch4/:13:6","tags":null,"title":"第 4 章 表达式和运算符","uri":"/posts/ch4/"},{"categories":null,"content":"4.13.7 The comma Operator (,) The comma operator is a binary operator whose operands may be of any type. It evaluates its left operand, evaluates its right operand, and then returns the value of the right operand. Thus, the following line: i=0, j=1, k=2; evaluates to 2 and is basically equivalent to: i = 0; j = 1; k = 2; The lefthand expression is always evaluated, but its value is discarded, which means that it only makes sense to use the comma operator when the lefthand expression has side effects. The only situation in which the comma operator is commonly used is with a for loop (§5.4.3) that has multiple loop variables: // The first comma below is part of the syntax of the let statement // The second comma is the comma operator: it lets us squeeze 2 // expressions (i++ and j--) into a statement (the for loop) that expects 1. for(let i=0,j=10; i \u003c j; i++,j--) { console.log(i+j); } ","date":"2020-11-02","objectID":"/posts/ch4/:13:7","tags":null,"title":"第 4 章 表达式和运算符","uri":"/posts/ch4/"},{"categories":null,"content":"4.14 Summary This chapter covers a wide variety of topics, and there is lots of reference material here that you may want to reread in the future as you continue to learn JavaScript. Some key points to remember, however, are these: Expressions are the phrases of a JavaScript program. Any expression can be evaluated to a JavaScript value. Expressions can also have side effects (such as variable assignment) in addition to producing a value. Simple expressions such as literals, variable references, and property accesses can be combined with operators to produce larger expressions. JavaScript defines operators for arithmetic, comparisons, Boolean logic, assignment, and bit manipulation, along with some miscellaneous operators, including the ternary conditional operator. The JavaScript + operator is used to both add numbers and concatenate strings. The logical operators \u0026\u0026 and || have special “short-circuiting” behavior and sometimes only evaluate one of their arguments. Common JavaScript idioms require you to understand the special behavior of these operators. ","date":"2020-11-02","objectID":"/posts/ch4/:14:0","tags":null,"title":"第 4 章 表达式和运算符","uri":"/posts/ch4/"},{"categories":null,"content":"Chapter 4 described expressions as JavaScript phrases. By that analogy, statements are JavaScript sentences or commands. Just as English sentences are terminated and separated from one another with periods, JavaScript statements are terminated with semicolons (§2.6). Expressions are evaluated to produce a value, but statements are executed to make something happen. 第 4 章将表达式描述为 JavaScript 短语。根据这个比喻，语句就是 JavaScript 句子或命令。就像英语句子以句点结尾并彼此分开一样，JavaScript 语句以分号结尾（§2.6）。表达式计算来产生一个值，但是语句被执行则使某些事情发生。 One way to “make something happen” is to evaluate an expression that has side effects. Expressions with side effects, such as assignments and function invocations, can stand alone as statements, and when used this way are known as expression statements. A similar category of statements are the declaration statements that declare new variables and define new functions. “使某事发生”的一种方法是对有副作用的表达式求值。带有副作用（如赋值和函数调用）的表达式可以单独作为语句使用，以这种方式使用时称为表达式语句。类似的语句是声明语句，它声明新的变量和定义的新函数。 JavaScript programs are nothing more than a sequence of statements to execute. By default, the JavaScript interpreter executes these statements one after another in the order they are written. Another way to “make something happen” is to alter this default order of execution, and JavaScript has a number of statements or control structures that do just this: JavaScript 程序只不过是一系列顺序执行的语句。默认情况下，JavaScript 解释器按照语句的编写顺序依次执行这些语句。另一种“让事情发生”的方法是改变默认的执行顺序，JavaScript 有很多语句或控制结构就是这样做的: Conditionals 条件 Statements like if and switch that make the JavaScript interpreter execute or skip other statements depending on the value of an expression 类似 if 和 switch 语句，让 JavaScript 解释器根据一个表达式的值计算或跳过一些语句 Loops 循环 Statements like while and for that execute other statements repetitively 类似 while 和 for 语句，重复执行一些语句 Jumps 跳转 Statements like break, return, and throw that cause the interpreter to jump to another part of the program 类似 break、return 和 throw 语句，引发解释器跳转到程序的另一部分 The sections that follow describe the various statements in JavaScript and explain their syntax. Table 5-1, at the end of the chapter, summarizes the syntax. A JavaScript program is simply a sequence of statements, separated from one another with semicolons, so once you are familiar with the statements of JavaScript, you can begin writing JavaScript programs. 接下来的小结讲解各种各样的 JavaScript 语句并解释它们的语法。本章最后表 5-1 总结了语法。JavaScript 程序是简单的顺序语句，被分号分隔，所以一旦熟悉了 JavaScript 语句，就可以开始编写 JavaScript 程序了。 ","date":"2020-11-02","objectID":"/posts/ch5/:0:0","tags":null,"title":"第 5 章 语句","uri":"/posts/ch5/"},{"categories":null,"content":"5.1 Expression Statements The simplest kinds of statements in JavaScript are expressions that have side effects. This sort of statement was shown in Chapter 4. Assignment statements are one major category of expression statements. For example: JavaScript 中最简单的语句是表达式，它们有副作用。下面这个简短的语句在第 4 章出现过。赋值语句是表达式语句分类中主要的语句之一。例如： greeting = \"Hello \" + name; i *= 3; The increment and decrement operators, ++ and –, are related to assignment statements. These have the side effect of changing a variable value, just as if an assignment had been performed: 递增和递减运算符 ++ 和 – 与赋值语句有关。这些具有更改变量值的副作用，就像执行了赋值一样： counter++; The delete operator has the important side effect of deleting an object property. Thus, it is almost always used as a statement, rather than as part of a larger expression: delete 运算符具有删除对象属性的重要副作用。因此，它几乎总是用作语句，而不是用作较大表达式的一部分： delete o.x; Function calls are another major category of expression statements. For example: 函数调用是表达式语句的另一个主要类别。例如： console.log(debugMessage); displaySpinner(); // A hypothetical function to display a spinner in a web app. These function calls are expressions, but they have side effects that affect the host environment or program state, and they are used here as statements. If a function does not have any side effects, there is no sense in calling it, unless it is part of a larger expression or an assignment statement. For example, you wouldn’t just compute a cosine and discard the result: 这些函数调用是表达式，但是它们具有影响主机环境或程序状态的副作用，在这里用作语句。如果函数没有任何副作用，则除非有任何较大的表达式或赋值语句的一部分，否则调用该函数没有任何意义。例如，您不会仅计算余弦并丢弃结果： Math.cos(x); But you might well compute the value and assign it to a variable for future use: 但是可能会计算出该值并将其分配给变量以供将来使用： cx = Math.cos(x); Note that each line of code in each of these examples is terminated with a semicolon. 请注意，这些示例中的每行代码均以分号结尾。 ","date":"2020-11-02","objectID":"/posts/ch5/:1:0","tags":null,"title":"第 5 章 语句","uri":"/posts/ch5/"},{"categories":null,"content":"5.2 Compound and Empty Statements Just as the comma operator (§4.13.7) combines multiple expressions into a single expression, a statement block combines multiple statements into a single compound statement. A statement block is simply a sequence of statements enclosed within curly braces. Thus, the following lines act as a single statement and can be used anywhere that JavaScript expects a single statement: 正如逗号运算符（§4.13.7）将多个表达式组合成一个表达式一样，一个语句块将多个语句组合成一个复合语句。语句块只是括在花括号内的一系列语句。因此，以下几行充当单个语句，并且可以在 JavaScript 需要单个语句的任何地方使用： { x = Math.PI; cx = Math.cos(x); console.log(\"cos(π) = \" + cx); } There are a few things to note about this statement block. First, it does not end with a semicolon. The primitive statements within the block end in semicolons, but the block itself does not. Second, the lines inside the block are indented relative to the curly braces that enclose them. This is optional, but it makes the code easier to read and understand. 关于此语句块需要注意一些事项。首先，它不以分号结尾。块中的原始语句以分号结尾，但是块本身没有。其次，相对于包围它们的花括号将块内的行缩进。这是可选的，但是它使代码更易于阅读和理解。 Just as expressions often contain subexpressions, many JavaScript statements contain substatements. Formally, JavaScript syntax usually allows a single substatement. For example, the while loop syntax includes a single statement that serves as the body of the loop. Using a statement block, you can place any number of statements within this single allowed substatement. 正如表达式通常包含子表达式一样，许多 JavaScript 语句也包含子语句。正式地，JavaScript 语法通常允许单个子语句。例如，while 循环语法包括一个用作循环主体的语句。使用语句块，可以在此单个允许的子语句中放置任意数量的语句。 A compound statement allows you to use multiple statements where JavaScript syntax expects a single statement. The empty statement is the opposite: it allows you to include no statements where one is expected. The empty statement looks like this: 复合语句允许在 JavaScript 语法要求使用单个语句的情况下使用多个语句。空语句则相反：它允许在期望的位置不包含任何语句。空语句如下所示： ; The JavaScript interpreter takes no action when it executes an empty statement. The empty statement is occasionally useful when you want to create a loop that has an empty body. Consider the following for loop (for loops will be covered in §5.4.3): JavaScript解释器执行空语句时不执行任何操作。当要创建一个包含空主体的循环时，空语句有时会很有用。考虑以下 for 循环（for 循环将在 §5.4.3 中介绍）： // Initialize an array a for(let i = 0; i \u003c a.length; a[i++] = 0) ; In this loop, all the work is done by the expression a[i++] = 0, and no loop body is necessary. JavaScript syntax requires a statement as a loop body, however, so an empty statement—just a bare semicolon—is used. 在此循环中，所有工作均由表达式 a[i++] = 0 完成，并且不需要循环体。JavaScript 语法需要一个语句作为循环体，因此使用一个空语句（仅一个裸分号）。 Note that the accidental inclusion of a semicolon after the right parenthesis of a for loop, while loop, or if statement can cause frustrating bugs that are difficult to detect. For example, the following code probably does not do what the author intended: 请注意，在 for 循环，while 循环或 if 语句的右括号后面意外地包含分号，可能导致令人沮丧的错误，难以检测。例如，以下代码可能不符合作者的意图： if ((a === 0) || (b === 0)); // Oops! This line does nothing... o = null; // and this line is always executed. When you intentionally use the empty statement, it is a good idea to comment your code in a way that makes it clear that you are doing it on purpose. For example: 当有意使用空语句时，以下注释代码是一种清楚表明是故意这样做的方式的好主意。 例如： for(let i = 0; i \u003c a.length; a[i++] = 0) /* empty */ ; ","date":"2020-11-02","objectID":"/posts/ch5/:2:0","tags":null,"title":"第 5 章 语句","uri":"/posts/ch5/"},{"categories":null,"content":"5.3 Conditionals Conditional statements execute or skip other statements depending on the value of a specified expression. These statements are the decision points of your code, and they are also sometimes known as “branches.” If you imagine a JavaScript interpreter following a path through your code, the conditional statements are the places where the code branches into two or more paths and the interpreter must choose which path to follow. 条件语句根据指定表达式的值执行或跳过其他语句。这些语句是代码的决策点，有时也称为“分支”。如果想象 JavaScript 解释器遵循代码路径，则条件语句是代码分支到两个或更多路径的位置，并且解释器必须选择要遵循的路径。 The following subsections explain JavaScript’s basic conditional, the if/else statement, and also cover switch, a more complicated, multiway branch statement. 以下小节介绍了 JavaScript 的基本条件，if / else 语句，还介绍了 switch，更复杂的多路分支语句。 ","date":"2020-11-02","objectID":"/posts/ch5/:3:0","tags":null,"title":"第 5 章 语句","uri":"/posts/ch5/"},{"categories":null,"content":"5.3.1 if The if statement is the fundamental control statement that allows JavaScript to make decisions, or, more precisely, to execute statements conditionally. This statement has two forms. The first is: if 语句是基本的控制语句，它允许 JavaScript 进行决策，或更准确地说，可以有条件地执行语句。该语句有两种形式。 第一个是： if (expression) statement In this form, expression is evaluated. If the resulting value is truthy, statement is executed. If expression is falsy, statement is not executed. (See §3.4 for a definition of truthy and falsy values.) For example: 以这种形式，表达式被评估。如果结果值为真，则执行语句。如果 expression 是假，则不执行语句。（有关真实值和假值的定义，请参见 §3.4。）例如： if (username == null) // If username is null or undefined, username = \"John Doe\"; // define it Or similarly: // If username is null, undefined, false, 0, \"\", or NaN, give it a new value if (!username) username = \"John Doe\"; Note that the parentheses around the expression are a required part of the syntax for the if statement. 请注意，表达式周围的括号是 if 语句语法的必需部分。 JavaScript syntax requires a single statement after the if keyword and parenthesized expression, but you can use a statement block to combine multiple statements into one. So the if statement might also look like this: JavaScript 语法在 if 关键字和带括号的表达式之后需要一个语句，但是可以使用语句块将多个语句组合为一个。因此，if 语句也可能如下所示： if (!address) { address = \"\"; message = \"Please specify a mailing address.\"; } The second form of the if statement introduces an else clause that is executed when expression is false. Its syntax is: if 语句的第二种形式引入了 else 子句，当 expression 为 false 时将执行该子句。 它的语法是： if (expression) statement1 else statement2 This form of the statement executes statement1 if expression is truthy and executes statement2 if expression is falsy. For example: 如果 expression 为真，则此语句形式执行 statement1；如果 expression 为 false，则执行 statement2。 例如： if (n === 1) console.log(\"You have 1 new message.\"); else console.log(`You have ${n}new messages.`); When you have nested if statements with else clauses, some caution is required to ensure that the else clause goes with the appropriate if statement. Consider the following lines: 当将带有 if 子句的 if 语句嵌套时，需要格外小心，以确保 else 子句与适当的 if 语句一起使用。考虑以下几行： i = j = 1; k = 2; if (i === j) if (j === k) console.log(\"i equals k\"); else console.log(\"i doesn't equal j\"); // WRONG!! In this example, the inner if statement forms the single statement allowed by the syntax of the outer if statement. Unfortunately, it is not clear (except from the hint given by the indentation) which if the else goes with. And in this example, the indentation is wrong, because a JavaScript interpreter actually interprets the previous example as: 在此示例中，内部 if 语句形成外部 if 语句的语法允许的单个语句。不幸的是，不清楚（除非缩进提示）else 接连在哪个 if 后。 在此示例中，缩进是错误的，因为 JavaScript 解释器实际上将前面的示例解释为： if (i === j) { if (j === k) console.log(\"i equals k\"); else console.log(\"i doesn't equal j\"); // OOPS! } The rule in JavaScript (as in most programming languages) is that by default an else clause is part of the nearest if statement. To make this example less ambiguous and easier to read, understand, maintain, and debug, you should use curly braces: JavaScript 中的规则（与大多数编程语言一样）在默认情况下，else 子句是最接近的 if 语句的一部分。为了使此示例不太含糊且易于阅读、理解、维护和调试，应使用花括号： if (i === j) { if (j === k) { console.log(\"i equals k\"); } } else { // What a difference the location of a curly brace makes! console.log(\"i doesn't equal j\"); } Many programmers make a habit of enclosing the bodies of if and else statements (as well as other compound statements, such as while loops) within curly braces, even when the body consists of only a single statement. Doing so consistently can prevent the sort of problem just shown, and I advise you to adopt this practice. In this printed book, I place a premium on keeping example code vertically compact, and I do not always follow my own advice on this matter. 许多程序员习惯将 if 和 else 语句（以及其他复合语句，例如 while 循环）的主体括在花括号内，即使主体仅由一个语句组成也是如此。始终如一地这样做可以防止出现刚才显示的问题，我建议采用这种做法。在这本书中，我非常重视保持示例代码在垂直方向上的紧凑性，并且在此问题上，我并不总是遵循自己的建议。 ","date":"2020-11-02","objectID":"/posts/ch5/:3:1","tags":null,"title":"第 5 章 语句","uri":"/posts/ch5/"},{"categories":null,"content":"5.3.2 else if The if/else statement evaluates an expression and executes one of two pieces of code, depending on the outcome. But what about when you need to execute one of many pieces of code? One way to do this is with an else if statement. else if is not really a JavaScript statement, but simply a frequently used programming idiom that results when repeated if/else statements are used: if/else 语句根据结果评估表达式并执行两段代码之一。但是，当需要执行许多代码之一时，该怎么办呢？一种方法是使用 else if 语句。else if 并不是真正的 JavaScript 语句，而只是一个经常使用的编程习惯用法，当使用重复的 if/else 语句时会产生该习惯用法： if (n === 1) { // Execute code block #1 } else if (n === 2) { // Execute code block #2 } else if (n === 3) { // Execute code block #3 } else { // If all else fails, execute block #4 } There is nothing special about this code. It is just a series of if statements, where each following if is part of the else clause of the previous statement. Using the else if idiom is preferable to, and more legible than, writing these statements out in their syntactically equivalent, fully nested form: 此代码没有什么特别的。 它只是一系列的 if 语句，其后的每个 if 都是前一条语句的 else 子句的一部分。 使用 else if 惯用语比以语法上等效的完全嵌套形式写出这些语句更好，更易读： if (n === 1) { // Execute code block #1 } else { if (n === 2) { // Execute code block #2 } else { if (n === 3) { // Execute code block #3 } else { // If all else fails, execute block #4 } } } ","date":"2020-11-02","objectID":"/posts/ch5/:3:2","tags":null,"title":"第 5 章 语句","uri":"/posts/ch5/"},{"categories":null,"content":"5.3.3 switch An if statement causes a branch in the flow of a program’s execution, and you can use the else if idiom to perform a multiway branch. This is not the best solution, however, when all of the branches depend on the value of the same expression. In this case, it is wasteful to repeatedly evaluate that expression in multiple if statements. if 语句会导致程序执行流程中的分支，可以使用 else if 惯用法来执行多路分支。但是，当所有分支都依赖于同一表达式的值时，这不是最佳解决方案。在这种情况下，在多个 if 语句中重复评估该表达式是浪费性能的。 The switch statement handles exactly this situation. The switch keyword is followed by an expression in parentheses and a block of code in curly braces: switch 语句完全可以处理这种情况。switch 关键字后跟一个括号中的表达式和一个花括号中的代码块： switch(expression) { statements } However, the full syntax of a switch statement is more complex than this. Various locations in the block of code are labeled with the case keyword followed by an expression and a colon. When a switch executes, it computes the value of expression and then looks for a case label whose expression evaluates to the same value (where sameness is determined by the === operator). If it finds one, it starts executing the block of code at the statement labeled by the case. If it does not find a case with a matching value, it looks for a statement labeled default:. If there is no default: label, the switch statement skips the block of code altogether. 但是，switch 语句的完整语法比这更复杂。代码块中的各个位置都用 case 关键字标记，后跟一个表达式和一个冒号。switch 执行时，它将计算表达式的值，然后查找其表达式计算为相同值（其中相同性由 === 运算符确定）的case标签。如果找到一个，它将开始在由 case 标记的语句处执行代码块。如果找不到与值匹配的个案，则查找标记为 default: 的语句。 如果没有 default: 标签，则 switch 语句将完全跳过该代码块。 switch is a confusing statement to explain; its operation becomes much clearer with an example. The following switch statement is equivalent to the repeated if/else statements shown in the previous section: switch 是一个令人困惑的陈述，难以解释；举个例子，它的操作变得更加清晰。以下 switch 语句等效于上一节中重复 if/else 语句： switch(n) { case 1: // Start here if n === 1 // Execute code block #1. break; // Stop here case 2: // Start here if n === 2 // Execute code block #2. break; // Stop here case 3: // Start here if n === 3 // Execute code block #3. break; // Stop here default: // If all else fails... // Execute code block #4. break; // Stop here } Note the break keyword used at the end of each case in this code. The break statement, described later in this chapter, causes the interpreter to jump to the end (or “break out”) of the switch statement and continue with the statement that follows it. The case clauses in a switch statement specify only the starting point of the desired code; they do not specify any ending point. In the absence of break statements, a switch statement begins executing its block of code at the case label that matches the value of its expression and continues executing statements until it reaches the end of the block. On rare occasions, it is useful to write code like this that “falls through” from one case label to the next, but 99% of the time you should be careful to end every case with a break statement. (When using switch inside a function, however, you may use a return statement instead of a break statement. Both serve to terminate the switch statement and prevent execution from falling through to the next case.) 请注意此代码中每种情况结尾处使用的 break 关键字。在本章后面介绍的 break 语句使解释器跳到 switch 语句的末尾（或“中断”），并继续其后的语句。 switch 语句中的 case 子句仅指定所需代码的起点；他们没有指定任何终点。在没有 break 语句的情况下，switch 语句在与其表达式值匹配的 case 标签处开始执行其代码块，并继续执行语句，直到到达该块的末尾为止。在极少数情况下，编写这样的代码（从一个案例标签到另一个案例）“贯穿”是很有用的，但是在 99％ 的使用中，应小心以 break 语句结束每个案例。（但是，在函数内部使用 switch 时，可以使用 return 语句而不是 break 语句。两者都可用于终止 switch 语句并防止执行陷入下一种情况。） Here is a more realistic example of the switch statement; it converts a value to a string in a way that depends on the type of the value: 这是 switch 语句的一个更实际的示例；它将值转换为字符串的方式取决于值的类型： function convert(x) { switch(typeof x) { case \"number\": // Convert the number to a hexadecimal integer return x.toString(16); case \"string\": // Return the string enclosed in quotes return '\"' + x + '\"'; default: // Convert any other type in the usual way return String(x);","date":"2020-11-02","objectID":"/posts/ch5/:3:3","tags":null,"title":"第 5 章 语句","uri":"/posts/ch5/"},{"categories":null,"content":"5.4 Loops To understand conditional statements, we imagined the JavaScript interpreter following a branching path through your source code. The looping statements are those that bend that path back upon itself to repeat portions of your code. JavaScript has five looping statements: while, do/while, for, for/of (and its for/await variant), and for/in. The following subsections explain each in turn. One common use for loops is to iterate over the elements of an array. §7.6 discusses this kind of loop in detail and covers special looping methods defined by the Array class. 为了理解条件语句，我们假设 JavaScript 解释器遵循源代码中的分支路径。循环语句是那些使该路径重新弯曲以重复代码部分的语句。JavaScript 有五个循环语句：while、do/while、for、for/of（及其 for/await 变体）和 for/in。以下小节依次解释。循环的一种常见用法是遍历数组的元素。§7.6 详细讨论了这种循环，并涵盖了 Array 类定义的特殊循环方法。 ","date":"2020-11-02","objectID":"/posts/ch5/:4:0","tags":null,"title":"第 5 章 语句","uri":"/posts/ch5/"},{"categories":null,"content":"5.4.1 while Just as the if statement is JavaScript’s basic conditional, the while statement is JavaScript’s basic loop. It has the following syntax: 正如 if 语句是 JavaScript 的基本条件一样，while 语句也是 JavaScript 的基本循环。它具有以下语法： while (expression) statement To execute a while statement, the interpreter first evaluates expression. If the value of the expression is falsy, then the interpreter skips over the statement that serves as the loop body and moves on to the next statement in the program. If, on the other hand, the expression is truthy, the interpreter executes the statement and repeats, jumping back to the top of the loop and evaluating expression again. Another way to say this is that the interpreter executes statement repeatedly while the expression is truthy. Note that you can create an infinite loop with the syntax while(true). 要执行 while 语句，解释器首先对表达式求值。如果表达式的值是假值，则解释器将跳过用作循环主体的语句，然后继续执行程序中的下一条语句。另一方面，如果表达式是真值，则解释器将执行该语句并重复，跳回到循环的顶部并再次评估表达式。另一种说法是，解释器在表达式为真时重复执行语句。请注意，可以使用 while(true) 语法创建无限循环。 Usually, you do not want JavaScript to perform exactly the same operation over and over again. In almost every loop, one or more variables change with each iteration of the loop. Since the variables change, the actions performed by executing statement may differ each time through the loop. Furthermore, if the changing variable or variables are involved in expression, the value of the expression may be different each time through the loop. This is important; otherwise, an expression that starts off truthy would never change, and the loop would never end! Here is an example of a while loop that prints the numbers from 0 to 9: 通常，不希望 JavaScript 一次又一次地执行完全相同的操作。在几乎每个循环中，一个或多个变量随循环的每次迭代而变化。由于变量会发生变化，因此每次循环执行时，执行语句所执行的动作可能会有所不同。此外，如果表达式中包含一个或多个变化的变量，则每次循环时表达式的值可能会有所不同。这个很重要；否则，以 true 开始的表达式将永远不会改变，循环永远不会结束！这是一个while循环的示例，该循环打印从 0 到 9 的数字： let count = 0; while(count \u003c 10) { console.log(count); count++; } As you can see, the variable count starts off at 0 and is incremented each time the body of the loop runs. Once the loop has executed 10 times, the expression becomes false (i.e., the variable count is no longer less than 10), the while statement finishes, and the interpreter can move on to the next statement in the program. Many loops have a counter variable like count. The variable names i, j, and k are commonly used as loop counters, though you should use more descriptive names if it makes your code easier to understand. 如你所见，变量计数从 0 开始，并在每次循环主体运行时递增。循环执行 10 次后，表达式变为 false（即变量计数不小于 10），while 语句结束，解释器可以继续执行程序中的下一个语句。许多循环都有一个计数器变量，例如 count。变量名 i、j 和 k 通常用作循环计数器，但是如果可以使代码更易于理解，则应使用更具描述性的名称。 ","date":"2020-11-02","objectID":"/posts/ch5/:4:1","tags":null,"title":"第 5 章 语句","uri":"/posts/ch5/"},{"categories":null,"content":"5.4.2 do/while The do/while loop is like a while loop, except that the loop expression is tested at the bottom of the loop rather than at the top. This means that the body of the loop is always executed at least once. The syntax is: do/while 循环类似于 while 循环，除了循环表达式是在循环的底部而不是顶部进行测试的。这意味着循环的主体始终至少执行一次。语法为： do statement while (expression); The do/while loop is less commonly used than its while cousin—in practice, it is somewhat uncommon to be certain that you want a loop to execute at least once. Here’s an example of a do/while loop: do/while 循环不如 while 常用——在实践中，确定要至少执行一次循环在某种程度上并不常见。这是 do/while 循环的示例： function printArray(a) { let len = a.length, i = 0; if (len === 0) { console.log(\"Empty Array\"); } else { do { console.log(a[i]); } while(++i \u003c len); } } There are a couple of syntactic differences between the do/while loop and the ordinary while loop. First, the do loop requires both the do keyword (to mark the beginning of the loop) and the while keyword (to mark the end and introduce the loop condition). Also, the do loop must always be terminated with a semicolon. The while loop doesn’t need a semicolon if the loop body is enclosed in curly braces. do/while 循环和普通的 while 循环之间在语法上有一些区别。首先，do 循环需要同时使用do关键字（以标记循环的开始）和while关键字（以标记结束并引入循环条件）。 另外，do 循环必须始终以分号终止。如果循环主体用花括号括起来，则 while 循环不需要分号。 ","date":"2020-11-02","objectID":"/posts/ch5/:4:2","tags":null,"title":"第 5 章 语句","uri":"/posts/ch5/"},{"categories":null,"content":"5.4.3 for The for statement provides a looping construct that is often more convenient than the while statement. The for statement simplifies loops that follow a common pattern. Most loops have a counter variable of some kind. This variable is initialized before the loop starts and is tested before each iteration of the loop. Finally, the counter variable is incremented or otherwise updated at the end of the loop body, just before the variable is tested again. In this kind of loop, the initialization, the test, and the update are the three crucial manipulations of a loop variable. The for statement encodes each of these three manipulations as an expression and makes those expressions an explicit part of the loop syntax: for 语句提供了一个循环构造，通常比 while 语句更方便。 for 语句简化了遵循通用模式的循环。大多数循环都有某种计数器变量。在循环开始之前初始化此变量，并在每次循环迭代之前对其进行测试。最后，在再次测试变量之前，计数器变量在循环主体的末尾增加或更新。在这种循环中，初始化、测试和更新是循环变量的三个关键操作。for 语句将这三个操作中的每一个都编码为一个表达式，并使这些表达式成为循环语法的显式部分： for(initialize ; test ; increment) statement initialize, test, and increment are three expressions (separated by semicolons) that are responsible for initializing, testing, and incrementing the loop variable. Putting them all in the first line of the loop makes it easy to understand what a for loop is doing and prevents mistakes such as forgetting to initialize or increment the loop variable. 初始化、测试和递增三个表达式（用分号分隔）。将它们全部放入循环的第一行可轻松了解 for 循环的作用，并防止诸如忘记初始化或增加循环变量之类的错误。 The simplest way to explain how a for loop works is to show the equivalent while loop:2 解释 for 循环如何工作的最简单方法是显示等效的while循环：[^2] initialize; while(test) { statement increment; } In other words, the initialize expression is evaluated once, before the loop begins. To be useful, this expression must have side effects (usually an assignment). JavaScript also allows initialize to be a variable declaration statement so that you can declare and initialize a loop counter at the same time. The test expression is evaluated before each iteration and controls whether the body of the loop is executed. If test evaluates to a truthy value, the statement that is the body of the loop is executed. Finally, the increment expression is evaluated. Again, this must be an expression with side effects in order to be useful. Generally, it is either an assignment expression, or it uses the ++ or – operators. 换句话说，在循环开始之前，对初始化表达式进行一次求值。该表达式必须具有副作用（通常是赋值）。JavaScript 还允许将初始化用作变量声明语句，以便可以同时声明和初始化循环计数器。测试表达式在每次迭代之前进行评估，并控制是否执行循环主体。如果测试评估为真值，则执行作为循环主体的语句。最后，计算增量表达式。同样，该表达式必须是具有副作用的表达式才有效。通常，它可以是赋值表达式，也可以使用 ++ 或 – 运算符。 We can print the numbers from 0 to 9 with a for loop like the following. Contrast it with the equivalent while loop shown in the previous section: 我们可以使用如下所示的 for 循环打印 0 到 9 之间的数字。 将其与上一节中显示的等效 while 循环进行对比： for(let count = 0; count \u003c 10; count++) { console.log(count); } Loops can become a lot more complex than this simple example, of course, and sometimes multiple variables change with each iteration of the loop. This situation is the only place that the comma operator is commonly used in JavaScript; it provides a way to combine multiple initialization and increment expressions into a single expression suitable for use in a for loop: 当然，循环比这个简单的例子要复杂得多，有时循环的每次迭代都会改变多个变量。这种情况是在 JavaScript 中唯一使用逗号运算符的地方。它提供了一种将多个初始化和增量表达式组合成适合在 for 循环中使用的单个表达式的方法： let i, j, sum = 0; for(i = 0, j = 10 ; i \u003c 10 ; i++, j--) { sum += i * j; } In all our loop examples so far, the loop variable has been numeric. This is quite common but is not necessary. The following code uses a for loop to traverse a linked list data structure and return the last object in the list (i.e., the first object that does not have a next property): 到目前为止，在我们所有的循环示例中，循环变量都是数字。这是很常见的，但不是必需的。以下代码使用 for 循环遍历链接列表数据结构并返回列表中的最后一个对象（即第一个不具有 next 属性的对象）： function tail(o) { // Return the tail of linked list o for(; o.next; o = o.next) /* empty */ ; // Traverse while o.next is truthy return o; } Note that this code has no initialize expression. Any of the three expressions may be omitted from a for loop, but the two semicol","date":"2020-11-02","objectID":"/posts/ch5/:4:3","tags":null,"title":"第 5 章 语句","uri":"/posts/ch5/"},{"categories":null,"content":"5.4.4 for/of ES6 defines a new loop statement: for/of. This new kind of loop uses the for keyword but is a completely different kind of loop than the regular for loop. (It is also completely different than the older for/in loop that we’ll describe in §5.4.5.) ES6 定义了一个新的循环语句：for/of。这种新的循环使用 for 关键字，但是与常规的 for 循环完全不同。（它也与我们在 §5.4.5 中描述的较早的 for/in 循环完全不同。） The for/of loop works with iterable objects. We’ll explain exactly what it means for an object to be iterable in Chapter 12, but for this chapter, it is enough to know that arrays, strings, sets, and maps are iterable: they represent a sequence or set of elements that you can loop or iterate through using a for/of loop. for/of 循环适用于可迭代对象。我们将在第 12 章中确切解释对象可迭代的含义，但是对于本章而言，知道数组、字符串、set 和 map 是可迭代的足以：它们代表了所需要可以使用 for/of 循环的序列或元素集合。 Here, for example, is how we can use for/of to loop through the elements of an array of numbers and compute their sum: 例如，这里是我们如何使用 for/of 遍历数字数组的元素并计算它们的总和的方法： let data = [1, 2, 3, 4, 5, 6, 7, 8, 9], sum = 0; for(let element of data) { sum += element; } sum // =\u003e 45 Superficially, the syntax looks like a regular for loop: the for keyword is followed by parentheses that contain details about what the loop should do. In this case, the parentheses contain a variable declaration (or, for variables that have already been declared, simply the name of the variable) followed by the of keyword and an expression that evaluates to an iterable object, like the data array in this case. As with all loops, the body of a for/of loop follows the parentheses, typically within curly braces. 从表面上看，语法看起来像是常规的 for 循环：for 关键字后面是括号，其中包含有关循环应执行的操作的详细信息。在这种情况下，括号中包含一个变量声明（或者对于已经声明的变量，仅是变量的名称），后跟 of 关键字和一个表达式，该表达式的结果为可迭代对象，例如本例中的数据数组。与所有循环一样，for/of 循环的主体跟随括号后，通常在花括号内。 In the code just shown, the loop body runs once for each element of the data array. Before each execution of the loop body, the next element of the array is assigned to the element variable. Array elements are iterated in order from first to last. 在刚刚显示的代码中，循环主体为数据数组的每个元素运行一次。在每次执行循环主体之前，将数组的下一个元素分配给 element 变量。数组元素从第一个到最后一个顺序进行迭代。 Arrays are iterated “live”—changes made during the iteration may affect the outcome of the iteration. If we modify the preceding code by adding the line data.push(sum); inside the loop body, then we create an infinite loop because the iteration can never reach the last element of the array. 数组是“实时”迭代的，在迭代过程中进行的更改可能会影响迭代的结果。如果我们通过添加行 data.push(sum); 在循环体内修改前面的代码，我们则创建一个无限循环，因为迭代永远无法到达数组的最后一个元素。 FOR/OF WITH OBJECTS Objects are not (by default) iterable. Attempting to use for/of on a regular object throws a TypeError at runtime: 对象是不可迭代的（默认情况下）。尝试在常规对象上使用 for/of 会在运行时引发 TypeError： let o = { x: 1, y: 2, z: 3 }; for(let element of o) { // Throws TypeError because o is not iterable console.log(element); } If you want to iterate through the properties of an object, you can use the for/in loop (introduced in §5.4.5), or use for/of with the Object.keys() method: 如果要遍历对象的属性，则可以使用 for/in 循环（在 §5.4.5 中介绍），或通过 Object.keys() 方法使用 for/of： let o = { x: 1, y: 2, z: 3 }; let keys = \"\"; for(let k of Object.keys(o)) { keys += k; } keys // =\u003e \"xyz\" This works because Object.keys() returns an array of property names for an object, and arrays are iterable with for/of. Note also that this iteration of the keys of an object is not live as the array example above was—changes to the object o made in the loop body will have no effect on the iteration. If you don’t care about the keys of an object, you can also iterate through their corresponding values like this: 之所以可行，是因为 Object.keys() 返回一个对象的属性名称数组，并且该数组可以使用 for/of 进行迭代。还要注意，对象的键的这种迭代不像上面的数组示例那样有效——在循环主体中对对象 o 所做的更改将对该迭代没有影响。 如果您不关心对象的键，也可以像下面这样遍历它们的对应值： let sum = 0; for(let v of Object.values(o)) { sum += v; } sum // =\u003e 6 And if you are interested in both the keys and the values of an object’s properties, you can use for/of with Object.entries() and destructuring assignment: 而且，如果对对象属性的键和值都感兴趣，则可以将 Object.entries() 与 for/of 一起使用，并销毁赋值： let pairs = \"\"; for(let [k","date":"2020-11-02","objectID":"/posts/ch5/:4:4","tags":null,"title":"第 5 章 语句","uri":"/posts/ch5/"},{"categories":null,"content":"5.4.5 for/in A for/in loop looks a lot like a for/of loop, with the of keyword changed to in. While a for/of loop requires an iterable object after the of, a for/in loop works with any object after the in. The for/of loop is new in ES6, but for/in has been part of JavaScript since the very beginning (which is why it has the more natural sounding syntax). for/in 循环看起来很像 for/of 循环，将 of 关键字更改为 in。for/of 循环在 of 之后需要可迭代的对象，而 for/in 循环则在 in 之后可用于任何对象。for/of 循环是 ES6 中的新功能，但是 for/in 从一开始就已经是 JavaScript 的一部分（这就是为什么它具有更自然的发音语法）。 The for/in statement loops through the property names of a specified object. The syntax looks like this: for/in 语句循环遍历指定对象的属性名称。语法如下所示： for (variable in object) statement variable typically names a variable, but it may be a variable declaration or anything suitable as the left-hand side of an assignment expression. object is an expression that evaluates to an object. As usual, statement is the statement or statement block that serves as the body of the loop. 变量通常命名为变量，但它可以是变量声明或任何适合作为赋值表达式左侧的内容。object 是一个计算结果为对象的表达式。像往常一样，statement 是用作循环正文的语句或语句块。 And you might use a for/in loop like this: 可能会使用如下所示的 for/in 循环： for(let p in o) { // Assign property names of o to variable p console.log(o[p]); // Print the value of each property } To execute a for/in statement, the JavaScript interpreter first evaluates the object expression. If it evaluates to null or undefined, the interpreter skips the loop and moves on to the next statement. The interpreter now executes the body of the loop once for each enumerable property of the object. Before each iteration, however, the interpreter evaluates the variable expression and assigns the name of the property (a string value) to it. 为了执行 for/in 语句，JavaScript 解释器首先评估对象表达式。如果评估结果为 null 或未定义，则解释器将跳过循环并继续执行下一条语句。现在，解释器对对象的每个可枚举属性执行一次循环主体。但是，在每次迭代之前，解释器都会对变量表达式求值，并为其分配属性名称（字符串值）。 Note that the variable in the for/in loop may be an arbitrary expression, as long as it evaluates to something suitable for the left side of an assignment. This expression is evaluated each time through the loop, which means that it may evaluate differently each time. For example, you can use code like the following to copy the names of all object properties into an array: 请注意，for/in 循环中的变量可以是任意表达式，只要它的计算结果适合于赋值的左侧即可。每次通过循环都会对该表达式进行求值，这意味着它每次都可能会进行不同的求值。例如，可以使用以下代码将所有对象属性的名称复制到数组中： let o = { x: 1, y: 2, z: 3 }; let a = [], i = 0; for(a[i++] in o) /* empty */; JavaScript arrays are simply a specialized kind of object, and array indexes are object properties that can be enumerated with a for/in loop. For example, following the previous code with this line enumerates the array indexes 0, 1, and 2: JavaScript 数组只是一种特殊的对象，而数组索引是可以用 for/in 循环枚举的对象属性。例如，在前面的代码之后加上此行，将枚举数组索引 0、1 和 2： for(let i in a) console.log(i); I find that a common source of bugs in my own code is the accidental use of for/in with arrays when I meant to use for/of. When working with arrays, you almost always want to use for/of instead of for/in. 我发现我自己的代码中常见的错误源是当我打算使用 for/of 时偶然将 for/in 与数组结合使用。使用数组时，几乎总是要使用 for/of 而不是 for/in。 The for/in loop does not actually enumerate all properties of an object. It does not enumerate properties whose names are symbols. And of the properties whose names are strings, it only loops over the enumerable properties (see §14.1). The various built-in methods defined by core JavaScript are not enumerable. All objects have a toString() method, for example, but the for/in loop does not enumerate this toString property. In addition to built-in methods, many other properties of the built-in objects are non-enumerable. All properties and methods defined by your code are enumerable, by default. (You can make them non-enumerable using techniques explained in §14.1.) for/in 循环实际上并未枚举对象的所有属性。它不枚举名称为符号的属性。在名称为字符串的属性中，它仅循环可枚举的属性（请参见第14.1节）。核心 JavaScript 定义的各种内置方法是无法枚举的。例如，所有对象都具有 toString() 方法，但是 for/in 循环不会枚举此 toString 属性。除了内置方法之外，内置对象的许多其他属性也是不可枚举的。 默认情况下，代码定义的所有属性和方法都是可枚举的。（可以使用 §14.1 中介绍的技术使它们不可枚举。） Enumerable inherited proper","date":"2020-11-02","objectID":"/posts/ch5/:4:5","tags":null,"title":"第 5 章 语句","uri":"/posts/ch5/"},{"categories":null,"content":"5.5 Jumps Another category of JavaScript statements are jump statements. As the name implies, these cause the JavaScript interpreter to jump to a new location in the source code. The break statement makes the interpreter jump to the end of a loop or other statement. continue makes the interpreter skip the rest of the body of a loop and jump back to the top of a loop to begin a new iteration. JavaScript allows statements to be named, or labeled, and break and continue can identify the target loop or other statement label. JavaScript 语句的另一类是跳转语句。顾名思义，这些会导致 JavaScript 解释器跳至源代码中的新位置。break 语句使解释器跳到循环或其他语句的末尾。continue 使解释器跳过循环主体的其余部分，然后跳回到循环的顶部以开始新的迭代。JavaScript 允许对语句进行命名或标记，并且 break 和 continue 可以标识目标循环或其他语句标签。 The return statement makes the interpreter jump from a function invocation back to the code that invoked it and also supplies the value for the invocation. The throw statement is a kind of interim return from a generator function. The throw statement raises, or throws, an exception and is designed to work with the try/catch/finally statement, which establishes a block of exception-handling code. This is a complicated kind of jump statement: when an exception is thrown, the interpreter jumps to the nearest enclosing exception handler, which may be in the same function or up the call stack in an invoking function. return 语句使解释器从函数调用跳回到调用它的代码，并提供该调用的值。throw 语句是生成器函数的一种临时返回。throw 语句引发或抛出异常，并设计为与 try/catch/finally 语句一起使用，该语句建立一个异常处理代码块。这是一种复杂的跳转语句：抛出异常时，解释器将跳转到最近的封闭异常处理程序，该处理程序可以在同一函数中，也可以在调用函数中的调用堆栈中向上移动。 Details about each of these jump statements are in the sections that follow. 有关这些跳转语句的详细信息，请参见以下各节。 ","date":"2020-11-02","objectID":"/posts/ch5/:5:0","tags":null,"title":"第 5 章 语句","uri":"/posts/ch5/"},{"categories":null,"content":"5.5.1 Labeled Statements Any statement may be labeled by preceding it with an identifier and a colon: 任何语句都可以在其前面加上标识符和冒号来标记： identifier: statement 标识符: 语句 By labeling a statement, you give it a name that you can use to refer to it elsewhere in your program. You can label any statement, although it is only useful to label statements that have bodies, such as loops and conditionals. By giving a loop a name, you can use break and continue statements inside the body of the loop to exit the loop or to jump directly to the top of the loop to begin the next iteration. break and continue are the only JavaScript statements that use statement labels; they are covered in the following subsections. Here is an example of a labeled while loop and a continue statement that uses the label. 通过给语句加标签，可以为它指定一个名称，可以使用该名称在程序的其他位置引用它。可以标记任何语句，尽管只有于标记具有主体（例如循环和条件）的语句才有用。通过给循环命名，可以在循环体内使用 break 和 continue 语句退出循环或直接跳转到循环顶部以开始下一个迭代。break 和 continue 是唯一使用语句标签的 JavaScript 语句；它们在以下小节中介绍。这是一个带有标签的 while 循环和一个使用该标签的 continue 语句的示例。 mainloop: while(token !== null) { // Code omitted... continue mainloop; // Jump to the next iteration of the named loop // More code omitted... } The identifier you use to label a statement can be any legal JavaScript identifier that is not a reserved word. The namespace for labels is different than the namespace for variables and functions, so you can use the same identifier as a statement label and as a variable or function name. Statement labels are defined only within the statement to which they apply (and within its substatements, of course). A statement may not have the same label as a statement that contains it, but two statements may have the same label as long as neither one is nested within the other. Labeled statements may themselves be labeled. Effectively, this means that any statement may have multiple labels. 用于标记语句的标识符可以是非保留字的任何合法 JavaScript 标识符。标签的命名空间与变量和函数的命名空间不同，因此可以将相同的标识符用作语句标签以及变量或函数名称。语句标签仅在它们适用的语句内定义（当然，在其子语句中也定义）。一条语句可能没有与包含该语句的语句相同的标签，但是两个语句都可以具有相同的标签，只要两个语句都不嵌套在另一个语句中即可。带标签的语句本身可以被标记。实际上，这意味着任何语句都可以具有多个标签。 ","date":"2020-11-02","objectID":"/posts/ch5/:5:1","tags":null,"title":"第 5 章 语句","uri":"/posts/ch5/"},{"categories":null,"content":"5.5.2 break The break statement, used alone, causes the innermost enclosing loop or switch statement to exit immediately. Its syntax is simple: 单独使用 break 语句会使最里面的循环或 switch 语句立即退出。它的语法很简单： break; Because it causes a loop or switch to exit, this form of the break statement is legal only if it appears inside one of these statements. 因为它导致循环或开关退出，所以这种形式的break语句仅当出现在这些语句之一内时才是合法的。 You’ve already seen examples of the break statement within a switch statement. In loops, it is typically used to exit prematurely when, for whatever reason, there is no longer any need to complete the loop. When a loop has complex termination conditions, it is often easier to implement some of these conditions with break statements rather than trying to express them all in a single loop expression. The following code searches the elements of an array for a particular value. The loop terminates in the normal way when it reaches the end of the array; it terminates with a break statement if it finds what it is looking for in the array: 您已经在 switch 语句中看到了 break 语句的示例。在循环中，通常由于某种原因而不再需要完成循环时，它会过早退出。当循环具有复杂的终止条件时，通常使用 break 语句更容易实现其中一些条件，而不是尝试在单个循环表达式中全部表达它们。以下代码在数组的元素中搜索特定值。当循环到达数组末尾时，循环以通常的方式终止。如果在数组中找到要查找的内容，则以 break 语句终止： for(let i = 0; i \u003c a.length; i++) { if (a[i] === target) break; } JavaScript also allows the break keyword to be followed by a statement label (just the identifier, with no colon): JavaScript 还允许 break 关键字后跟一个语句标签（只是标识符，没有冒号）： break labelname; When break is used with a label, it jumps to the end of, or terminates, the enclosing statement that has the specified label. It is a syntax error to use break in this form if there is no enclosing statement with the specified label. With this form of the break statement, the named statement need not be a loop or switch: break can “break out of” any enclosing statement. This statement can even be a statement block grouped within curly braces for the sole purpose of naming the block with a label. 当 break 与标签一起使用时，它跳转到具有指定标签的封闭语句的末尾或终止。如果没有带有指定标签的封闭语句，则使用这种形式的 break 是语法错误。 使用 break 语句的这种形式，命名的语句不必是循环或 switch：break 可以“跳出”任何封闭的语句。该语句甚至可以是用大括号括起来的语句块，其唯一目的是用标签命名该块。 A newline is not allowed between the break keyword and the label name. This is a result of JavaScript’s automatic insertion of omitted semicolons: if you put a line terminator between the break keyword and the label that follows, JavaScript assumes you meant to use the simple, unlabeled form of the statement and treats the line terminator as a semicolon. (See §2.6.) 在 break 关键字和标签名之间不允许使用换行符。 这是 JavaScript 自动插入省略的分号的结果：如果在 break 关键字和后面的标签之间放置了行终止符，则 JavaScript 会假定您打算使用语句的简单、无标签形式并将行终止符视为分号 。（请参见 §2.6） You need the labeled form of the break statement when you want to break out of a statement that is not the nearest enclosing loop or a switch. The following code demonstrates: 当想脱离不是最近的封闭循环或 switch 的语句时，需要使用 break 语句的标签形式。以下代码演示： let matrix = getData(); // Get a 2D array of numbers from somewhere // Now sum all the numbers in the matrix. let sum = 0, success = false; // Start with a labeled statement that we can break out of if errors occur computeSum: if (matrix) { for(let x = 0; x \u003c matrix.length; x++) { let row = matrix[x]; if (!row) break computeSum; for(let y = 0; y \u003c row.length; y++) { let cell = row[y]; if (isNaN(cell)) break computeSum; sum += cell; } } success = true; } // The break statements jump here. If we arrive here with success == false // then there was something wrong with the matrix we were given. // Otherwise, sum contains the sum of all cells of the matrix. Finally, note that a break statement, with or without a label, can not transfer control across function boundaries. You cannot label a function definition statement, for example, and then use that label inside the function. 最后，请注意，带有或不带有标签的 break 语句无法跨函数边界转移控制权。例如，不能标记函数定义语句，然后在函数内部使用该标记。 ","date":"2020-11-02","objectID":"/posts/ch5/:5:2","tags":null,"title":"第 5 章 语句","uri":"/posts/ch5/"},{"categories":null,"content":"5.5.3 continue The continue statement is similar to the break statement. Instead of exiting a loop, however, continue restarts a loop at the next iteration. The continue statement’s syntax is just as simple as the break statement’s: continue 语句类似于 break 语句。但是，continue 不是退出循环，而是在重新开始循环的下一次迭代。continue 语句的语法与 break 语句的语法一样简单： continue; The continue statement can also be used with a label: continue 语句也可以与标签一起使用： continue labelname; The continue statement, in both its labeled and unlabeled forms, can be used only within the body of a loop. Using it anywhere else causes a syntax error. 标记和未标记形式的 continue 语句只能在循环体内使用。在其他任何地方使用它都会导致语法错误。 When the continue statement is executed, the current iteration of the enclosing loop is terminated, and the next iteration begins. This means different things for different types of loops: 当执行 continue 语句时，封闭循环的当前迭代将终止，并且下一个迭代开始。对于不同类型的循环，这意味着不同的事情： In a while loop, the specified expression at the beginning of the loop is tested again, and if it’s true, the loop body is executed starting from the top. 在 while 循环中，将再次测试循环开始处的指定表达式，如果该表达式为 true，则循环主体将从顶部开始执行。 In a do/while loop, execution skips to the bottom of the loop, where the loop condition is tested again before restarting the loop at the top. 在 do/while 循环中，执行跳到循环的底部，在重新测试顶部的循环之前，先对循环条件进行测试。 In a for loop, the increment expression is evaluated, and the test expression is tested again to determine if another iteration should be done. 在 for 循环中，对增量表达式进行求值，然后再次对测试表达式进行测试，以确定是否应执行另一次迭代。 In a for/of or for/in loop, the loop starts over with the next iterated value or next property name being assigned to the specified variable. 在 for/of 或 for/in 循环中，循环从下一个迭代值或下一个属性名称分配给指定变量开始。 Note the difference in behavior of the continue statement in the while and for loops: a while loop returns directly to its condition, but a for loop first evaluates its increment expression and then returns to its condition. Earlier, we considered the behavior of the for loop in terms of an “equivalent” while loop. Because the continue statement behaves differently for these two loops, however, it is not actually possible to perfectly simulate a for loop with a while loop alone. 注意 while 和 for 循环中 continue 语句的行为差异：while 循环直接返回其条件，但是 for 循环首先计算其增量表达式，然后返回其条件。之前，我们以“等效” while 循环的形式考虑了 for 循环的行为。但是，由于 continue 语句在这两个循环中的行为不同，因此实际上不可能仅使用 while 循环来完美地模拟 for 循环。 The following example shows an unlabeled continue statement being used to skip the rest of the current iteration of a loop when an error occurs: 以下示例显示了一个未标记的 continue 语句，该语句在发生错误时用于跳过循环的当前迭代的其余部分： for(let i = 0; i \u003c data.length; i++) { if (!data[i]) continue; // Can't proceed with undefined data total += data[i]; } Like the break statement, the continue statement can be used in its labeled form within nested loops when the loop to be restarted is not the immediately enclosing loop. Also, as with the break statement, line breaks are not allowed between the continue statement and its label name. 像 break 语句一样，当要重新启动的循环不是立即封闭的循环时，可以在嵌套循环内以标记形式使用 continue 语句。同样，与 break 语句一样，在 continue 语句及其标签名之间不允许换行。 ","date":"2020-11-02","objectID":"/posts/ch5/:5:3","tags":null,"title":"第 5 章 语句","uri":"/posts/ch5/"},{"categories":null,"content":"5.5.4 return Recall that function invocations are expressions and that all expressions have values. A return statement within a function specifies the value of invocations of that function. Here’s the syntax of the return statement: 回想一下，函数调用是表达式，并且所有表达式都具有值。函数内的 return 语句指定该函数的调用值。这是 return 语句的语法： return expression; A return statement may appear only within the body of a function. It is a syntax error for it to appear anywhere else. When the return statement is executed, the function that contains it returns the value of expression to its caller. For example: return 语句可能仅出现在函数体内。它出现在其他任何地方都是语法错误。当执行 return 语句时，包含它的函数会将 expression 的值返回给其调用者。例如： function square(x) { return x*x; } // A function that has a return statement square(2) // =\u003e 4 With no return statement, a function invocation simply executes each of the statements in the function body in turn until it reaches the end of the function and then returns to its caller. In this case, the invocation expression evaluates to undefined. The return statement often appears as the last statement in a function, but it need not be last: a function returns to its caller when a return statement is executed, even if there are other statements remaining in the function body. 在没有 return 语句的情况下，函数调用只是依次依次执行函数体中的每个语句，直到到达函数末尾，然后返回到其调用者。在这种情况下，调用表达式的计算结果为 undefined。return 语句通常显示为函数中的最后一条语句，但不一定要最后一条：执行 return 语句时，函数返回到其调用者，即使函数体内还有其他语句。 The return statement can also be used without an expression to make the function return undefined to its caller. For example: 还可以在没有表达式的情况下使用 return 语句，以使函数返回未定义给调用者。例如： function displayObject(o) { // Return immediately if the argument is null or undefined. if (!o) return; // Rest of function goes here... } Because of JavaScript’s automatic semicolon insertion (§2.6), you cannot include a line break between the return keyword and the expression that follows it. 由于 JavaScript 自动插入了分号（§2.6），因此不能在 return 关键字和其后的表达式之间包含换行符。 ","date":"2020-11-02","objectID":"/posts/ch5/:5:4","tags":null,"title":"第 5 章 语句","uri":"/posts/ch5/"},{"categories":null,"content":"5.5.5 yield The yield statement is much like the return statement but is used only in ES6 generator functions (see §12.3) to produce the next value in the generated sequence of values without actually returning: yield 语句与 return 语句非常相似，但仅在 ES6 生成器函数（请参阅 §12.3）中使用，以在所生成的值序列中生成下一个值，而无需实际返回： // A generator function that yields a range of integers function* range(from, to) { for(let i = from; i \u003c= to; i++) { yield i; } } In order to understand yield, you must understand iterators and generators, which will not be covered until Chapter 12. yield is included here for completeness, however. (Technically, though, yield is an operator rather than a statement, as explained in §12.4.2.) 为了了解 yield，必须了解迭代器和生成器，但是为了完整起见，直到第 12 章都不会涉及。（但是，从技术上讲，yield 是运算符，而不是语句，如 §12.4.2 节中所述。） ","date":"2020-11-02","objectID":"/posts/ch5/:5:5","tags":null,"title":"第 5 章 语句","uri":"/posts/ch5/"},{"categories":null,"content":"5.5.6 throw An exception is a signal that indicates that some sort of exceptional condition or error has occurred. To throw an exception is to signal such an error or exceptional condition. To catch an exception is to handle it—to take whatever actions are necessary or appropriate to recover from the exception. In JavaScript, exceptions are thrown whenever a runtime error occurs and whenever the program explicitly throws one using the throw statement. Exceptions are caught with the try/catch/finally statement, which is described in the next section. 异常是表示已发生某种异常情况或错误的信号。引发异常是表示这种错误或异常情况。捕获异常就是对它进行处理——采取必要措施或适当措施以从异常中恢复。在 JavaScript 中，只要发生运行时错误，并且只要程序使用 throw 语句显式抛出一个异常，就会引发异常。使用 try/catch/finally 语句捕获异常，这将在下一部分中进行描述。 The throw statement has the following syntax: throw语句具有以下语法： throw expression; expression may evaluate to a value of any type. You might throw a number that represents an error code or a string that contains a human-readable error message. The Error class and its subclasses are used when the JavaScript interpreter itself throws an error, and you can use them as well. An Error object has a name property that specifies the type of error and a message property that holds the string passed to the constructor function. Here is an example function that throws an Error object when invoked with an invalid argument: 表达式可以计算为任何类型的值。可能会抛出代表错误代码的数字或包含人类可读错误消息的字符串。当 JavaScript 解释器本身抛出错误时，将使用 Error 类及其子类，并且您也可以使用它们。Error 对象具有用于指定错误类型的 name 属性和用于保存传递给构造函数的字符串的 message 属性。这是一个示例函数，当使用无效参数调用该函数时，将引发 Error 对象： function factorial(x) { // If the input argument is invalid, throw an exception! if (x \u003c 0) throw new Error(\"x must not be negative\"); // Otherwise, compute a value and return normally let f; for(f = 1; x \u003e 1; f *= x, x--) /* empty */ ; return f; } factorial(4) // =\u003e 24 When an exception is thrown, the JavaScript interpreter immediately stops normal program execution and jumps to the nearest exception handler. Exception handlers are written using the catch clause of the try/catch/finally statement, which is described in the next section. If the block of code in which the exception was thrown does not have an associated catch clause, the interpreter checks the next-highest enclosing block of code to see if it has an exception handler associated with it. This continues until a handler is found. If an exception is thrown in a function that does not contain a try/catch/finally statement to handle it, the exception propagates up to the code that invoked the function. In this way, exceptions propagate up through the lexical structure of JavaScript methods and up the call stack. If no exception handler is ever found, the exception is treated as an error and is reported to the user. 引发异常时，JavaScript 解释器立即停止正常程序执行并跳转到最近的异常处理程序。异常处理程序使用 try/catch/finally 语句的 catch 子句编写，这将在下一部分中进行描述。如果在其中引发了异常的代码块中没有关联的 catch 子句，则解释器将检查下一个最顶层的代码块，以查看其是否具有与之关联的异常处理程序。这一直持续到找到处理程序为止。如果在不包含 try/catch/finally 语句来处理它的函数中引发异常，则该异常会传播到调用该函数的代码。这样，异常会通过 JavaScript 方法的词法结构向上传播，并向上扩展到调用堆栈。如果未找到异常处理程序，则将该异常视为错误并报告给用户。 ","date":"2020-11-02","objectID":"/posts/ch5/:5:6","tags":null,"title":"第 5 章 语句","uri":"/posts/ch5/"},{"categories":null,"content":"5.5.7 try/catch/finally The try/catch/finally statement is JavaScript’s exception handling mechanism. The try clause of this statement simply defines the block of code whose exceptions are to be handled. The try block is followed by a catch clause, which is a block of statements that are invoked when an exception occurs anywhere within the try block. The catch clause is followed by a finally block containing cleanup code that is guaranteed to be executed, regardless of what happens in the try block. Both the catch and finally blocks are optional, but a try block must be accompanied by at least one of these blocks. The try, catch, and finally blocks all begin and end with curly braces. These braces are a required part of the syntax and cannot be omitted, even if a clause contains only a single statement. try/catch/finally 语句是 JavaScript 的异常处理机制。该语句的 try 子句仅定义要处理其异常的代码块。在 try 块之后是 catch 子句，catch 子句是在 try 块内任何地方发生异常时调用的语句块。catch 子句后面是一个 finally 块，其中包含保证可以执行的清除代码，无论 try 块中发生了什么。catch 和 finally 块都是可选的，但是 try 块必须至少与这些块之一相伴。尝试，捕获和最终阻止都以花括号开头和结尾。这些花括号是语法的必需部分，即使子句仅包含一个语句，也不能忽略这些花括号。 The following code illustrates the syntax and purpose of the try/catch/finally statement: 以下代码说明了 try/catch/finally 语句的语法和用途： try { // Normally, this code runs from the top of the block to the bottom // without problems. But it can sometimes throw an exception, // either directly, with a throw statement, or indirectly, by calling // a method that throws an exception. } catch(e) { // The statements in this block are executed if, and only if, the try // block throws an exception. These statements can use the local variable // e to refer to the Error object or other value that was thrown. // This block may handle the exception somehow, may ignore the // exception by doing nothing, or may rethrow the exception with throw. } finally { // This block contains statements that are always executed, regardless of // what happens in the try block. They are executed whether the try // block terminates: // 1) normally, after reaching the bottom of the block // 2) because of a break, continue, or return statement // 3) with an exception that is handled by a catch clause above // 4) with an uncaught exception that is still propagating } Note that the catch keyword is generally followed by an identifier in parentheses. This identifier is like a function parameter. When an exception is caught, the value associated with the exception (an Error object, for example) is assigned to this parameter. The identifier associated with a catch clause has block scope—it is only defined within the catch block. 请注意，catch 关键字通常在括号后跟一个标识符。该标识符就像一个函数参数。捕获到异常后，与该异常关联的值（例如 Error 对象）将分配给该参数。与 catch 子句关联的标识符具有块作用域——仅在catch块内有定义。 Here is a realistic example of the try/catch statement. It uses the factorial() method defined in the previous section and the client-side JavaScript methods prompt() and alert() for input and output: 这是 try/catch 语句的实际示例。它使用上一节中定义的 factorial() 方法以及客户端 JavaScript 方法 hint() 和 alert() 进行输入和输出： try { // Ask the user to enter a number let n = Number(prompt(\"Please enter a positive integer\", \"\")); // Compute the factorial of the number, assuming the input is valid let f = factorial(n); // Display the result alert(n + \"! = \" + f); } catch(ex) { // If the user's input was not valid, we end up here alert(ex); // Tell the user what the error is } This example is a try/catch statement with no finally clause. Although finally is not used as often as catch, it can be useful. However, its behavior requires additional explanation. The finally clause is guaranteed to be executed if any portion of the try block is executed, regardless of how the code in the try block completes. It is generally used to clean up after the code in the try clause. 这个例子是一个 try/catch 语句，没有 finally 子句。虽然 finally 不像 catch 那样经常使用，但它很有用。可是，其行为需要额外说明。如果 try 块的任何部分被执行，则必定执行 finally 子句，无论 try 块中的代码如何完成。通常用于在 try 子句中的代码之后进行清理。 In the normal case, the JavaScript interpreter reaches the end of the try block and then pr","date":"2020-11-02","objectID":"/posts/ch5/:5:7","tags":null,"title":"第 5 章 语句","uri":"/posts/ch5/"},{"categories":null,"content":"5.6 Miscellaneous Statements This section describes the remaining three JavaScript statements—with, debugger, and “use strict”. 本节描述了其余三个 JavaScript 语句——with、debugger 和“ use strict”。 ","date":"2020-11-02","objectID":"/posts/ch5/:6:0","tags":null,"title":"第 5 章 语句","uri":"/posts/ch5/"},{"categories":null,"content":"5.6.1 with The with statement runs a block of code as if the properties of a specified object were variables in scope for that code. It has the following syntax: with 语句运行代码块，就像指定对象的属性是该代码范围内的变量一样。它具有以下语法： with (object) statement This statement creates a temporary scope with the properties of object as variables and then executes statement within that scope. 该语句使用对象的属性作为变量创建一个临时作用域，然后在该作用域内执行语句。 The with statement is forbidden in strict mode (see §5.6.3) and should be considered deprecated in non-strict mode: avoid using it whenever possible. JavaScript code that uses with is difficult to optimize and is likely to run significantly more slowly than the equivalent code written without the with statement. 在严格模式下禁止 with 语句（请参见 §5.6.3），并且在非严格模式下应将其视为已弃用：请尽可能避免使用它。与 with 一起使用的 JavaScript 代码难以优化，并且与没有 with 语句编写的等效代码相比，运行速度可能慢得多。 The common use of the with statement is to make it easier to work with deeply nested object hierarchies. In client-side JavaScript, for example, you may have to type expressions like this one to access elements of an HTML form: with 语句的常用用法是使使用深度嵌套的对象层次结构更清晰。例如，在客户端 JavaScript 中，可能必须键入此类表达式才能访问 HTML 表单的元素： document.forms[0].address.value If you need to write expressions like this a number of times, you can use the with statement to treat the properties of the form object like variables: 如果需要多次编写这样的表达式，则可以使用 with 语句将表单对象的属性像变量一样对待： with(document.forms[0]) { // Access form elements directly here. For example: name.value = \"\"; address.value = \"\"; email.value = \"\"; } This reduces the amount of typing you have to do: you no longer need to prefix each form property name with document.forms[0]. It is just as simple, of course, to avoid the with statement and write the preceding code like this: 这减少了必须进行的键入操作的数量：不再需要为每个表单属性名称加上 document.forms[0] 前缀。当然，避免 with 语句并像这样编写前面的代码也很简单： let f = document.forms[0]; f.name.value = \"\"; f.address.value = \"\"; f.email.value = \"\"; Note that if you use const or let or var to declare a variable or constant within the body of a with statement, it creates an ordinary variable and does not define a new property within the specified object. 请注意，如果使用 const 或 let 或 var 在 with 语句的主体内声明变量或常量，则它将创建普通变量，并且不会在指定对象内定义新属性。 ","date":"2020-11-02","objectID":"/posts/ch5/:6:1","tags":null,"title":"第 5 章 语句","uri":"/posts/ch5/"},{"categories":null,"content":"5.6.2 debugger The debugger statement normally does nothing. If, however, a debugger program is available and is running, then an implementation may (but is not required to) perform some kind of debugging action. In practice, this statement acts like a breakpoint: execution of JavaScript code stops, and you can use the debugger to print variables’ values, examine the call stack, and so on. Suppose, for example, that you are getting an exception in your function f() because it is being called with an undefined argument, and you can’t figure out where this call is coming from. To help you in debugging this problem, you might alter f() so that it begins like this: debugger 语句通常不执行任何操作。但是，如果 debugger 程序可用并且正在运行，则这个实现可以（但不是必需）执行某种调试操作。实际上，该语句就像一个断点：停止执行 JavaScript 代码，并且可以使用调试器打印变量的值，检查调用堆栈等。例如，假设您在函数 f() 中遇到一个异常，因为该异常正在使用未定义的参数进行调用，而您无法弄清楚该调用的来源。为了帮助调试此问题，可以更改 f() 使其开始，如下所示： function f(o) { if (o === undefined) debugger; // Temporary line for debugging purposes ... // The rest of the function goes here. } Now, when f() is called with no argument, execution will stop, and you can use the debugger to inspect the call stack and find out where this incorrect call is coming from. 现在，当不带任何参数调用 f() 时，执行将停止，并且可以使用调试器检查调用堆栈，并找出此错误调用的出处。 Note that it is not enough to have a debugger available: the debugger statement won’t start the debugger for you. If you’re using a web browser and have the developer tools console open, however, this statement will cause a breakpoint. 请注意，仅有 debugger 是不够的：debugger 语句不会为启动调试器。但是，如果您使用的是网络浏览器并打开了开发者工具控制台，则此语句将导致一个断点。 ","date":"2020-11-02","objectID":"/posts/ch5/:6:2","tags":null,"title":"第 5 章 语句","uri":"/posts/ch5/"},{"categories":null,"content":"5.6.3 “use strict” “use strict” is a directive introduced in ES5. Directives are not statements (but are close enough that “use strict” is documented here). There are two important differences between the “use strict” directive and regular statements: “use strict”是ES5中引入的指令。指令不是语句（但足够接近，因此此处记录了“use strict”）。“use strict”指令和常规语句之间有两个重要区别： It does not include any language keywords: the directive is just an expression statement that consists of a special string literal (in single or double quotes). 它不包含任何语言关键字：指令只是由特殊字符串文字（单引号或双引号）组成的表达式语句。 It can appear only at the start of a script or at the start of a function body, before any real statements have appeared. 它只能出现在脚本的开始处或函数体的开始处，然后才出现任何实际的语句。 The purpose of a “use strict” directive is to indicate that the code that follows (in the script or function) is strict code. The top-level (nonfunction) code of a script is strict code if the script has a “use strict” directive. A function body is strict code if it is defined within strict code or if it has a “use strict” directive. Code passed to the eval() method is strict code if eval() is called from strict code or if the string of code includes a “use strict” directive. In addition to code explicitly declared to be strict, any code in a class body (Chapter 9) or in an ES6 module (§10.3) is automatically strict code. This means that if all of your JavaScript code is written as modules, then it is all automatically strict, and you will never need to use an explicit “use strict” directive. “use strict”指令的目的是指示（在脚本或函数中）后面的代码是严格代码。如果脚本具有“use strict”指令，则该脚本的顶级（非函数）代码为严格代码。如果函数体是在严格代码中定义的，或者具有“use strict”指令，则它是严格代码。如果从严格代码中调用 eval() 或代码字符串包含“use strict”指令，则传递给 eval() 方法的代码为严格代码。除了明确声明为严格的代码之外，类主体（第9章）或 ES6 模块（10.3）中的任何代码都是自动严格的代码。这意味着，如果所有的JavaScript代码都是作为模块编写的，那么它们都是自动严格的，并且将不需要使用显式的“use strict”指令。 Strict code is executed in strict mode. Strict mode is a restricted subset of the language that fixes important language deficiencies and provides stronger error checking and increased security. Because strict mode is not the default, old JavaScript code that still uses the deficient legacy features of the language will continue to run correctly. The differences between strict mode and non-strict mode are the following (the first three are particularly important): 严格代码在严格模式下执行。严格模式是该语言的受限子集，可修复重要的语言缺陷并提供更强的错误检查和更高的安全性。由于严格模式不是默认模式，因此旧 JavaScript 代码使用不足传统特性将继续正确运行。严格模式和非严格模式之间的区别如下（前三个特别重要）： The with statement is not allowed in strict mode. 在严格模式下，不允许使用 with 语句。 In strict mode, all variables must be declared: a ReferenceError is thrown if you assign a value to an identifier that is not a declared variable, function, function parameter, catch clause parameter, or property of the global object. (In non-strict mode, this implicitly declares a global variable by adding a new property to the global object.) 在严格模式下，必须声明所有变量：如果将值分配给未声明的变量、函数、函数参数、catch 子句参数或全局对象的属性的标识符，则会引发 ReferenceError。（在非严格模式下，通过向全局对象添加新属性来隐式声明全局变量。） In strict mode, functions invoked as functions (rather than as methods) have a this value of undefined. (In non-strict mode, functions invoked as functions are always passed the global object as their this value.) Also, in strict mode, when a function is invoked with call() or apply() (§8.7.4), the this value is exactly the value passed as the first argument to call() or apply(). (In non-strict mode, null and undefined values are replaced with the global object and nonobject values are converted to objects.) 在严格模式下，作为函数（而不是方法）调用的函数的 this 值是 undefined。（在非严格模式下，作为函数调用的函数总是将全局对象作为其 this 值。）此外，在严格模式下，当使用 call() 或 apply() 调用函数时（§8.7.4），this 值作为第一个参数传递给 call() 或 apply() 的值。（在非严格模式下，将 null 和 undefined 值替换为全局对象，并将 nonobject 值转换为对象。） In strict mode, assignments to nonwritable properties and attempts to create new properties on non-extensible objects throw a TypeError. (In non-strict mode, these attempts fail silently.) 在严格模式下，对不可写属性的分配以及在不可扩展对象上尝试创建新属性的尝试将引发 TypeError。（在非严格模式下，这些尝试将以静默方式失败。） In strict mode, code passed to eval() cannot declare va","date":"2020-11-02","objectID":"/posts/ch5/:6:3","tags":null,"title":"第 5 章 语句","uri":"/posts/ch5/"},{"categories":null,"content":"5.7 Declarations The keywords const, let, var, function, class, import, and export are not technically statements, but they look a lot like statements, and this book refers informally to them as statements, so they deserve a mention in this chapter. 从技术上讲，关键字 const、let、var、function、class、import 和 export 并不是语句，但它们看起来很像语句，并且本书将它们非正式地称为语句，因此在本章中应予提及。 These keywords are more accurately described as declarations rather than statements. We said at the start of this chapter that statements “make something happen.” Declarations serve to define new values and give them names that we can use to refer to those values. They don’t make much happen themselves, but by providing names for values they, in an important sense, define the meaning of the other statements in your program. 这些关键字被更准确地描述为声明而不是语句。我们在本章开始时说过，语句“使某事发生”。声明用于定义新值，并为它们提供可用来引用这些值的名称。它们本身并不会带来太大的变化，但是通过提供值的名称，它们在重要的意义上定义了程序中其他语句的含义。 When a program runs, it is the program’s expressions that are being evaluated and the program’s statements that are being executed. The declarations in a program don’t “run” in the same way: instead, they define the structure of the program itself. Loosely, you can think of declarations as the parts of the program that are processed before the code starts running. 程序运行时，将对程序的表达式进行评估，并执行程序的语句。程序中的声明不是以相同的方式“运行”：相反，它们定义了程序本身的结构。不确切地说，可以将声明视为代码开始运行之前已处理的部分程序。 JavaScript declarations are used to define constants, variables, functions, and classes and for importing and exporting values between modules. The next subsections give examples of all of these declarations. They are all covered in much more detail elsewhere in this book. JavaScript 声明用于定义常量、变量、函数和类，以及在模块之间导入和导出值。接下来的小节将给出所有这些声明的示例。在本书的其他地方，将对它们进行更详细的介绍。 ","date":"2020-11-02","objectID":"/posts/ch5/:7:0","tags":null,"title":"第 5 章 语句","uri":"/posts/ch5/"},{"categories":null,"content":"5.7.1 const, let, and var The const, let, and var declarations are covered in §3.10. In ES6 and later, const declares constants, and let declares variables. Prior to ES6, the var keyword was the only way to declare variables and there was no way to declare constants. Variables declared with var are scoped to the containing function rather than the containing block. This can be a source of bugs, and in modern JavaScript there is really no reason to use var instead of let. const TAU = 2*Math.PI; let radius = 3; var circumference = TAU * radius; ","date":"2020-11-02","objectID":"/posts/ch5/:7:1","tags":null,"title":"第 5 章 语句","uri":"/posts/ch5/"},{"categories":null,"content":"5.7.2 function The function declaration is used to define functions, which are covered in detail in Chapter 8. (We also saw function in §4.3, where it was used as part of a function expression rather than a function declaration.) A function declaration looks like this: function area(radius) { return Math.PI * radius * radius; } A function declaration creates a function object and assigns it to the specified name—area in this example. Elsewhere in our program, we can refer to the function—and run the code inside it—by using this name. The function declarations in any block of JavaScript code are processed before that code runs, and the function names are bound to the function objects throughout the block. We say that function declarations are “hoisted” because it is as if they had all been moved up to the top of whatever scope they are defined within. The upshot is that code that invokes a function can exist in your program before the code that declares the function. §12.3 describes a special kind of function known as a generator. Generator declarations use the function keyword but follow it with an asterisk. §13.3 describes asynchronous functions, which are also declared using the function keyword but are prefixed with the async keyword. ","date":"2020-11-02","objectID":"/posts/ch5/:7:2","tags":null,"title":"第 5 章 语句","uri":"/posts/ch5/"},{"categories":null,"content":"5.7.3 class In ES6 and later, the class declaration creates a new class and gives it a name that we can use to refer to it. Classes are described in detail in Chapter 9. A simple class declaration might look like this: class Circle { constructor(radius) { this.r = radius; } area() { return Math.PI * this.r * this.r; } circumference() { return 2 * Math.PI * this.r; } } Unlike functions, class declarations are not hoisted, and you cannot use a class declared this way in code that appears before the declaration. ","date":"2020-11-02","objectID":"/posts/ch5/:7:3","tags":null,"title":"第 5 章 语句","uri":"/posts/ch5/"},{"categories":null,"content":"5.7.4 import and export The import and export declarations are used together to make values defined in one module of JavaScript code available in another module. A module is a file of JavaScript code with its own global namespace, completely independent of all other modules. The only way that a value (such as function or class) defined in one module can be used in another module is if the defining module exports it with export and the using module imports it with import. Modules are the subject of Chapter 10, and import and export are covered in detail in §10.3. import directives are used to import one or more values from another file of JavaScript code and give them names within the current module. import directives come in a few different forms. Here are some examples: import Circle from './geometry/circle.js'; import { PI, TAU } from './geometry/constants.js'; import { magnitude as hypotenuse } from './vectors/utils.js'; Values within a JavaScript module are private and cannot be imported into other modules unless they have been explicitly exported. The export directive does this: it declares that one or more values defined in the current module are exported and therefore available for import by other modules. The export directive has more variants than the import directive does. Here is one of them: // geometry/constants.js const PI = Math.PI; const TAU = 2 * PI; export { PI, TAU }; The export keyword is sometimes used as a modifier on other declarations, resulting in a kind of compound declaration that defines a constant, variable, function, or class and exports it at the same time. And when a module exports only a single value, this is typically done with the special form export default: export const TAU = 2 * Math.PI; export function magnitude(x,y) { return Math.sqrt(x*x + y*y); } export default class Circle { /* class definition omitted here */ } ","date":"2020-11-02","objectID":"/posts/ch5/:7:4","tags":null,"title":"第 5 章 语句","uri":"/posts/ch5/"},{"categories":null,"content":"5.8 Summary of JavaScript Statements This chapter introduced each of the JavaScript language’s statements, which are summarized in Table 5-1. Table 5-1. JavaScript statement syntax Statement Purpose break Exit from the innermost loop or switch or from named enclosing statement case Label a statement within a switch class Declare a class const Declare and initialize one or more constants continue Begin next iteration of the innermost loop or the named loop debugger Debugger breakpoint default Label the default statement within a switch do/while An alternative to the while loop export Declare values that can be imported into other modules for An easy-to-use loop for/await Asynchronously iterate the values of an async iterator for/in Enumerate the property names of an object for/of Enumerate the values of an iterable object such as an array function Declare a function if/else Execute one statement or another depending on a condition import Declare names for values defined in other modules label Give statement a name for use with break and continue let Declare and initialize one or more block-scoped variables (new syntax) return Return a value from a function switch Multiway branch to case or default: labels throw Throw an exception try/catch/finally Handle exceptions and code cleanup “use strict” Apply strict mode restrictions to script or function var Declare and initialize one or more variables (old syntax) while A basic loop construct with Extend the scope chain (deprecated and forbidden in strict mode) yield Provide a value to be iterated; only used in generator functions The fact that the case expressions are evaluated at runtime makes the JavaScript switch statement much different from (and less efficient than) the switch statement of C, C++, and Java. In those languages, the case expressions must be compile-time constants of the same type, and switch statements can often compile down to highly efficient jump tables. When we consider the continue statement in §5.5.3, we’ll see that this while loop is not an exact equivalent of the for loop. ","date":"2020-11-02","objectID":"/posts/ch5/:8:0","tags":null,"title":"第 5 章 语句","uri":"/posts/ch5/"},{"categories":null,"content":"Objects are JavaScript’s most fundamental datatype, and you have already seen them many times in the chapters that precede this one. Because objects are so important to the JavaScript language, it is important that you understand how they work in detail, and this chapter provides that detail. It begins with a formal overview of objects, then dives into practical sections about creating objects and querying, setting, deleting, testing, and enumerating the properties of objects. These property-focused sections are followed by sections that explain how to extend, serialize, and define important methods on objects. Finally, the chapter concludes with a long section about new object literal syntax in ES6 and more recent versions of the language. 对象是 JavaScript 最基本的数据类型，在本章之前的章节中已经多次看到它们。因为对象对 JavaScript 语言非常重要，所以了解它们的工作原理非常重要，本章将提供这些细节。它从对象的正式概述开始，然后深入到关于创建对象以及查询、设置、删除、测试和枚举对象属性的实用部分。在这些以属性为中心的章节之后，将介绍如何扩展、序列化和定义对象上的重要方法。最后，本章以一大段关于 ES6 中的新对象文字语法和该语言的最新版本结尾。 ","date":"2020-11-02","objectID":"/posts/ch6/:0:0","tags":null,"title":"第 6 章 对象","uri":"/posts/ch6/"},{"categories":null,"content":"6.1 Introduction to Objects An object is a composite value: it aggregates multiple values (primitive values or other objects) and allows you to store and retrieve those values by name. An object is an unordered collection of properties, each of which has a name and a value. Property names are usually strings (although, as we’ll see in §6.10.3, property names can also be Symbols), so we can say that objects map strings to values. This string-to-value mapping goes by various names—you are probably already familiar with the fundamental data structure under the name “hash,” “hashtable,” “dictionary,” or “associative array.” An object is more than a simple string-to-value map, however. In addition to maintaining its own set of properties, a JavaScript object also inherits the properties of another object, known as its “prototype.” The methods of an object are typically inherited properties, and this “prototypal inheritance” is a key feature of JavaScript. 对象是一个复合值：它聚合了多个值（原始值或其他对象），并允许按名称存储和获取这些值。对象是属性的无序集合，每个属性都有一个名称和一个值。属性名通常是字符串（尽管，正如我们将在 §6.10.3 中看到的，属性名也可以是 Symbol），所以我们可以说对象将字符串映射到值。这种字符串到值的映射有不同的名称——可能已经熟悉这种基本数据结构的别的名称“散列”（hash）、“散列表”（hashtable）、“字典”（dictionary）或“关联数组”（associative array）。然而，对象不仅仅是简单的字符串到值的映射。除了维护自己的属性集，JavaScript 对象还继承另一个对象的属性，即它的“原型”。对象的方法通常是继承的属性，而这种“原型继承”是 JavaScript 的一个关键特性。 JavaScript objects are dynamic—properties can usually be added and deleted—but they can be used to simulate the static objects and “structs” of statically typed languages. They can also be used (by ignoring the value part of the string-to-value mapping) to represent sets of strings. JavaScript 对象是动态的——属性通常可以添加和删除——但它们可以用来模拟静态类型语言的静态对象和“结构体”（struct）。有时它们也用做字符串的集 合（忽略名/值对中的值）。 Any value in JavaScript that is not a string, a number, a Symbol, or true, false, null, or undefined is an object. And even though strings, numbers, and booleans are not objects, they can behave like immutable objects. JavaScript 中任何不是字符串、数字、Symbol 或 true、false、null 或 undefined 的值都是对象。即使字符串、数字和布尔值不是对象，它们的行为和不可变对象非常类似。 Recall from §3.8 that objects are mutable and manipulated by reference rather than by value. If the variable x refers to an object and the code let y = x; is executed, the variable y holds a reference to the same object, not a copy of that object. Any modifications made to the object through the variable y are also visible through the variable x. 回想一下 §3.8，对象是可变的，通过引用而不是值来操作。如果变量 x 指向一个对象的引用，执行 y = x; 时，变量 y 也是指向同一对象的引用，而不是该对象的副本。通过变量 y 修改这个对象也会对变量 x 造成影响。 The most common things to do with objects are to create them and set, query, delete, test, and enumerate their properties. These fundamental operations are described in the opening sections of this chapter. The sections after that cover more advanced topics. 对对象最常见的操作是创建它们并设置、查询、删除、测试和枚举它们的属性。这些基本的操作将在本章的开头部分进行描述。之后的部分将介绍更高级的主题。 A property has a name and a value. A property name may be any string, including the empty string (or any Symbol), but no object may have two properties with the same name. The value may be any JavaScript value, or it may be a getter or setter function (or both). We’ll learn about getter and setter functions in §6.10.6. 属性有一个名称和一个值。属性名可以是任何字符串，包括空字符串（或任何 Symbol），但任何对象都不能有两个同名的属性。值可以是任何 JavaScript 值，也可以是 getter 或 setter 函数（或两者都是）。我们将在 §6.10.6 中学习 getter 和 setter 函数。 It is sometimes important to be able to distinguish between properties defined directly on an object and those that are inherited from a prototype object. JavaScript uses the term own property to refer to non-inherited properties. 有时，能够区分直接在对象上定义的属性和从原型对象继承的属性是很重要的。JavaScript 使用术语“自有属性”来指代非继承属性。 In addition to its name and value, each property has three property attributes: 除了名称和值之外，每个属性还有三个属性属性: The writable attribute specifies whether the value of the property can be set. The enumerable attribute specifies whether the property name is returned by a for/in loop. The configurable attribute specifies whether the property can be deleted and whether its attributes can be altered. writable 属性指定是否可以设置属性的值。 enumerable 属","date":"2020-11-02","objectID":"/posts/ch6/:1:0","tags":null,"title":"第 6 章 对象","uri":"/posts/ch6/"},{"categories":null,"content":"6.2 Creating Objects Objects can be created with object literals, with the new keyword, and with the Object.create() function. The subsections below describe each technique. 对象可以用对象字面量创建，也可以用 new 关键字和 Object.create() 函数来创建。接下来的几部分对这些技术一一讲述。 ","date":"2020-11-02","objectID":"/posts/ch6/:2:0","tags":null,"title":"第 6 章 对象","uri":"/posts/ch6/"},{"categories":null,"content":"6.2.1 Object Literals The easiest way to create an object is to include an object literal in your JavaScript code. In its simplest form, an object literal is a comma-separated list of colon-separated name:value pairs, enclosed within curly braces. A property name is a JavaScript identifier or a string literal (the empty string is allowed). A property value is any JavaScript expression; the value of the expression (it may be a primitive value or an object value) becomes the value of the property. Here are some examples: 创建对象最简单的方式就是在 JavaScript 代码中使用对象直接量。对象直接量是由若干名/值对组成的映射表，名/值对中间用冒号分隔，名/值对之间用逗号分隔，整个映射表用花括号括起来。属性名可以是 JavaScript 标识符也可以是字符串字面量（包括空字符串）。属性的值可以是任意类型的 JavaScript 表达式；表达式的值（可以是原始值也可以是对象值）变成这个属性的值。下面有一些例子： let empty = {}; // An object with no properties let point = { x: 0, y: 0 }; // Two numeric properties let p2 = { x: point.x, y: point.y+1 }; // More complex values let book = { \"main title\": \"JavaScript\", // These property names include spaces, \"sub-title\": \"The Definitive Guide\", // and hyphens, so use string literals. for: \"all audiences\", // for is reserved, but no quotes. author: { // The value of this property is firstname: \"David\", // itself an object. surname: \"Flanagan\" } }; A trailing comma following the last property in an object literal is legal, and some programming styles encourage the use of these trailing commas so you’re less likely to cause a syntax error if you add a new property at the end of the object literal at some later time. 对象文本中最后一个属性的尾随逗号是合法的，并且某些编程样式鼓励使用这些尾随逗号，因为，如果之后在对象文本的末尾添加新属性，则不太可能导致语法错误。 An object literal is an expression that creates and initializes a new and distinct object each time it is evaluated. The value of each property is evaluated each time the literal is evaluated. This means that a single object literal can create many new objects if it appears within the body of a loop or in a function that is called repeatedly, and that the property values of these objects may differ from each other. 对象字面量是一个表达式，它每次计算时都会创建和初始化一个新对象。每次字面量计算时，将计算每个属性的值。这意味着，如果单个对象字面量出现在循环体或重复调用的函数中，它能创建许多个新对象，并且这些对象的属性值可能彼此不同。 The object literals shown here use simple syntax that has been legal since the earliest versions of JavaScript. Recent versions of the language have introduced a number of new object literal features, which are covered in §6.10. 此处的简单语法对象字面量，自 JavaScript 最早的版本以来一直是合法的。最新版本引入了许多对象字面量的新的特性，这些特性在 §6.10 中介绍。 ","date":"2020-11-02","objectID":"/posts/ch6/:2:1","tags":null,"title":"第 6 章 对象","uri":"/posts/ch6/"},{"categories":null,"content":"6.2.2 Creating Objects with new The new operator creates and initializes a new object. The new keyword must be followed by a function invocation. A function used in this way is called a constructor and serves to initialize a newly created object. JavaScript includes constructors for its built-in types. For example: new 运算符创建并初始化一个新的对象。new 关键字必须紧跟一个函数调用。这种方式使用函数叫做构造函数调用，其提供初始化一个新创建的对象的服务。在 JavaScript 中，内置类型都包含相对应的构造函数。例如： let o = new Object(); // Create an empty object: same as {}. let a = new Array(); // Create an empty array: same as []. let d = new Date(); // Create a Date object representing the current time let r = new Map(); // Create a Map object for key/value mapping In addition to these built-in constructors, it is common to define your own constructor functions to initialize newly created objects. Doing so is covered in Chapter 9. 除了这些内置构造函数，常常用自定义构造函数来初始化新对象。 第 9 章将详细讲述其中的细节。 ","date":"2020-11-02","objectID":"/posts/ch6/:2:2","tags":null,"title":"第 6 章 对象","uri":"/posts/ch6/"},{"categories":null,"content":"6.2.3 Prototypes Before we can cover the third object creation technique, we must pause for a moment to explain prototypes. Almost every JavaScript object has a second JavaScript object associated with it. This second object is known as a prototype, and the first object inherits properties from the prototype. 在讲述第三种对象创建技术之前，我们应当首先解释一下原型。每一个 JavaScript 对象都和另一个对象相关联。“另一个”对象就是我们熟知的原型，每一个对象都从原型继承属性。 All objects created by object literals have the same prototype object, and we can refer to this prototype object in JavaScript code as Object.prototype. Objects created using the new keyword and a constructor invocation use the value of the prototype property of the constructor function as their prototype. So the object created by new Object() inherits from Object.prototype, just as the object created by {} does. Similarly, the object created by new Array() uses Array.prototype as its prototype, and the object created by new Date() uses Date.prototype as its prototype. This can be confusing when first learning JavaScript. Remember: almost all objects have a prototype, but only a relatively small number of objects have a prototype property. It is these objects with prototype properties that define the prototypes for all the other objects. 所有通过对象字面量创建的对象都具有同一个原型对象，并可以通过 JavaScript 代码 Object.prototype 获得对原型对象的引用。通过关键字 new 和构造函数调用创建的对象的原型就是构造函数的 prototype 属性的值。因此，同使用 {} 创建对象一样，通过 new Object() 创建的对象也继承自Object.prototype。同样，通过 new Array() 创建的对象的原型就是 Array.prototype，通过 new Date() 创建的对象的原型就是 Date.prototype。当第一次学习 JavaScript 时，这可能令人困惑。请记住：几乎所有对象都有原型，但只有相对较少的对象具有原型属性。正是这些具有原型属性的对象定义了所有其他对象的原型。 Object.prototype is one of the rare objects that has no prototype: it does not inherit any properties. Other prototype objects are normal objects that do have a prototype. Most built-in constructors (and most user-defined constructors) have a prototype that inherits from Object.prototype. For example, Date.prototype inherits properties from Object.prototype, so a Date object created by new Date() inherits properties from both Date.prototype and Object.prototype. This linked series of prototype objects is known as a prototype chain. 没有原型的对象为数不多，Object.prototype就是其中之一：它不继承任何属性。其他原型对象都是普通对象，普通对象都具有原型。大部分的内置构造函数（以及大部分自定义的构造函数）都具有一个继承自 Object.prototype 的原型。例如， Date.prototype 的属性继承自 Object.prototype，因此由 new Date() 创建的 Date 对象的属性同时继承自 Date.prototype 和 Object.prototype。这一系列链接的原型对象就是所谓 “原型链”（prototype chain）。 An explanation of how property inheritance works is in §6.3.2. Chapter 9 explains the connection between prototypes and constructors in more detail: it shows how to define new “classes” of objects by writing a constructor function and setting its prototype property to the prototype object to be used by the “instances” created with that constructor. And we’ll learn how to query (and even change) the prototype of an object in §14.3. §6.3.2 节讲述属性继承的工作机制。第 9 章将会更详细地讨论原型和构造函数：包括如何通过编写构造函数定义对象的“类”，以及给构造函数的 prototype 属性赋值可以让其“实例”直接使用这个原型上的属性和方法。并且在 §14.3 我们会学习如何查询（甚至改变）对象的原型。 ","date":"2020-11-02","objectID":"/posts/ch6/:2:3","tags":null,"title":"第 6 章 对象","uri":"/posts/ch6/"},{"categories":null,"content":"6.2.4 Object.create() Object.create() creates a new object, using its first argument as the prototype of that object: Object.create() 创建一个新的对象，用第一个实参作为它的原型： let o1 = Object.create({x: 1, y: 2}); // o1 inherits properties x and y. o1.x + o1.y // =\u003e 3 You can pass null to create a new object that does not have a prototype, but if you do this, the newly created object will not inherit anything, not even basic methods like toString() (which means it won’t work with the + operator either): 可以通过传入参数 null 来创建一个没有原型的新对象，但通过这种方式创建的对象不会继承任何东西，甚至不包括基础方法，比如 toString()，也就是说，它将不能和“+”运算符一起正常工作： let o2 = Object.create(null); // o2 inherits no props or methods. If you want to create an ordinary empty object (like the object returned by {} or new Object()), pass Object.prototype: 如果想创建一个普通的空对象（像通过 {} 或 new Object() 创建的对象），需要传入 Object.prototype： let o3 = Object.create(Object.prototype); // o3 is like {} or new Object(). The ability to create a new object with an arbitrary prototype is a powerful one, and we’ll use Object.create() in a number of places throughout this chapter. (Object.create() also takes an optional second argument that describes the properties of the new object. This second argument is an advanced feature covered in §14.1.) 可以通过任意原型创建新对象，这是一个强大的特性，并且本章我们会在很多地方使用 Object.create()。（Object.create() 也可以传入第二个可选实参来描述这个新的对象的属性。第二个实参是一个高级特性，在 §14.1 再进行描述。） One use for Object.create() is when you want to guard against unintended (but nonmalicious) modification of an object by a library function that you don’t have control over. Instead of passing the object directly to the function, you can pass an object that inherits from it. If the function reads properties of that object, it will see the inherited values. If it sets properties, however, those writes will not affect the original object. Object.create() 其中一个用途是预防对象无意间（非恶意地）被无法支配的库函数篡改。可以创建一个继承它的对象来传递给函数，而不是将其直接传递给函数。当函数读取继承对象的属性时，实际上读取的是继承来的值。如果给继承对象的属性赋值，则这些属性只会影响这个继承对象自身，而不是原始对象： let o = { x: \"don't change this value\" }; library.function(Object.create(o)); // Guard against accidental modifications To understand why this works, you need to know how properties are queried and set in JavaScript. These are the topics of the next section. 想要了解其工作原理，需要先知道 JavaScript 中属性的查询和设置机制。这是接下来这节的主题。 ","date":"2020-11-02","objectID":"/posts/ch6/:2:4","tags":null,"title":"第 6 章 对象","uri":"/posts/ch6/"},{"categories":null,"content":"6.3 Querying and Setting Properties To obtain the value of a property, use the dot (.) or square bracket ([]) operators described in §4.4. The lefthand side should be an expression whose value is an object. If using the dot operator, the righthand side must be a simple identifier that names the property. If using square brackets, the value within the brackets must be an expression that evaluates to a string that contains the desired property name: §4.4 已经提到，可以通过点（.）或方括号（[]）运算符来获取属性的值。运算符左侧应当是一个表达式，它返回一个对象。如果使用点运算符，右侧必须是一个以属性名称命名的简单标识符。如果使用方括号，方括号内必须是一个计算结果为字符串的表达式，这个字符串就是属性的名字： let author = book.author; // Get the \"author\" property of the book. let name = author.surname; // Get the \"surname\" property of the author. let title = book[\"main title\"]; // Get the \"main title\" property of the book. To create or set a property, use a dot or square brackets as you would to query the property, but put them on the lefthand side of an assignment expression: 和查询属性值的写法一样，通过点和方括号也可以创建属性或给属性赋值，但需要将它们放在赋值表达式的左侧： book.edition = 7; // Create an \"edition\" property of book. book[\"main title\"] = \"ECMAScript\"; // Change the \"main title\" property. When using square bracket notation, we’ve said that the expression inside the square brackets must evaluate to a string. A more precise statement is that the expression must evaluate to a string or a value that can be converted to a string or to a Symbol (§6.10.3). In Chapter 7, for example, we’ll see that it is common to use numbers inside the square brackets. 当使用方括号时，我们说方括号内的表达式必须返回字符串。其实更严格地讲，表达式必须返回字符串或返回一个可以转换为字符串的值或 Symbol（§6.10.3）。在第 7 章里有一些例子中的方括号内使用了数字，这情况是非常常用的。 ","date":"2020-11-02","objectID":"/posts/ch6/:3:0","tags":null,"title":"第 6 章 对象","uri":"/posts/ch6/"},{"categories":null,"content":"6.3.1 Objects As Associative Arrays As explained in the preceding section, the following two JavaScript expressions have the same value: 上文提到，下面两个表达式有相同的值： object.property object[\"property\"] The first syntax, using the dot and an identifier, is like the syntax used to access a static field of a struct or object in C or Java. The second syntax, using square brackets and a string, looks like array access, but to an array indexed by strings rather than by numbers. This kind of array is known as an associative array (or hash or map or dictionary). JavaScript objects are associative arrays, and this section explains why that is important. 第一种语法使用点运算符和一个标识符，这和 C 和 Java 中访问一个结构体或对象的静态字段非常类似。第二种语法使用方括号和一个字符串，看起来更像数组，只是这个数组元素是通过字符串索引而不是数字索引。这种数组就是我们所说的关联数组（associative array）（也称做散列、映射或字典）。JavaScript 对象都是关联数组，本节将讨论它的重要性。 In C, C++, Java, and similar strongly typed languages, an object can have only a fixed number of properties, and the names of these properties must be defined in advance. Since JavaScript is a loosely typed language, this rule does not apply: a program can create any number of properties in any object. When you use the . operator to access a property of an object, however, the name of the property is expressed as an identifier. Identifiers must be typed literally into your JavaScript program; they are not a datatype, so they cannot be manipulated by the program. 在 C、C++、Java 和一些强类型语言中，对象只能拥有固定数目的属性，并且这些属性的名称必须提前定义好。由于 JavaScript 是一个弱类型语言，因此不适用这条规则：对象在程序中可以创建任意数量的属性。当使用 . 运算符访问对象的属性时，属性名用一个标识符来表示。标识符必须直接出现在 JavaScript 程序中，它们不是数据类型，所以无法在程序中修改。 On the other hand, when you access a property of an object with the [] array notation, the name of the property is expressed as a string. Strings are JavaScript datatypes, so they can be manipulated and created while a program is running. So, for example, you can write the following code in JavaScript: 另一种方式，当通过 [] 来访问对象的属性时，属性名通过字符串来表示。字符串是 JavaScript 的数据类型，在程序运行时可以修改和创建它们。因此，可以在 JavaScript 中使用下面这种代码： let addr = \"\"; for(let i = 0; i \u003c 4; i++) { addr += customer[`address${i}`] + \"\\n\"; } This code reads and concatenates the address0, address1, address2, and address3 properties of the customer object. 这段代码读取 customer 对象的 address0、address1、address2 和 address3 属性，并将它们连接起来。 This brief example demonstrates the flexibility of using array notation to access properties of an object with string expressions. This code could be rewritten using the dot notation, but there are cases in which only the array notation will do. Suppose, for example, that you are writing a program that uses network resources to compute the current value of the user’s stock market investments. The program allows the user to type in the name of each stock they own as well as the number of shares of each stock. You might use an object named portfolio to hold this information. The object has one property for each stock. The name of the property is the name of the stock, and the property value is the number of shares of that stock. So, for example, if a user holds 50 shares of stock in IBM, the portfolio.ibm property has the value 50. 这个例子主要说明了通过字符串表达式使用数组标记来访问对象属性的灵活性。这段代码也可以通过点运算符来重写，但是一些场景只能使用数组写法来完成。假设你正在写一个程序，这个程序利用网络资源计算用户股票市场投资的当前价值。程序允许用户输入他们拥有的股票名称以及对应的数量。你可以用一个名为 portfolio 的对象来储存这些信息。每一个股票在对象中都有一个属性与之对应。属性名是股票名，属性值是股票持有份额。例如，如果用户持有 IBM 的 50 股，那么 portfolio.ibm 属性的值就为 50。 Part of this program might be a function for adding a new stock to the portfolio: 下面是程序的部分代码，这个函数用来给 portifolio 添加新的股票： function addstock(portfolio, stockname, shares) { portfolio[stockname] = shares; } Since the user enters stock names at runtime, there is no way that you can know the property names ahead of time. Since you can’t know the property names when you write the program, there is no way you can use the . operator to access the properties of the portfolio object. You can use the [] operator, however, because it uses a string value (which is dynamic and can change at runtime) rather than an identifier (which is static and must be hardcoded","date":"2020-11-02","objectID":"/posts/ch6/:3:1","tags":null,"title":"第 6 章 对象","uri":"/posts/ch6/"},{"categories":null,"content":"6.3.2 Inheritance JavaScript objects have a set of “own properties,” and they also inherit a set of properties from their prototype object. To understand this, we must consider property access in more detail. The examples in this section use the Object.create() function to create objects with specified prototypes. We’ll see in Chapter 9, however, that every time you create an instance of a class with new, you are creating an object that inherits properties from a prototype object. JavaScript 对象中有一组“自有属性”，也有一组属性是继承自它的原型对象。想要理解属性继承，必须更深入地了解属性访问的细节。这一节的例子通过使用 Object.create() 函数创建对象来指定它的原型。我们会在第 9 章再次看到它，但是，每次使用 new 创建类的实例时，都会创建一个从原型对象继承属性的对象。 Suppose you query the property x in the object o. If o does not have an own property with that name, the prototype object of o1 is queried for the property x. If the prototype object does not have an own property by that name, but has a prototype itself, the query is performed on the prototype of the prototype. This continues until the property x is found or until an object with a null prototype is searched. As you can see, the prototype attribute of an object creates a chain or linked list from which properties are inherited: 假设要查询对象 o 的属性 x。如果 o 中不存在 x 名称的自由属性，那么将会继续在 o 的原型对象中查询属性 x。如果原型对象中也没有 x，但这个原型对象也有原型，那么继续在这个原型对象的原型上执行查询，直到找到 x 或者查找到一个原型是 null 的对象为止。可以看到，对象的原型属性构成了一个“链”，通过这个“链”可以实现属性的继承。 let o = {}; // o inherits object methods from Object.prototype o.x = 1; // and it now has an own property x. let p = Object.create(o); // p inherits properties from o and Object.prototype p.y = 2; // and has an own property y. let q = Object.create(p); // q inherits properties from p, o, and... q.z = 3; // ...Object.prototype and has an own property z. let f = q.toString(); // toString is inherited from Object.prototype q.x + q.y // =\u003e 3; x and y are inherited from o and p Now suppose you assign to the property x of the object o. If o already has an own (non-inherited) property named x, then the assignment simply changes the value of this existing property. Otherwise, the assignment creates a new property named x on the object o. If o previously inherited the property x, that inherited property is now hidden by the newly created own property with the same name. 现在假设给对象 o 的属性 x 赋值，如果 o 中已经有属性 x（这个属性不是继承来的），那么这个赋值操作只改变这个已有属性 x 的值。否则，赋值操作给 o 添加一个新属性 x。如果之前 o 继承自属性 x，那么这个继承的属性就被新创建的同名属性覆盖了。 Property assignment examines the prototype chain only to determine whether the assignment is allowed. If o inherits a read-only property named x, for example, then the assignment is not allowed. (Details about when a property may be set are in §6.3.3.) If the assignment is allowed, however, it always creates or sets a property in the original object and never modifies objects in the prototype chain. The fact that inheritance occurs when querying properties but not when setting them is a key feature of JavaScript because it allows us to selectively override inherited properties: 属性赋值操作检查原型链只是判断是否允许赋值操作。例如，如果 o 继承自一个只读属性 x，那么赋值操作是不允许的（§6.3.3 将对此进行详细讨论）。 如果允许属性赋值操作，它也总是在原始对象上创建属性或对已有的属性赋值，而不会去修改原型链。在 JavaScript 中，只有在查询属性时才会体会到继承的存在，而设置属性则和继承无关，这是 JavaScript 的一个重要特性，该特性让程序员可以有选择地重写继承的属性。 let unitcircle = { r: 1 }; // An object to inherit from let c = Object.create(unitcircle); // c inherits the property r c.x = 1; c.y = 1; // c defines two properties of its own c.r = 2; // c overrides its inherited property unitcircle.r // =\u003e 1: the prototype is not affected There is one exception to the rule that a property assignment either fails or creates or sets a property in the original object. If o inherits the property x, and that property is an accessor property with a setter method (see §6.10.6), then that setter method is called rather than creating a new property x in o. Note, however, that the setter method is called on the object o, not on the prototype object that defines the property, so if the setter method defines any properties, it will do so on o, and it will again leave the prototype chain unmodified. 属性赋值要么失败，要么创建一个","date":"2020-11-02","objectID":"/posts/ch6/:3:2","tags":null,"title":"第 6 章 对象","uri":"/posts/ch6/"},{"categories":null,"content":"6.3.3 Property Access Errors Property access expressions do not always return or set a value. This section explains the things that can go wrong when you query or set a property. 属性访问表达式并不总是返回或设置一个值。本节讲述查询或设置属性时的一些出错情况。 It is not an error to query a property that does not exist. If the property x is not found as an own property or an inherited property of o, the property access expression o.x evaluates to undefined. Recall that our book object has a “sub-title” property, but not a “subtitle” property: 查询一个不存在的属性并不会报错，如果在对象 o 自身的属性或继承的属性中均未找到属性 x，属性访问表达式 o.x 返回 undefined。回想一下我们的 book 对象有属性“sub-title”，而没有属性“subtitle”： book.subtitle // =\u003e undefined: property doesn't exist It is an error, however, to attempt to query a property of an object that does not exist. The null and undefined values have no properties, and it is an error to query properties of these values. Continuing the preceding example: 但是，如果对象不存在，那么试图查询这个不存在的对象的属性就会报错。null 和 undefined 值都没有属性，因此查询这些值的属性会报错，接上例： let len = book.subtitle.length; // !TypeError: undefined doesn't have length Property access expressions will fail if the lefthand side of the . is null or undefined. So when writing an expression like book.author.surname, you should be careful if you are not certain that book and book.author are actually defined. Here are two ways to guard against this kind of problem: 如果 . 的左边是 null 或 undefined 时，其属性表达式会失败。所以当写一个像 book.author.surname 一样的表达式时，如果你不确定 book 和 book.author 确实被定义就要小心了。下面提供了两种避免出错的方法： // A verbose and explicit technique let surname = undefined; if (book) { if (book.author) { surname = book.author.surname; } } // A concise and idiomatic alternative to get surname or null or undefined surname = book \u0026\u0026 book.author \u0026\u0026 book.author.surname; To understand why this idiomatic expression works to prevent TypeError exceptions, you might want to review the short-circuiting behavior of the \u0026\u0026 operator in §4.10.1. 为了理解为什么这里的第二种方法可以避免类型错误异常，可以参照 §4.10.1节 中关于 \u0026\u0026 运算符的短路行为。 As described in §4.4.1, ES2020 supports conditional property access with ?., which allows us to rewrite the previous assignment expression as: 如 §4.4.1 中所描述，ES2020 支持用 ?. 条件属性访问，它允许这样重写上面的赋值表达式： let surname = book?.author?.surname; Attempting to set a property on null or undefined also causes a TypeError. Attempts to set properties on other values do not always succeed, either: some properties are read-only and cannot be set, and some objects do not allow the addition of new properties. In strict mode (§5.6.3), a TypeError is thrown whenever an attempt to set a property fails. Outside of strict mode, these failures are usually silent. 当然，给 null 和 undefined 设置属性也会报类型错误。给其他值设置属性也不总是成功，有一些属性是只读的，不能重新赋值，有一些对象不允许新增属性。在严格模式下（§5.6.3），属性设定失败时会抛出 TypeError 异常。在非严格模式下，这些失败的处理经常没有任何反应。 The rules that specify when a property assignment succeeds and when it fails are intuitive but difficult to express concisely. An attempt to set a property p of an object o fails in these circumstances: 尽管属性赋值成功或失败的规律看起来很简单，但要描述清楚并不容易。在这些场景下给对象 o 设置属性 p 会失败： o has an own property p that is read-only: it is not possible to set read-only properties. o 中的属性 p 是只读的：不能给只读属性重新赋值。 o has an inherited property p that is read-only: it is not possible to hide an inherited read-only property with an own property of the same name. o 中的属性 p 是继承属性，且它是只读的：不能通过同名自有属性覆盖只读的继承属性。 o does not have an own property p; o does not inherit a property p with a setter method, and o’s extensible attribute (see §14.2) is false. Since p does not already exist in o, and if there is no setter method to call, then p must be added to o. But if o is not extensible, then no new properties can be defined on it. o 中不存在自有属性 p：o 没有使用 setter 方法继承属性 p，并且o的可扩展性是（见 §14.2）false。如果 o 中不存在 p，而且没有 setter 方法可供调用，则 p 一定会添加至 o 中。但如果 o 不是可扩展的，那么在 o 中不能定义新属性。 ","date":"2020-11-02","objectID":"/posts/ch6/:3:3","tags":null,"title":"第 6 章 对象","uri":"/posts/ch6/"},{"categories":null,"content":"6.4 Deleting Properties The delete operator (§4.13.4) removes a property from an object. Its single operand should be a property access expression. Surprisingly, delete does not operate on the value of the property but on the property itself: 删除运算符（§4.13.4）能删除对象中的属性。它的操作数应当是一个属性访问表达式。令人意外的是，delete 没有操作属性的值，而是操作属性的属性： delete book.author; // The book object now has no author property. delete book[\"main title\"]; // Now it doesn't have \"main title\", either. The delete operator only deletes own properties, not inherited ones. (To delete an inherited property, you must delete it from the prototype object in which it is defined. Doing this affects every object that inherits from that prototype.) delete 运算符只删除自有属性，不删除继承属性。（想要删除一个继承属性，必须从定义这个属性的原型对象上删除它。这会影响所有继承这个原型的对象。） A delete expression evaluates to true if the delete succeeded or if the delete had no effect (such as deleting a nonexistent property). delete also evaluates to true when used (meaninglessly) with an expression that is not a property access expression: 如果删除成功或删除没有任何影响时删除表达式计算结果是 true（如删除不存在的属性）。delete 作用于非属性访问表达式（无用代码）时也返回 true。 let o = {x: 1}; // o has own property x and inherits property toString delete o.x // =\u003e true: deletes property x delete o.x // =\u003e true: does nothing (x doesn't exist) but true anyway delete o.toString // =\u003e true: does nothing (toString isn't an own property) delete 1 // =\u003e true: nonsense, but true anyway delete does not remove properties that have a configurable attribute of false. Certain properties of built-in objects are non-configurable, as are properties of the global object created by variable declaration and function declaration. In strict mode, attempting to delete a non-configurable property causes a TypeError. In non-strict mode, delete simply evaluates to false in this case: delete 不能删除那些可配置性为 false 的属性。某些内置对象的属性是不可配置的，比如通过变量声明和函数声明创建的全局对象的属性。在严格模式中，删除一个不可配置属性会报一个类型错误。在非严格模式中，在这些情况下的 delete 操作会返回 false： // In strict mode, all these deletions throw TypeError instead of returning false delete Object.prototype // =\u003e false: property is non-configurable var x = 1; // Declare a global variable delete globalThis.x // =\u003e false: can't delete this property function f() {} // Declare a global function delete globalThis.f // =\u003e false: can't delete this property either When deleting configurable properties of the global object in non-strict mode, you can omit the reference to the global object and simply follow the delete operator with the property name: 当在非严格模式中删除全局对象的可配值属性时，可以省略对全局对象的引用，直接在 delete 操作符后跟随要删除的属性名即可： globalThis.x = 1; // Create a configurable global property (no let or var) delete x // =\u003e true: this property can be deleted In strict mode, however, delete raises a SyntaxError if its operand is an unqualified identifier like x, and you have to be explicit about the property access: 然而在严格模式中，delete 后跟随一个非法的操作数（比如 x），则会报一个语法错误，因此必须显式指定对象及其属性： delete x; // SyntaxError in strict mode delete globalThis.x; // This works ","date":"2020-11-02","objectID":"/posts/ch6/:4:0","tags":null,"title":"第 6 章 对象","uri":"/posts/ch6/"},{"categories":null,"content":"6.5 Testing Properties JavaScript objects can be thought of as sets of properties, and it is often useful to be able to test for membership in the set—to check whether an object has a property with a given name. You can do this with the in operator, with the hasOwnProperty() and propertyIsEnumerable() methods, or simply by querying the property. The examples shown here all use strings as property names, but they also work with Symbols (§6.10.3). JavaScript 对象可以看作属性的集合，我们经常会检测集合中成员的所属关系——判断某个属性是否存在于某个对象中。可以用 in 运算符、hasOwnPreperty() 和 propertyIsEnumerable() 方法来完成这个工作，甚至仅通过属性查询也可以做到这一点。这节的例子都是用字符串作为属性名称，但是也可以用 Symbol 作为属性名（§6.10.3）。 The in operator expects a property name on its left side and an object on its right. It returns true if the object has an own property or an inherited property by that name: in 运算符的左侧是属性名，右侧是对象。如果对象的自有属性或继承属性中包含这个属性则返回 true： let o = { x: 1 }; \"x\" in o // =\u003e true: o has an own property \"x\" \"y\" in o // =\u003e false: o doesn't have a property \"y\" \"toString\" in o // =\u003e true: o inherits a toString property The hasOwnProperty() method of an object tests whether that object has an own property with the given name. It returns false for inherited properties: 对象的 hasOwnProperty() 方法用来检测给定的名字是否是对象的自有属性。对于继承属性它将返回 false： let o = { x: 1 }; o.hasOwnProperty(\"x\") // =\u003e true: o has an own property x o.hasOwnProperty(\"y\") // =\u003e false: o doesn't have a property y o.hasOwnProperty(\"toString\") // =\u003e false: toString is an inherited property The propertyIsEnumerable() refines the hasOwnProperty() test. It returns true only if the named property is an own property and its enumerable attribute is true. Certain built-in properties are not enumerable. Properties created by normal JavaScript code are enumerable unless you’ve used one of the techniques shown in §14.1 to make them non-enumerable. propertyIsEnumerable() 是 hasOwnProperty() 的增强版。只有检测到是自有属性且这个属性的可枚举性为 true 时它才返回 true。某些内置属性是不可枚举的。通常由 JavaScript 代码创建的属性都是可枚举的，除非使用 §14.1 中介绍的技术来让它们不可枚举。 let o = { x: 1 }; o.propertyIsEnumerable(\"x\") // =\u003e true: o has an own enumerable property x o.propertyIsEnumerable(\"toString\") // =\u003e false: not an own property Object.prototype.propertyIsEnumerable(\"toString\") // =\u003e false: not enumerable Instead of using the in operator, it is often sufficient to simply query the property and use !== to make sure it is not undefined: 除了使用 in 运算符之外，另一种更简便的方法是使用 !== 判断一个属性是否是 undefined： let o = { x: 1 }; o.x !== undefined // =\u003e true: o has a property x o.y !== undefined // =\u003e false: o doesn't have a property y o.toString !== undefined // =\u003e true: o inherits a toString property There is one thing the in operator can do that the simple property access technique shown here cannot do. in can distinguish between properties that do not exist and properties that exist but have been set to undefined. Consider this code: 然而有一种场景只能使用 in 运算符而不能使用上述属性访问的方式。in 可以区分不存在的属性和存在但值为 undefined 的属性。例如下面的代码： let o = { x: undefined }; // Property is explicitly set to undefined o.x !== undefined // =\u003e false: property exists but is undefined o.y !== undefined // =\u003e false: property doesn't even exist \"x\" in o // =\u003e true: the property exists \"y\" in o // =\u003e false: the property doesn't exist delete o.x; // Delete the property x \"x\" in o // =\u003e false: it doesn't exist anymore ","date":"2020-11-02","objectID":"/posts/ch6/:5:0","tags":null,"title":"第 6 章 对象","uri":"/posts/ch6/"},{"categories":null,"content":"6.6 Enumerating Properties Instead of testing for the existence of individual properties, we sometimes want to iterate through or obtain a list of all the properties of an object. There are a few different ways to do this. 除了检测对象的属性是否存在，我们还会经常遍历对象的属性。有几种不同的方法可以做到这一点。 The for/in loop was covered in §5.4.5. It runs the body of the loop once for each enumerable property (own or inherited) of the specified object, assigning the name of the property to the loop variable. Built-in methods that objects inherit are not enumerable, but the properties that your code adds to objects are enumerable by default. For example: §5.4.5 讨论过 for/in 循环，其可以在循环体中遍历指定对象中所有可枚举的属性（包括自有属性和继承的属性），把属性名称赋值给循环变量。对象继承的 内置方法不可枚举的，但在代码中给对象添加的属性都是可枚举的（除非用下文中提到的一个方法将它们转换为不可枚举的）。例如： let o = {x: 1, y: 2, z: 3}; // Three enumerable own properties o.propertyIsEnumerable(\"toString\") // =\u003e false: not enumerable for(let p in o) { // Loop through the properties console.log(p); // Prints x, y, and z, but not toString } To guard against enumerating inherited properties with for/in, you can add an explicit check inside the loop body: 为了防止 for/in 枚举到继承属性，可以在循环中添加显示检查： for(let p in o) { if (!o.hasOwnProperty(p)) continue; // Skip inherited properties } for(let p in o) { if (typeof o[p] === \"function\") continue; // Skip all methods } As an alternative to using a for/in loop, it is often easier to get an array of property names for an object and then loop through that array with a for/of loop. There are four functions you can use to get an array of property names: 作为使用 for/in 循环的替代方法，通常使用 for/of 循环遍历易获取对象的属性名称数组。可以使用四个函数获取属性名称数组： Object.keys() returns an array of the names of the enumerable own properties of an object. It does not include non-enumerable properties, inherited properties, or properties whose name is a Symbol (see §6.10.3). Object.keys() 返回对象的可枚举自有属性名称数组集合。数组内不包含不可枚举属性、继承属性或属性名称是 Symbol（见 §6.10.3）的属性 Object.getOwnPropertyNames() works like Object.keys() but returns an array of the names of non-enumerable own properties as well, as long as their names are strings. Object.getOwnPropertyNames() 用起来和 Object.keys() 类似，但是它返回数组中也包含不可迭代的自有属性，只要它们的名称是字符串。 Object.getOwnPropertySymbols() returns own properties whose names are Symbols, whether or not they are enumerable. Object.getOwnPropertySymbols() 返回名称是 Symbol 的自有属性，无论它们是否可枚举。 Reflect.ownKeys() returns all own property names, both enumerable and non-enumerable, and both string and Symbol. (See §14.6.) Reflect.ownKeys() 返回所有的自由属性名称，包括可枚举和不可枚举类型，也包括字符串和 Symbol（见 §14.6）。 There are examples of the use of Object.keys() with a for/of loop in §6.7. 在 §6.7 中有例子使用 for/of 循环 Object.keys()。 ","date":"2020-11-02","objectID":"/posts/ch6/:6:0","tags":null,"title":"第 6 章 对象","uri":"/posts/ch6/"},{"categories":null,"content":"6.6.1 Property Enumeration Order ES6 formally defines the order in which the own properties of an object are enumerated. Object.keys(), Object.getOwnPropertyNames(), Object.getOwnPropertySymbols(), Reflect.ownKeys(), and related methods such as JSON.stringify() all list properties in the following order, subject to their own additional constraints about whether they list non-enumerable properties or properties whose names are strings or Symbols: ES6 正式定义元素的自有属性的枚举顺序。Object.keys()、Object.getOwnPropertyNames()、Object.getOwnPropertyNames()、Object.getOwnPropertySymbols()、Reflect.ownKeys() 和相关方法如 JSON.stringify() 属性列表都按以下顺序排列的，受它们自身是否是不可枚举属性列表或者属性是字符串或者 Symbol 影响： String properties whose names are non-negative integers are listed first, in numeric order from smallest to largest. This rule means that arrays and array-like objects will have their properties enumerated in order. 首先列出名称为非负整数的字符串属性，按从最小到最大的数字顺序列出。此规则意味着数组和数组类对象将按顺序枚举其属性。 After all properties that look like array indexes are listed, all remaining properties with string names are listed (including properties that look like negative numbers or floating-point numbers). These properties are listed in the order in which they were added to the object. For properties defined in an object literal, this order is the same order they appear in the literal. 列出所有看起来像数组索引的属性后，将列出所有具有字符串名称的剩余属性（包括看起来像负数或浮点数字的属性）。这些属性按添加到对象的顺序列出。对于在对象字面量中定义的属性，此顺序与它们在文本中显示的顺序相同。 Finally, the properties whose names are Symbol objects are listed in the order in which they were added to the object. 最后，其名称为 Symbol 对象的属性按添加到对象的顺序列出。 The enumeration order for the for/in loop is not as tightly specified as it is for these enumeration functions, but implementations typically enumerate own properties in the order just described, then travel up the prototype chain enumerating properties in the same order for each prototype object. Note, however, that a property will not be enumerated if a property by that same name has already been enumerated, or even if a non-enumerable property by the same name has already been considered. for/in 循环的枚举顺序不像这些枚举函数那样严格指定，但实现通常按刚才描述的顺序枚举自己的属性，然后向上移动原型链按相同顺序枚举每个原型对象的属性。但是请注意，如果已枚举具有相同名称的属性，或者不可枚举属性已经被检测过再次枚举到相同名称的属性，都不会再次枚举。 ","date":"2020-11-02","objectID":"/posts/ch6/:6:1","tags":null,"title":"第 6 章 对象","uri":"/posts/ch6/"},{"categories":null,"content":"6.7 Extending Objects A common operation in JavaScript programs is needing to copy the properties of one object to another object. It is easy to do that with code like this: 在 JavaScript 代码中有一个很常见的操作，需要将一个对象中的属性拷贝到另外一个对象。以下面的代码很容易实现： let target = {x: 1}, source = {y: 2, z: 3}; for(let key of Object.keys(source)) { target[key] = source[key]; } target // =\u003e {x: 1, y: 2, z: 3} But because this is a common operation, various JavaScript frameworks have defined utility functions, often named extend(), to perform this copying operation. Finally, in ES6, this ability comes to the core JavaScript language in the form of Object.assign(). 但是因为这个是个常用的操作，各种 JavaScript 框架定义公用函数，经常将其命名为 extend() 来执行这个拷贝操作。最后在 ES6 中，这个功能以 Object.assign() 的形式被添加到 JavaScript 核心语言中。 Object.assign() expects two or more objects as its arguments. It modifies and returns the first argument, which is the target object, but does not alter the second or any subsequent arguments, which are the source objects. For each source object, it copies the enumerable own properties of that object (including those whose names are Symbols) into the target object. It processes the source objects in argument list order so that properties in the first source object override properties by the same name in the target object and properties in the second source object (if there is one) override properties with the same name in the first source object. Object.assign() 需要两个或多个对象作为其实参。它修改并返回第一个实参，即目标对象，但不会改变第二个或任何后续参数，这些参数是源对象。对于每个源对象，它将该对象的可枚举自有属性（包括名称为 Symbol 的属性）复制到目标对象中。它按源对象在实参列表顺序中的顺序处理，所以第一个源对象中的属性会重写在目标对象中的同名属性，然后以第二个源对象中的同名属性（如果有第二个源对象）再次重写第一个源对象重写后的属性。 Object.assign() copies properties with ordinary property get and set operations, so if a source object has a getter method or the target object has a setter method, they will be invoked during the copy, but they will not themselves be copied. Object.assign() 通过普通属性的 get 和 set 操作复制属性，因此，如果源对象具有 getter 方法或目标对象具有 setter 方法，则将在复制期间调用它们，但不会复制方法本身。 One reason to assign properties from one object into another is when you have an object that defines default values for many properties and you want to copy those default properties into another object if a property by that name does not already exist in that object. Using Object.assign() naively will not do what you want: 看这样一个场景，有一个对象定义许多属性的默认值，希望将这些默认属性中不存在于目标对象中的属性复制到目标对象中，使用 Object.assign() 不会得到想要的结果： Object.assign(o, defaults); // overwrites everything in o with defaults Instead, what you can do is to create a new object, copy the defaults into it, and then override those defaults with the properties in o: 想得到这个效果需要创建一个新的对象，将默认值拷贝到其中，然后用 o 的属性重写默认值中的属性： o = Object.assign({}, defaults, o); We’ll see in §6.10.4 that you can also express this object copy-and-override operation using the … spread operator like this: 我们会在 §6.10.4 见到，可以用 … 展开操作符如下操作这个对象拷贝并重写： o = {...defaults, ...o}; We could also avoid the overhead of the extra object creation and copying by writing a version of Object.assign() that copies properties only if they are missing: 为了避免对象创建和复制的额外开销，我们还可以通过编写一个 Object.assign() 仅在缺少属性时复制属性： // Like Object.assign() but doesn't override existing properties // (and also doesn't handle Symbol properties) function merge(target, ...sources) { for(let source of sources) { for(let key of Object.keys(source)) { if (!(key in target)) { // This is different than Object.assign() target[key] = source[key]; } } } return target; } Object.assign({x: 1}, {x: 2, y: 2}, {y: 3, z: 4}) // =\u003e {x: 2, y: 3, z: 4} merge({x: 1}, {x: 2, y: 2}, {y: 3, z: 4}) // =\u003e {x: 1, y: 2, z: 4} It is straightforward to write other property manipulation utilities like this merge() function. A restrict() function could delete properties of an object if they do not appear in another template object, for example. Or a subtract() function could remove all of the properties of one object from another object. 编写其他属性操作公共函数很简单，就是像这个 merge() 函数。例如，如果对象的属性不出现在另一个模板对象中，则 restrict() 函数会删除这些属性。或者，subtract() 函数可以从其他对象中删除一个对象的所有属性。 ","date":"2020-11-02","objectID":"/posts/ch6/:7:0","tags":null,"title":"第 6 章 对象","uri":"/posts/ch6/"},{"categories":null,"content":"6.8 Serializing Objects Object serialization is the process of converting an object’s state to a string from which it can later be restored. The functions JSON.stringify() and JSON.parse() serialize and restore JavaScript objects. These functions use the JSON data interchange format. JSON stands for “JavaScript Object Notation,” and its syntax is very similar to that of JavaScript object and array literals: 对象序列化（serialization）是指将对象的状态转换为字符串，也可将字符串还原为对象。函数 JSON.stringify() 和 JSON.parse() 用来序列化和还原 JavaScript 对象。这些方法都使用 JSON 作为数据交换格式，JSON 的全称是“JavaScript Object Notation”——JavaScript 对象表示法，它的语法和 JavaScript 对象与数组字面量的语法非常相近： let o = {x: 1, y: {z: [false, null, \"\"]}}; // Define a test object let s = JSON.stringify(o); // s == '{\"x\":1,\"y\":{\"z\":[false,null,\"\"]}}' let p = JSON.parse(s); // p == {x: 1, y: {z: [false, null, \"\"]}} JSON syntax is a subset of JavaScript syntax, and it cannot represent all JavaScript values. Objects, arrays, strings, finite numbers, true, false, and null are supported and can be serialized and restored. NaN, Infinity, and -Infinity are serialized to null. Date objects are serialized to ISO-formatted date strings (see the Date.toJSON() function), but JSON.parse() leaves these in string form and does not restore the original Date object. Function, RegExp, and Error objects and the undefined value cannot be serialized or restored. JSON.stringify() serializes only the enumerable own properties of an object. If a property value cannot be serialized, that property is simply omitted from the stringified output. Both JSON.stringify() and JSON.parse() accept optional second arguments that can be used to customize the serialization and/or restoration process by specifying a list of properties to be serialized, for example, or by converting certain values during the serialization or stringification process. Complete documentation for these functions is in §11.6. JSON 的语法是 JavaScript 语法的子集，它并不能表示 JavaScript 里的所有值。支持对象、数组、字符串、无穷大数字、true、false 和 null，并且它们可以序列化和还原。NaN、Infinity 和 -Infinity 序列化的结果是 null，日期对象序列化的结果是 ISO 格式的日期字符串（参照 Date.toJSON() 函数），但 JSON.parse() 依然保留它们的字符串形态，而不会将它们还原为原始日期对象。函数、RegExp、Error 对象和 undefined 值不能序列化和还原。JSON.stringify() 只能序列化对象可枚举的自有属性。对于一个不能序列化的属性来说，在序列化后的输出字符串中会将这个属性省略掉。JSON.stringify() 和 JSON.parse() 都可以接收第二个可选实参，通过传入需要序列化或还原的属性列表来定制自定义的序列化或还原操作。§11.6 有关于这些函数的详细文档。 ","date":"2020-11-02","objectID":"/posts/ch6/:8:0","tags":null,"title":"第 6 章 对象","uri":"/posts/ch6/"},{"categories":null,"content":"6.9 Object Methods As discussed earlier, all JavaScript objects (except those explicitly created without a prototype) inherit properties from Object.prototype. These inherited properties are primarily methods, and because they are universally available, they are of particular interest to JavaScript programmers. We’ve already seen the hasOwnProperty() and propertyIsEnumerable() methods, for example. (And we’ve also already covered quite a few static functions defined on the Object constructor, such as Object.create() and Object.keys().) This section explains a handful of universal object methods that are defined on Object.prototype, but which are intended to be replaced by other, more specialized implementations. In the sections that follow, we show examples of defining these methods on a single object. In Chapter 9, you’ll learn how to define these methods more generally for an entire class of objects. 上文已经讨论过，所有的 JavaScript 对象都从 Object.prototype 继承属性（除了那些不通过原型显式创建的对象）。这些继承属性主要是方法，因为 JavaScript 程序员普遍对继承方法更感兴趣。例如我们已经见过的 hasOwnProperty() 和 propertyIsEnumerable() 方法。（并且我们也已经提到了一小部分定义在对象构造函数中的静态函数，像 Object.create() 和 Object.keys()。）本节介绍在 Object.prototype 上定义的少数通用对象方法，但是这些方法经常会被更专业的实现所取代。在下面的各节中，我们将展示在单个对象上定义这些方法的示例。在第 9 章中，将学习如何更常规化地为整个对象类定义这些方法。 ","date":"2020-11-02","objectID":"/posts/ch6/:9:0","tags":null,"title":"第 6 章 对象","uri":"/posts/ch6/"},{"categories":null,"content":"6.9.1 The toString() Method The toString() method takes no arguments; it returns a string that somehow represents the value of the object on which it is invoked. JavaScript invokes this method of an object whenever it needs to convert the object to a string. This occurs, for example, when you use the + operator to concatenate a string with an object or when you pass an object to a method that expects a string. toString() 方法没有实参，它将返回一个表示调用这个方法的对象值的字符串。在需要将对象转换为字符串的时候，JavaScript 都会调用这个方法。比如，当使用 + 运算符连接一个字符串和一个对象时或者在希望使用字符串的方法中使用了对象时都会调用 toString()。 The default toString() method is not very informative (though it is useful for determining the class of an object, as we will see in §14.4.3). For example, the following line of code simply evaluates to the string “[object Object]”: 默认的 toString() 方法的返回值带有的信息量很少（尽管它在检测对象的类型时非常有用，参照 §14.4.3），例如，下面这行代码的计算结果为字符串”[object Object]”： let s = { x: 1, y: 1 }.toString(); // s == \"[object Object]\" Because this default method does not display much useful information, many classes define their own versions of toString(). For example, when an array is converted to a string, you obtain a list of the array elements, themselves each converted to a string, and when a function is converted to a string, you obtain the source code for the function. You might define your own toString() method like this: 由于默认的 toString() 方法并不会输出很多有用的信息，因此很多类都带有自定义的 toString()。例如，当数组转换为字符串的时候，结果是一个数组元素列表，只是每个元素都转换成了字符串，再比如，当函数转换为字符串的时候，得到函数的源代码。可以像下面这样自定义 toString() 方法： let point = { x: 1, y: 2, toString: function() { return `(${this.x}, ${this.y})`; } }; String(point) // =\u003e \"(1, 2)\": toString() is used for string conversions ","date":"2020-11-02","objectID":"/posts/ch6/:9:1","tags":null,"title":"第 6 章 对象","uri":"/posts/ch6/"},{"categories":null,"content":"6.9.2 The toLocaleString() Method In addition to the basic toString() method, objects all have a toLocaleString(). The purpose of this method is to return a localized string representation of the object. The default toLocaleString() method defined by Object doesn’t do any localization itself: it simply calls toString() and returns that value. The Date and Number classes define customized versions of toLocaleString() that attempt to format numbers, dates, and times according to local conventions. Array defines a toLocaleString() method that works like toString() except that it formats array elements by calling their toLocaleString() methods instead of their toString() methods. You might do the same thing with a point object like this: 除了基本的 toString() 方法之外，对象都包含 toLocaleString() 方法，这个方法返回一个表示这个对象的本地化字符串。Object 中默认的 toLocaleString() 方法并不做任何本地化自身的操作，它仅调用 toString() 方法并返回对应值。Date 和 Number 类对 toLocaleString() 方法做了定制，可以用它对数字、日期和时间做本地化的转换。 Array 类的 toLocaleString() 方法和 toString() 方法很像，唯一的不同是每个数组元素会调用 toLocaleString() 方法转换为字符串，而不是调用各自的 toString() 方法。可以像这样使用 point 对象做到同样的效果： let point = { x: 1000, y: 2000, toString: function() { return `(${this.x}, ${this.y})`; }, toLocaleString: function() { return `(${this.x.toLocaleString()}, ${this.y.toLocaleString()})`; } }; point.toString() // =\u003e \"(1000, 2000)\" point.toLocaleString() // =\u003e \"(1,000, 2,000)\": note thousands separators The internationalization classes documented in §11.7 can be useful when implementing a toLocaleString() method. 在 §11.7 的国际化类中，toLocaleString() 方法的实现是非常有用的。 ","date":"2020-11-02","objectID":"/posts/ch6/:9:2","tags":null,"title":"第 6 章 对象","uri":"/posts/ch6/"},{"categories":null,"content":"6.9.3 The valueOf() Method The valueOf() method is much like the toString() method, but it is called when JavaScript needs to convert an object to some primitive type other than a string—typically, a number. JavaScript calls this method automatically if an object is used in a context where a primitive value is required. The default valueOf() method does nothing interesting, but some of the built-in classes define their own valueOf() method. The Date class defines valueOf() to convert dates to numbers, and this allows Date objects to be chronologically compared with \u003c and \u003e. You could do something similar with a point object, defining a valueOf() method that returns the distance from the origin to the point: valueOf() 方法和 toString() 方法非常类似，但往往当 JavaScript 需要将对象转换为某种原始值而非字符串的时候才会调用它，尤其是转换为数字的时候。如果在需要使用原始值的上下文中使用了对象，JavaScript 就会自动调用这个方法。默认的 valueOf() 方法不足为奇，但有些内置类自定义了 valueOf() 方法. Date 类定义 valueOf() 将日期转化成数值型，并且这允许 Date 对象使用 \u003c 和 \u003e 按时间先手顺序比较。可以对 point 对象做同样的事，定义一个 valueOf() 方法返回原点到点的距离： let point = { x: 3, y: 4, valueOf: function() { return Math.hypot(this.x, this.y); } }; Number(point) // =\u003e 5: valueOf() is used for conversions to numbers point \u003e 4 // =\u003e true point \u003e 5 // =\u003e false point \u003c 6 // =\u003e true ","date":"2020-11-02","objectID":"/posts/ch6/:9:3","tags":null,"title":"第 6 章 对象","uri":"/posts/ch6/"},{"categories":null,"content":"6.9.4 The toJSON() Method Object.prototype does not actually define a toJSON() method, but the JSON.stringify() method (see §6.8) looks for a toJSON() method on any object it is asked to serialize. If this method exists on the object to be serialized, it is invoked, and the return value is serialized, instead of the original object. The Date class (§11.4) defines a toJSON() method that returns a serializable string representation of the date. We could do the same for our Point object like this: Object.prototype 实际上没有定义 toJSON() 方法，但对于需要执行序列化的对象来说，JSON.stringify() 方法（见 §6.8）会调用 toJSON() 方法。如果在待序列化的对象中存在这 个方法，则调用它，返回值即是序列化的结果，而不是原始的对象。Date 类（§11.4）定义了 toJSON() 方法返回日期的序列化字符串。我们可以这样对 point 对象做同样的事： let point = { x: 1, y: 2, toString: function() { return `(${this.x}, ${this.y})`; }, toJSON: function() { return this.toString(); } }; JSON.stringify([point]) // =\u003e '[\"(1, 2)\"]' ","date":"2020-11-02","objectID":"/posts/ch6/:9:4","tags":null,"title":"第 6 章 对象","uri":"/posts/ch6/"},{"categories":null,"content":"6.10 Extended Object Literal Syntax Recent versions of JavaScript have extended the syntax for object literals in a number of useful ways. The following subsections explain these extensions. JavaScript 的最新版本扩展了许多有用的对象字面量相关的语法。以下小节解释这些扩展。 ","date":"2020-11-02","objectID":"/posts/ch6/:10:0","tags":null,"title":"第 6 章 对象","uri":"/posts/ch6/"},{"categories":null,"content":"6.10.1 Shorthand Properties Suppose you have values stored in variables x and y and want to create an object with properties named x and y that hold those values. With basic object literal syntax, you’d end up repeating each identifier twice: 假设值存储在变量 x 和 y 中，并且想要创建具有名为 x 和 y 的属性的对象，这些属性包含这些值。使用基本对象字面量语法，最终会重复每个标识符两次： let x = 1, y = 2; let o = { x: x, y: y }; In ES6 and later, you can drop the colon and one copy of the identifier and end up with much simpler code: 在 ES6 之后，可以删除标识符的冒号和一个副本，最终使用更简单的代码： let x = 1, y = 2; let o = { x, y }; o.x + o.y // =\u003e 3 ","date":"2020-11-02","objectID":"/posts/ch6/:10:1","tags":null,"title":"第 6 章 对象","uri":"/posts/ch6/"},{"categories":null,"content":"6.10.2 Computed Property Names Sometimes you need to create an object with a specific property, but the name of that property is not a compile-time constant that you can type literally in your source code. Instead, the property name you need is stored in a variable or is the return value of a function that you invoke. You can’t use a basic object literal for this kind of property. Instead, you have to create an object and then add the desired properties as an extra step: 有时需要创建具有特定属性的对象，但该属性的名称不是可以在源代码中键入的编译时常量。相反，需要的属性名称存储在变量中，或者是调用的函数的返回值。不能对此类属性使用基本对象字面量。而必须创建一个对象，通过额外的步骤，添加所需的属性： const PROPERTY_NAME = \"p1\"; function computePropertyName() { return \"p\" + 2; } let o = {}; o[PROPERTY_NAME] = 1; o[computePropertyName()] = 2; It is much simpler to set up an object like this with an ES6 feature known as computed properties that lets you take the square brackets from the preceding code and move them directly into the object literal: 使用称为计算属性的 ES6 特性设置这样的对象要简单得多，该功能允许从前面的代码写入方括内并直接移动到对象字面量中： const PROPERTY_NAME = \"p1\"; function computePropertyName() { return \"p\" + 2; } let p = { [PROPERTY_NAME]: 1, [computePropertyName()]: 2 }; p.p1 + p.p2 // =\u003e 3 With this new syntax, the square brackets delimit an arbitrary JavaScript expression. That expression is evaluated, and the resulting value (converted to a string, if necessary) is used as the property name. 使用这种新语法，方括号将其分隔成 JavaScript 表达式。计算该表达式，并将结果值（如有必要转换为字符串）用作属性名称。 One situation where you might want to use computed properties is when you have a library of JavaScript code that expects to be passed objects with a particular set of properties, and the names of those properties are defined as constants in that library. If you are writing code to create the objects that will be passed to that library, you could hardcode the property names, but you’d risk bugs if you type the property name wrong anywhere, and you’d risk version mismatch issues if a new version of the library changes the required property names. Instead, you might find that it makes your code more robust to use computed property syntax with the property name constants defined by the library. 可能想要使用计算属性的一个情况是，有一个 JavaScript 代码库，该库希望传递具有一组特定属性的对象，并且这些属性的名称定义为该库中的常量。如果要编写代码以创建将传递给该库的对象，可以硬编码属性名称，但如果在任何地方键入错误的属性名称，则存在错误风险；如果库的新版本更改了所需的属性名称，则存在版本不匹配问题的风险。相反，可能会发现，使用计算属性语法与库定义的属性名称常量时，它使代码更加健壮。 ","date":"2020-11-02","objectID":"/posts/ch6/:10:2","tags":null,"title":"第 6 章 对象","uri":"/posts/ch6/"},{"categories":null,"content":"6.10.3 Symbols as Property Names The computed property syntax enables one other very important object literal feature. In ES6 and later, property names can be strings or symbols. If you assign a symbol to a variable or constant, then you can use that symbol as a property name using the computed property syntax: 计算属性语法启用了另一个非常重要的对象字面量特性。在 ES6 之后，属性名称可以是字符串或 Symbol。如果将 Symbol 分配给变量或常量，则可以使用计算属性语法将该 Symbol 用作属性名称： const extension = Symbol(\"my extension symbol\"); let o = { [extension]: { /* extension data stored in this object */ } }; o[extension].x = 0; // This won't conflict with other properties of o As explained in §3.6, Symbols are opaque values. You can’t do anything with them other than use them as property names. Every Symbol is different from every other Symbol, however, which means that Symbols are good for creating unique property names. Create a new Symbol by calling the Symbol() factory function. (Symbols are primitive values, not objects, so Symbol() is not a constructor function that you invoke with new.) The value returned by Symbol() is not equal to any other Symbol or other value. You can pass a string to Symbol(), and this string is used when your Symbol is converted to a string. But this is a debugging aid only: two Symbols created with the same string argument are still different from one another. 如 §3.6 中所述，符号是不透明值。除了将它们用作属性名称，不能对它们进行任何其他处理。但是，每个 Symbol 都不同于所有其他 Symbol，这意味着 Symbol 适合创建唯一的属性名称。通过调用 Symbol() 工厂函数创建新 Symbol。（Symbol 是原始值，而不是对象，因此 Symbol() 不是使用 new 调用的构造函数。）Symbol() 返回的值不等于任何其他 Symbol 或其他值。可以将字符串传递给 Symbol()，当 Symbol 转换为字符串时，将使用此字符串。但是，这只是一个调试帮助：使用同一字符串参数创建的两个 Symbol 仍然彼此不同。 The point of Symbols is not security, but to define a safe extension mechanism for JavaScript objects. If you get an object from third-party code that you do not control and need to add some of your own properties to that object but want to be sure that your properties will not conflict with any properties that may already exist on the object, you can safely use Symbols as your property names. If you do this, you can also be confident that the third-party code will not accidentally alter your symbolically named properties. (That third-party code could, of course, use Object.getOwnPropertySymbols() to discover the Symbols you’re using and could then alter or delete your properties. This is why Symbols are not a security mechanism.) Symbol 的要点不是安全性，而是为 JavaScript 对象定义一个安全的扩展机制。如果从第三方代码获取对象，您无法控制该对象，并且需要向该对象添加自己的一些属性，但希望确保属性不会与对象上可能存在的任何属性冲突，可以安全地使用 Symbol 作为属性名称。如果这样做，还可以确信第三方代码不会意外更改 Symbol 命名的属性。（当然，该第三方代码可以使用 Object.getOwnPropertySymbols() 来发现你使用的 Symbol，然后可以更改或删除你的属性。这就是为什么符号不是安全机制。） ","date":"2020-11-02","objectID":"/posts/ch6/:10:3","tags":null,"title":"第 6 章 对象","uri":"/posts/ch6/"},{"categories":null,"content":"6.10.4 Spread Operator In ES2018 and later, you can copy the properties of an existing object into a new object using the “spread operator” … inside an object literal: 在 ES2018 之后，可以使用展开运算符 … 将现有的对象中的属性复制到新的对象中： let position = { x: 0, y: 0 }; let dimensions = { width: 100, height: 75 }; let rect = { ...position, ...dimensions }; rect.x + rect.y + rect.width + rect.height // =\u003e 175 In this code, the properties of the position and dimensions objects are “spread out” into the rect object literal as if they had been written literally inside those curly braces. Note that this … syntax is often called a spread operator but is not a true JavaScript operator in any sense. Instead, it is a special-case syntax available only within object literals. (Three dots are used for other purposes in other JavaScript contexts, but object literals are the only context where the three dots cause this kind of interpolation of one object into another one.) 在此代码中，position 和 dimensions 对象的属性被展开到 rect 对象字面量中，就像它们以字面量的方式写入这些大括号中一样。请注意，… 语法通常称为展开运算符，但在任何情况下都不是真正的 JavaScript 运算符。相反，它是一种特殊情况下语法，仅在对象文本中可用。（… 在别的 JavaScript 上下文中有其他用途，但是对象字面量上下文中只有这一种用法。） If the object that is spread and the object it is being spread into both have a property with the same name, then the value of that property will be the one that comes last: 如果展开的目标对象和源对象中具有相同的名称，则该属性的值将是位置处于后面的值： let o = { x: 1 }; let p = { x: 0, ...o }; p.x // =\u003e 1: the value from object o overrides the initial value let q = { ...o, x: 2 }; q.x // =\u003e 2: the value 2 overrides the previous value from o. Also note that the spread operator only spreads the own properties of an object, not any inherited ones: 还有注意展开运算符只展开对象的自有属性，不展开继承属性： let o = Object.create({x: 1}); // o inherits the property x let p = { ...o }; p.x // =\u003e undefined Finally, it is worth noting that, although the spread operator is just three little dots in your code, it can represent a substantial amount of work to the JavaScript interpreter. If an object has n properties, the process of spreading those properties into another object is likely to be an O(n) operation. This means that if you find yourself using … within a loop or recursive function as a way to accumulate data into one large object, you may be writing an inefficient O(n2) algorithm that will not scale well as n gets larger. 最后，值得注意的是，虽然展开运算符在代码中只是三个小点，但它对 JavaScript 解释器来说可以代表大量的工作。如果对象具有 n 个属性，则将这些属性分散到另一个对象的过程很可能是 O(n) 操作。这意味着，如果你发现自己在使用 … 在循环或递归函数中，类似将数据累积到一个大对象中的方法，您可能正在编写一个低效的 O(n2) 算法，该算法不会随着 n 变大而扩展。 ","date":"2020-11-02","objectID":"/posts/ch6/:10:4","tags":null,"title":"第 6 章 对象","uri":"/posts/ch6/"},{"categories":null,"content":"6.10.5 Shorthand Methods When a function is defined as a property of an object, we call that function a method (we’ll have a lot more to say about methods in Chapters 8 and 9). Prior to ES6, you would define a method in an object literal using a function definition expression just as you would define any other property of an object: 当函数被定义为对象的属性时，我们称该函数为方法（我们将在第 8 章和第 9 章中对方法有更多的描述）。在 ES6 之前，在对象字面量中用函数定义表达式定义一个方法和在对象中定义其他属性一样： let square = { area: function() { return this.side * this.side; }, side: 10 }; square.area() // =\u003e 100 In ES6, however, the object literal syntax (and also the class definition syntax we’ll see in Chapter 9) has been extended to allow a shortcut where the function keyword and the colon are omitted, resulting in code like this: 但是，在 ES6 中，对象字面量语法（以及我们将在第 9 章中看到的类定义语法）已扩展成允许省略函数关键字和冒号的快捷方式，可以写成这样的代码： let square = { area() { return this.side * this.side; }, side: 10 }; square.area() // =\u003e 100 Both forms of the code are equivalent: both add a property named area to the object literal, and both set the value of that property to the specified function. The shorthand syntax makes it clearer that area() is a method and not a data property like side. 两种形式是相同的：在对象字面量中添加一个名为 area 的属性，并指定一个函数为这个属性的值。速记语法更清晰的看出 area() 是一个方法而不是一个像 side 一样的数据属性。 When you write a method using this shorthand syntax, the property name can take any of the forms that are legal in an object literal: in addition to a regular JavaScript identifier like the name area above, you can also use string literals and computed property names, which can include Symbol property names: 使用此速记语法编写方法时，属性名称可以采用对象字面量中的任何合法形式：除了像上面的名称 area 这样的常规 JavaScript 标识符外，还可以使用字符串字面量和计算属性名称，包括 Symbol 属性名称： const METHOD_NAME = \"m\"; const symbol = Symbol(); let weirdMethods = { \"method With Spaces\"(x) { return x + 1; }, [METHOD_NAME](x) { return x + 2; }, [symbol](x) { return x + 3; } }; weirdMethods[\"method With Spaces\"](1) // =\u003e 2 weirdMethods[METHOD_NAME](1) // =\u003e 3 weirdMethods[symbol](1) // =\u003e 4 Using a Symbol as a method name is not as strange as it seems. In order to make an object iterable (so it can be used with a for/of loop), you must define a method with the symbolic name Symbol.iterator, and there are examples of doing exactly that in Chapter 12. 使用 Symbol 作为方法名称并不像看起来那么奇怪。为了使对象可迭代（因此它可以与 for/of 循环一起使用），必须定义一个具有符号名称 Symbol.iterator 的方法，并且在第 12 章中有这样做的示例。 ","date":"2020-11-02","objectID":"/posts/ch6/:10:5","tags":null,"title":"第 6 章 对象","uri":"/posts/ch6/"},{"categories":null,"content":"6.10.6 Property Getters and Setters All of the object properties we’ve discussed so far in this chapter have been data properties with a name and an ordinary value. JavaScript also supports accessor properties, which do not have a single value but instead have one or two accessor methods: a getter and/or a setter. 到目前为止，本节我们所讨论的所有的对象都是具有名称和普通值的数据属性。JavaScript 还支持存取器属性，这些属性没有单个值，而是具有一个或两个存取器方法：getter 和或是或 setter。 When a program queries the value of an accessor property, JavaScript invokes the getter method (passing no arguments). The return value of this method becomes the value of the property access expression. When a program sets the value of an accessor property, JavaScript invokes the setter method, passing the value of the righthand side of the assignment. This method is responsible for “setting,” in some sense, the property value. The return value of the setter method is ignored. 当程序查询存取器属性的值时，JavaScript 调用 getter 方法（无实参）。这个方法的返回值就是属性存取表达式的值。当程序设置一个存取器属性的值时， JavaScript 调用 setter 方法，将赋值表达式右侧的值当做参数传入 setter。从某种意义上讲，这个方法负责“设置”属性值。可以忽略 setter 方法的返回值。 If a property has both a getter and a setter method, it is a read/write property. If it has only a getter method, it is a read-only property. And if it has only a setter method, it is a write-only property (something that is not possible with data properties), and attempts to read it always evaluate to undefined. 如果属性同时有 getter 和 setter 方法，则它是一个可读写属性。如果它只含有 getter 方法，它是一个只读属性。如果它只有 setter 方法，它是一个只可写属性（这对一个数据属性来说是不可能的），如果尝试去读它，计算结果永远是 undefined。 Accessor properties can be defined with an extension to the object literal syntax (unlike the other ES6 extensions we’ve seen here, getters and setters were introduced in ES5): 存储器属性可以通过表达式在对象字面量语法中定义（不像我们在这里看到的其他 ES6 扩展，getter 和 setter 是 ES5 中的内容）： let o = { // An ordinary data property dataProp: value, // An accessor property defined as a pair of functions. get accessorProp() { return this.dataProp; }, set accessorProp(value) { this.dataProp = value; } }; Accessor properties are defined as one or two methods whose name is the same as the property name. These look like ordinary methods defined using the ES6 shorthand except that getter and setter definitions are prefixed with get or set. (In ES6, you can also use computed property names when defining getters and setters. Simply replace the property name after get or set with an expression in square brackets.) 存储器属性定义为名称与属性名称相同的一个或两个方法。这些方法看起来像使用 ES6 速记定义的普通方法，只不过 getter 和 setter 定义使用 get 或 set 前缀。（在 ES6 中，在定义 getter 和 setter 时还可以使用计算属性名称。只需将带方括号的表达式替换属性名称即可。 The accessor methods defined above simply get and set the value of a data property, and there is no reason to prefer the accessor property over the data property. But as a more interesting example, consider the following object that represents a 2D Cartesian point. It has ordinary data properties to represent the x and y coordinates of the point, and it has accessor properties that give the equivalent polar coordinates of the point: 上面定义的存储器方法只需获取并设置数据属性的值，没有理由将存储器属性替换数据属性。但作为一个更有趣的示例，请考虑以下表示 2D 笛卡尔点的对象。它具有表示点的 x 和 y 坐标的普通数据属性，并且具有提供点等效极坐标的存储器属性： let p = { // x and y are regular read-write data properties. x: 1.0, y: 1.0, // r is a read-write accessor property with getter and setter. // Don't forget to put a comma after accessor methods. get r() { return Math.hypot(this.x, this.y); }, set r(newvalue) { let oldvalue = Math.hypot(this.x, this.y); let ratio = newvalue/oldvalue; this.x *= ratio; this.y *= ratio; }, // theta is a read-only accessor property with getter only. get theta() { return Math.atan2(this.y, this.x); } }; p.r // =\u003e Math.SQRT2 p.theta // =\u003e Math.PI / 4 Note the use of the keyword this in the getters and setter in this example. JavaScript invokes these functions as methods of the object on which they are defined, which means that within the body of the function, this refers to the point object p. So the getter method for the r property can refer to the x and y properties as this.x and this.y. Methods and the this keyw","date":"2020-11-02","objectID":"/posts/ch6/:10:6","tags":null,"title":"第 6 章 对象","uri":"/posts/ch6/"},{"categories":null,"content":"6.11 Summary This chapter has documented JavaScript objects in great detail, covering topics that include: Basic object terminology, including the meaning of terms like enumerable and own property. Object literal syntax, including the many new features in ES6 and later. How to read, write, delete, enumerate, and check for the presence of the properties of an object. How prototype-based inheritance works in JavaScript and how to create an object that inherits from another object with Object.create(). How to copy properties from one object into another with Object.assign(). All JavaScript values that are not primitive values are objects. This includes both arrays and functions, which are the topics of the next two chapters. 本章非常详细地记录了 JavaScript 对象，涵盖的主题包括： 基本对象术语，包括可枚举和自有属性等术语的含义。 对象字面量语法，包括 ES6 及以后的许多新特性。 如何读取、写入、删除、枚举和检查对象属性是否存在。 基于原型的继承是如何在 JavaScript 中工作，以及如何使用 Object.create() 创建一个从另一个对象继承的对象。 如何使用 Object.assign() 将属性从一个对象复制到另一个对象。 所有 JavaScript 的非原始值都是对象。这包括数组和函数，这是接下来两章的主题。 Remember; almost all objects have a prototype but most do not have a property named prototype. JavaScript inheritance works even if you can’t access the prototype object directly. But see §14.3 if you want to learn how to do that. 记住，几乎所有对象都有一个原型，但大多数对象没有名为 prototype 的属性。即使不能直接访问原型对象，JavaScript 继承依然工作。但是，如果你想学习如何做到这一点，请参阅 §14.3。 ","date":"2020-11-02","objectID":"/posts/ch6/:11:0","tags":null,"title":"第 6 章 对象","uri":"/posts/ch6/"},{"categories":null,"content":"This chapter documents arrays, a fundamental datatype in JavaScript and in most other programming languages. An array is an ordered collection of values. Each value is called an element, and each element has a numeric position in the array, known as its index. JavaScript arrays are untyped: an array element may be of any type, and different elements of the same array may be of different types. Array elements may even be objects or other arrays, which allows you to create complex data structures, such as arrays of objects and arrays of arrays. JavaScript arrays are zero-based and use 32-bit indexes: the index of the first element is 0, and the highest possible index is 4294967294 (232−2), for a maximum array size of 4,294,967,295 elements. JavaScript arrays are dynamic: they grow or shrink as needed, and there is no need to declare a fixed size for the array when you create it or to reallocate it when the size changes. JavaScript arrays may be sparse: the elements need not have contiguous indexes, and there may be gaps. Every JavaScript array has a length property. For nonsparse arrays, this property specifies the number of elements in the array. For sparse arrays, length is larger than the highest index of any element. 本章记录了数组、一个在 JavaScript 和大多数其他编程语言中的基本数据类型。数组是值的有序集合。每个值叫做一个元素，而每个元素在数组中有一个位置，以数字表示，称为索引。JavaScript 数组是无类型的：数组元素可以是任意类型，并且同一个数组中的不同元素也可能有不同的类型。数组的元素甚至也可能是对象或其他数组，这允许创建复杂的数据结构，如对象的数组和数组的数组。JavaScript 数组的索引是基于零的 32 位数值：第一个元素的索引为 0，最大可能的索引为 4,294,967,294（232-2），数组最大能容纳 4,294,967,295 个元素。JavaScript 数组是动态的：根据需要它们会增长或缩减，并且在创建数组时无须声明一个固定的大小或者在数组大小变化时无须重新分配空间。JavaScript 数组可能是稀疏的：数组元素的索引不一定要连续的，它们之间可以有空缺。每个 JavaScript 数组都有一个 length 属性。针对非稀疏数组，该属性就是数组元素的个数。针对稀疏数组，length 大于任何元素的最高索引。 JavaScript arrays are a specialized form of JavaScript object, and array indexes are really little more than property names that happen to be integers. We’ll talk more about the specializations of arrays elsewhere in this chapter. Implementations typically optimize arrays so that access to numerically indexed array elements is generally significantly faster than access to regular object properties. JavaScript 数组是 JavaScript 对象的特殊形式，数组索引实际上和碰巧是整数的属性名差不多。我们将在本章的其他地方更多地讨论特殊化的数组。通常，数组的实现是经过优化的，用数字索引来访问数组元素一般来说比访问常规的对象属性要快很多。 Arrays inherit properties from Array.prototype, which defines a rich set of array manipulation methods, covered in §7.8. Most of these methods are generic, which means that they work correctly not only for true arrays, but for any “array-like object.” We’ll discuss array-like objects in §7.9. Finally, JavaScript strings behave like arrays of characters, and we’ll discuss this in §7.10. 数组继承自 Array.prototype 中的属性，它定义了一套丰富的数组操作方法，§7.8 涵盖这方面内容。大多数这些方法是通用的，这意味着它们不仅对真正的数组有效，而且对“类数组对象”同样有效。§7.9 讨论类数组对象。最后，JavaScript 字符串的行为与字符数组类似，我们将在 §7.10 讨论。 ES6 introduces a set of new array classes known collectively as “typed arrays.” Unlike regular JavaScript arrays, typed arrays have a fixed length and a fixed numeric element type. They offer high performance and byte-level access to binary data and are covered in §11.2. ES6 引入了一组新的数组类，这些类统称为“类型化数组”。与常规的 JavaScript 数组不同，类型化数组有固定的长度和固定的数值元素类型。它们提供高性能和对二进制数据的字节级访问，在 §11.2 中有介绍。 ","date":"2020-11-02","objectID":"/posts/ch7/:0:0","tags":null,"title":"第 7 章 数组","uri":"/posts/ch7/"},{"categories":null,"content":"7.1 Creating Arrays There are several ways to create arrays. The subsections that follow explain how to create arrays with: 有很多种创建数组的方法。以下小节将说明如何使用以下方式创建数组： Array literals 数组字面量 The … spread operator on an iterable object 可迭代数组 … 展开运算符 The Array() constructor Array() 构造函数 The Array.of() and Array.from() factory methods Array.of() 和 Array.from() 工厂方法 ","date":"2020-11-02","objectID":"/posts/ch7/:1:0","tags":null,"title":"第 7 章 数组","uri":"/posts/ch7/"},{"categories":null,"content":"7.1.1 Array Literals By far the simplest way to create an array is with an array literal, which is simply a comma-separated list of array elements within square brackets. For example: 到目前为止使用数组字面量是创建数组最简单的方法，在方括号中将数组元素用逗号隔开即可。例如： let empty = []; // An array with no elements let primes = [2, 3, 5, 7, 11]; // An array with 5 numeric elements let misc = [ 1.1, true, \"a\", ]; // 3 elements of various types + trailing comma The values in an array literal need not be constants; they may be arbitrary expressions: 数组字面量中的值不一定要是常量；它们可以是任意的表达式： let base = 1024; let table = [base, base+1, base+2, base+3]; Array literals can contain object literals or other array literals: 数组字面量可以包含对象字面量或其他数组字面量： let b = [[1, {x: 1, y: 2}], [2, {x: 3, y: 4}]]; If an array literal contains multiple commas in a row, with no value between, the array is sparse (see §7.3). Array elements for which values are omitted do not exist but appear to be undefined if you query them: 如果数组字面量在一行中包含多个逗号，之间没有值，则数组是稀疏的（请参阅 §7.3）。省略值的数组元素不存在，但如果查询它们则返回 undefined： let count = [1,,3]; // Elements at indexes 0 and 2. No element at index 1 let undefs = [,,]; // An array with no elements but a length of 2 Array literal syntax allows an optional trailing comma, so [,,] has a length of 2, not 3. 数组字面量语法允许可选的尾部逗号，所以 [,,] 的长度是 2，不是3。 ","date":"2020-11-02","objectID":"/posts/ch7/:1:1","tags":null,"title":"第 7 章 数组","uri":"/posts/ch7/"},{"categories":null,"content":"7.1.2 The Spread Operator In ES6 and later, you can use the “spread operator,” …, to include the elements of one array within an array literal: ES6 之后，可以使用展开操作符 … 将一个数组中的元素展开在数组字面量中： let a = [1, 2, 3]; let b = [0, ...a, 4]; // b == [0, 1, 2, 3, 4] The three dots “spread” the array a so that its elements become elements within the array literal that is being created. It is as if the …a was replaced by the elements of the array a, listed literally as part of the enclosing array literal. (Note that, although we call these three dots a spread operator, this is not a true operator because it can only be used in array literals and, as we’ll see later in the book, function invocations.) 三个点展开数组 a，所以它的元素变成了数组字面量，并被创建在数组中。就像 …a 被数组 a 的元素所替换，被列出作为未闭合的数组字面量的一部分。（注意，尽管我们称三点是展开运算符，但这并不是一个操作，因为它只能用于数组字面量和本书后面提到的函数调用。） The spread operator is a convenient way to create a (shallow) copy of an array: 展开运算符可以方便的创建一个数组的拷贝（浅拷贝）： let original = [1,2,3]; let copy = [...original]; copy[0] = 0; // Modifying the copy does not change the original original[0] // =\u003e 1 The spread operator works on any iterable object. (Iterable objects are what the for/of loop iterates over; we first saw them in §5.4.4, and we’ll see much more about them in Chapter 12.) Strings are iterable, so you can use a spread operator to turn any string into an array of single-character strings: 展开运算符可以作用于任何可迭代对象。（可迭代对象是可以用 for/of 进行循环的对象；第一次在 §5.4.4 中提到，在第 12 章会看到更多关于它们的描述。）字符串是可迭代对象，所以可以使用展开操作符将字符串转换成单个字符的数组。 let digits = [...\"0123456789ABCDEF\"]; digits // =\u003e [\"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"A\",\"B\",\"C\",\"D\",\"E\",\"F\"] Set objects (§11.1.1) are iterable, so an easy way to remove duplicate elements from an array is to convert the array to a set and then immediately convert the set back to an array using the spread operator: Set 对象（§11.1.1）是可迭代对象，所以数组去重有一种简单的方法是用展开运算符将数组转换成 set 然后再转成数组： let letters = [...\"hello world\"]; [...new Set(letters)] // =\u003e [\"h\",\"e\",\"l\",\"o\",\" \",\"w\",\"r\",\"d\"] ","date":"2020-11-02","objectID":"/posts/ch7/:1:2","tags":null,"title":"第 7 章 数组","uri":"/posts/ch7/"},{"categories":null,"content":"7.1.3 The Array() Constructor Another way to create an array is with the Array() constructor. You can invoke this constructor in three distinct ways: 另一种创建数组的方法是使用 Array() 构造函数。可以用三种不同的方式调用这个构造函数： Call it with no arguments: 调用时没有实参： let a = new Array(); This method creates an empty array with no elements and is equivalent to the array literal []. 这个方法创建了一个没有元素的空数组，它等价于 [] 数组字面量。 Call it with a single numeric argument, which specifies a length: 调用时有一个数值实参，它指定了数组的长度： let a = new Array(10); This technique creates an array with the specified length. This form of the Array() constructor can be used to preallocate an array when you know in advance how many elements will be required. Note that no values are stored in the array, and the array index properties “0”, “1”, and so on are not even defined for the array. 该技术创建指定长度的数组。当预先知道所需元素个数时，这种形式的 Array() 构造函数可以用来预分配一个数组空间。注意，数组中没有存储值，甚至数组的索引属性“0”、“1”等还未定义。 Explicitly specify two or more array elements or a single non-numeric element for the array: 为数组显式指定两个或多个数组元素或者非数值元素： let a = new Array(5, 4, 3, 2, 1, \"testing, testing\"); In this form, the constructor arguments become the elements of the new array. Using an array literal is almost always simpler than this usage of the Array() constructor. 以这种形式，构造函数的实参将会成为新数组的元素。使用数组字面量比这样使用 Array() 构造函数要简单多了。 ","date":"2020-11-02","objectID":"/posts/ch7/:1:3","tags":null,"title":"第 7 章 数组","uri":"/posts/ch7/"},{"categories":null,"content":"7.1.4 Array.of() When the Array() constructor function is invoked with one numeric argument, it uses that argument as an array length. But when invoked with more than one numeric argument, it treats those arguments as elements for the array to be created. This means that the Array() constructor cannot be used to create an array with a single numeric element. 当 Array() 构造函数调用时有一个数值型实参，它会将实参作为数组的长度。但当调用时不止一个数值型实参时，它会将那些实参作为数组的元素创建。这意味着 Array() 构造函数不能创建只有一个数值型元素的数组。 In ES6, the Array.of() function addresses this problem: it is a factory method that creates and returns a new array, using its argument values (regardless of how many of them there are) as the array elements: 在 ES6 中，Array.of() 函数修复了这个问题：它是一个将其实参值（无论有多少个实参）作为数组元素创建并返回一个新数组的工厂方法： Array.of() // =\u003e []; returns empty array with no arguments Array.of(10) // =\u003e [10]; can create arrays with a single numeric argument Array.of(1,2,3) // =\u003e [1, 2, 3] ","date":"2020-11-02","objectID":"/posts/ch7/:1:4","tags":null,"title":"第 7 章 数组","uri":"/posts/ch7/"},{"categories":null,"content":"7.1.5 Array.from() Array.from is another array factory method introduced in ES6. It expects an iterable or array-like object as its first argument and returns a new array that contains the elements of that object. With an iterable argument, Array.from(iterable) works like the spread operator […iterable] does. It is also a simple way to make a copy of an array: Array.from 是 ES6 中另外一个数组工厂方法。它期望一个可迭代或类数组对象作为它的第一个实参，并返回一个包含对象中元素的新数组。使用一个可迭代实参，Array.from(iterable) 工作方式类似于展开运算符 […iterable]。它也可以简单的拷贝一个数组： let copy = Array.from(original); Array.from() is also important because it defines a way to make a true-array copy of an array-like object. Array-like objects are non-array objects that have a numeric length property and have values stored with properties whose names happen to be integers. When working with client-side JavaScript, the return values of some web browser methods are array-like, and it can be easier to work with them if you first convert them to true arrays: Array.from() 也很重要，因为它定义了一个将类数组对象拷贝成数组的方法。类数组对象是一个不是数组的对象，它有一个数值型的 length 属性，并且它的值碰巧保存在属性名为整数的属性中。当使用客户端 JavaScript 时，一些浏览器方法的返回值是类数组的，并且当将其转化成真正的数组后会更容易操作它们： let truearray = Array.from(arraylike); Array.from() also accepts an optional second argument. If you pass a function as the second argument, then as the new array is being built, each element from the source object will be passed to the function you specify, and the return value of the function will be stored in the array instead of the original value. (This is very much like the array map() method that will be introduced later in the chapter, but it is more efficient to perform the mapping while the array is being built than it is to build the array and then map it to another new array.) Array.from() 第二个实参为可选实参。如果传递一个函数作为第二个实参，那么当新数组被创建，每一个元素都会被作为实参传入这个指定函数中，并且这个函数的每个返回值保存在数组中代替原来的值。（这很像后面会介绍的数组 map() 方法，但是，它会更加高效的执行映射，因其为没有创建数组，而是直接进行映射到另外一个数组。） ","date":"2020-11-02","objectID":"/posts/ch7/:1:5","tags":null,"title":"第 7 章 数组","uri":"/posts/ch7/"},{"categories":null,"content":"7.2 Reading and Writing Array Elements You access an element of an array using the [] operator. A reference to the array should appear to the left of the brackets. An arbitrary expression that has a non-negative integer value should be inside the brackets. You can use this syntax to both read and write the value of an element of an array. Thus, the following are all legal JavaScript statements: 使用 [] 运算符来访问数组中的一个元素。数组的引用位于方括号的左边。方括号中是一个返回非负整数值的任意表达式。使用该语法既可以读又可以写数组的一个元素。因此，如下代码都是合法的 JavaScript 语句： let a = [\"world\"]; // Start with a one-element array let value = a[0]; // Read element 0 a[1] = 3.14; // Write element 1 let i = 2; a[i] = 3; // Write element 2 a[i + 1] = \"hello\"; // Write element 3 a[a[i]] = a[0]; // Read elements 0 and 2, write element 3 What is special about arrays is that when you use property names that are non-negative integers less than 232–1, the array automatically maintains the value of the length property for you. In the preceding, for example, we created an array a with a single element. We then assigned values at indexes 1, 2, and 3. The length property of the array changed as we did, so: 数组特殊的是，当使用小于 232–1 的非负整数属性名时，数组会自动维护 length 属性。例如，上文中我们创建了只有一个元素的数组 a。然后我们为其序列为 1、2 和 3 的元素进行赋值。数组 length 属性会自动改变： a.length // =\u003e 4 Remember that arrays are a specialized kind of object. The square brackets used to access array elements work just like the square brackets used to access object properties. JavaScript converts the numeric array index you specify to a string—the index 1 becomes the string “1”—then uses that string as a property name. There is nothing special about the conversion of the index from a number to a string: you can do that with regular objects, too: 请记住，数组是对象的特殊形式。使用方括号访问数组元素就像用方括号访问对象的属性一样。JavaScript 将指定的数字索引值转换成字符串（索引值 1 变成“1”）然后将其作为属性名来使用。关于索引值从数字转换为字符串没什么特别之处：对常规对象也可以这么做： let o = {}; // Create a plain object o[1] = \"one\"; // Index it with an integer o[\"1\"] // =\u003e \"one\"; numeric and string property names are the same It is helpful to clearly distinguish an array index from an object property name. All indexes are property names, but only property names that are integers between 0 and 232–2 are indexes. All arrays are objects, and you can create properties of any name on them. If you use properties that are array indexes, however, arrays have the special behavior of updating their length property as needed. 清晰地区分数组的索引和对象的属性名是非常有用的。所有的索引都是属性名，但只有在 0～232-2 之间的整数属性名才是索引。所有的数组都是对象，可以为其创建任意名字的属性。但如果使用的属性是数组的索引，数组的特殊行为就是将根据需要更新它们的 length 属性值。 Note that you can index an array using numbers that are negative or that are not integers. When you do this, the number is converted to a string, and that string is used as the property name. Since the name is not a non-negative integer, it is treated as a regular object property, not an array index. Also, if you index an array with a string that happens to be a non-negative integer, it behaves as an array index, not an object property. The same is true if you use a floating-point number that is the same as an integer: 注意，可以使用负数或非整数来索引数组。这种情况下，数值转换为字符串，字符串作为属性名来用。既然名字不是非负整数，它就只能当做常规的对象属性，而非数组的索引。同样，如果凑巧使用了是非负整数的字符串，它就当做数组索引，而非对象属性。当使用的一个浮点数和一个整数相等时情况也是一样的： a[-1.23] = true; // This creates a property named \"-1.23\" a[\"1000\"] = 0; // This the 1001st element of the array a[1.000] = 1; // Array index 1. Same as a[1] = 1; The fact that array indexes are simply a special type of object property name means that JavaScript arrays have no notion of an “out of bounds” error. When you try to query a nonexistent property of any object, you don’t get an error; you simply get undefined. This is just as true for arrays as it is for objects: 事实上数组索引仅仅是对象属性名的一种特殊类型，这意味着 JavaScript 数组没有“越界”错误的概念。当试图查询任何对象中不存在的属性时，都不会报错，只会得到 undefined 值。类似于对象，对于对象同样存在这种情况。 let a = [true, false]; // This array has elements at indexes 0 and 1 a[2] // =\u003e undefined; no element at this index. a[-1] // =\u003e undefined; no property with this name. ","date":"2020-11-02","objectID":"/posts/ch7/:2:0","tags":null,"title":"第 7 章 数组","uri":"/posts/ch7/"},{"categories":null,"content":"7.3 Sparse Arrays A sparse array is one in which the elements do not have contiguous indexes starting at 0. Normally, the length property of an array specifies the number of elements in the array. If the array is sparse, the value of the length property is greater than the number of elements. Sparse arrays can be created with the Array() constructor or simply by assigning to an array index larger than the current array length. 稀疏数组就是包含从 0 开始的不连续索引的数组。通常，数组的 length 属性值代表数组中元素的个数。如果数组是稀疏的，length 属性值大于元素的个数。可以用 Array() 构造函数或简单地指定数组的索引值大于当前的数组长度来创建稀疏数组。 let a = new Array(5); // No elements, but a.length is 5. a = []; // Create an array with no elements and length = 0. a[1000] = 0; // Assignment adds one element but sets length to 1001. We’ll see later that you can also make an array sparse with the delete operator. 后面会看到你也可以用 delete 运算符来生产稀疏数组。 Arrays that are sufficiently sparse are typically implemented in a slower, more memory-efficient way than dense arrays are, and looking up elements in such an array will take about as much time as regular object property lookup. 足够稀疏的数组通常在实现上比稠密的数组更慢、内存利用率更高，在这样的数组中查找元素的时间与常规对象属性的查找时间一样长。 Note that when you omit a value in an array literal (using repeated commas as in [1,,3]), the resulting array is sparse, and the omitted elements simply do not exist: 注意，当在数组字面量中省略值时（像 [1,,3] 中使用重复的逗号）返回的是稀疏数组，省略掉的值是不存在的： let a1 = [,]; // This array has no elements and length 1 let a2 = [undefined]; // This array has one undefined element 0 in a1 // =\u003e false: a1 has no element with index 0 0 in a2 // =\u003e true: a2 has the undefined value at index 0 Understanding sparse arrays is an important part of understanding the true nature of JavaScript arrays. In practice, however, most JavaScript arrays you will work with will not be sparse. And, if you do have to work with a sparse array, your code will probably treat it just as it would treat a nonsparse array with undefined elements. 了解稀疏数组是了解 JavaScript 数组的真实本质的一部分。尽管如此，实际上你所碰到的绝大多数 JavaScript 数组不是稀疏数组。并且，如果你确实碰到了稀疏数组，你的代码很可能像对待非稀疏数组一样来对待它们，只不过它们包含一些 undefined 元素。 ","date":"2020-11-02","objectID":"/posts/ch7/:3:0","tags":null,"title":"第 7 章 数组","uri":"/posts/ch7/"},{"categories":null,"content":"7.4 Array Length Every array has a length property, and it is this property that makes arrays different from regular JavaScript objects. For arrays that are dense (i.e., not sparse), the length property specifies the number of elements in the array. Its value is one more than the highest index in the array: 每个数组有一个 length 属性，就是这个属性使其区别于常规的 JavaScript 对象。针对稠密（也就是非稀疏）数组，length 属性值代表数组中元素的个数。其值比数组中最大的索引大 1： [].length // =\u003e 0: the array has no elements [\"a\",\"b\",\"c\"].length // =\u003e 3: highest index is 2, length is 3 When an array is sparse, the length property is greater than the number of elements, and all we can say about it is that length is guaranteed to be larger than the index of every element in the array. Or, put another way, an array (sparse or not) will never have an element whose index is greater than or equal to its length. In order to maintain this invariant, arrays have two special behaviors. The first we described above: if you assign a value to an array element whose index i is greater than or equal to the array’s current length, the value of the length property is set to i+1. 当数组是稀疏的时，length 属性值大于元素的个数。而且关于此我们可以说数组长度保证大于它每个元素的索引值。或者，换一种说法，在数组中（无论稀疏与否）肯定找不到一个元素的索引值大于或等于它的长度。为了维持此规则不变化，数组有两个特殊的行为。第一个如同上面的描述：如果为一个数组元素赋值，它的索引 i 大于或等于现有数组的长度时，length 属性的值将设置为 i+1。 The second special behavior that arrays implement in order to maintain the length invariant is that, if you set the length property to a non-negative integer n smaller than its current value, any array elements whose index is greater than or equal to n are deleted from the array: 第二个特殊的行为就是设置 length 属性为一个小于当前长度的非负整数n时，当前数组中那些索引值大于或等于 n 的元素将从中删除： a = [1,2,3,4,5]; // Start with a 5-element array. a.length = 3; // a is now [1,2,3]. a.length = 0; // Delete all elements. a is []. a.length = 5; // Length is 5, but no elements, like new Array(5) You can also set the length property of an array to a value larger than its current value. Doing this does not actually add any new elements to the array; it simply creates a sparse area at the end of the array. 还可以将数组的 length 属性值设置为大于其当前的长度。实际上这不会向数组中添加新的元素，它只是在数组尾部创建一个稀疏区域。 ","date":"2020-11-02","objectID":"/posts/ch7/:4:0","tags":null,"title":"第 7 章 数组","uri":"/posts/ch7/"},{"categories":null,"content":"7.5 Adding and Deleting Array Elements We’ve already seen the simplest way to add elements to an array: just assign values to new indexes: 我们已经见过添加数组元素最简单的方法：为新索引赋值： let a = []; // Start with an empty array. a[0] = \"zero\"; // And add elements to it. a[1] = \"one\"; You can also use the push() method to add one or more values to the end of an array: 也可以使用push()方法在数组末尾增加一个或多个元素： let a = []; // Start with an empty array a.push(\"zero\"); // Add a value at the end. a = [\"zero\"] a.push(\"one\", \"two\"); // Add two more values. a = [\"zero\", \"one\", \"two\"] Pushing a value onto an array a is the same as assigning the value to a[a.length]. You can use the unshift() method (described in §7.8) to insert a value at the beginning of an array, shifting the existing array elements to higher indexes. The pop() method is the opposite of push(): it removes the last element of the array and returns it, reducing the length of an array by 1. Similarly, the shift() method removes and returns the first element of the array, reducing the length by 1 and shifting all elements down to an index one lower than their current index. See §7.8 for more on these methods. 在数组尾部压入一个元素与给 a[a.length] 赋值是一样的。可以使用 unshift() 方法（§7.8 有描述）在数组的首部插入一个元素，并且将其他元素依次移到更高的索引处。pop() 方法与 push() 相反：它移除数组最后一个元素并返回这个元素，使数组 length 减 1。同样，shift() 方法移除并返回数组的第一个元素，使数组 length 减 1，并将其他元素依次移到低 1 的索引处。§7.8 有更多关于这些方法的描述。 You can delete array elements with the delete operator, just as you can delete object properties: 可以像删除对象属性一样使用 delete 运算符来删除数组元素： let a = [1,2,3]; delete a[2]; // a now has no element at index 2 2 in a // =\u003e false: no array index 2 is defined a.length // =\u003e 3: delete does not affect array length Deleting an array element is similar to (but subtly different than) assigning undefined to that element. Note that using delete on an array element does not alter the length property and does not shift elements with higher indexes down to fill in the gap that is left by the deleted property. If you delete an element from an array, the array becomes sparse. 删除数组元素与为其赋 undefined 值是类似的（但有一些微妙的区别）。注意，对一个数组元素使用 delete 不会修改数组的 length 属性，也不会将元素从高索引处移下来填充已删除属性留下的空白。如果从数组中删除一个元素，它就变成稀疏数组。 As we saw above, you can also remove elements from the end of an array simply by setting the length property to the new desired length. 正如上面所看到的，也可以通过设置新的所需长度，即可从数组尾部删除元素。 Finally, splice() is the general-purpose method for inserting, deleting, or replaci ng array elements. It alters the length property and shifts array elements to higher or lower indexes as needed. See §7.8 for details. 最后，splice() 是一个通用的方法来插入、删除或替换数组元素。它会根据需要修改 length 属性并移动元素到更高或较低的索引处。详细内容见 §7.8。 ","date":"2020-11-02","objectID":"/posts/ch7/:5:0","tags":null,"title":"第 7 章 数组","uri":"/posts/ch7/"},{"categories":null,"content":"7.6 Iterating Arrays As of ES6, the easiest way to loop through each of the elements of an array (or any iterable object) is with the for/of loop, which was covered in detail in §5.4.4: 在 ES6 中，最容易遍历数组元素（或可迭代对象）的方法是 for/of 循环，在 §5.4.4 中详细介绍： let letters = [...\"Hello world\"]; // An array of letters let string = \"\"; for(let letter of letters) { string += letter; } string // =\u003e \"Hello world\"; we reassembled the original text The built-in array iterator that the for/of loop uses returns the elements of an array in ascending order. It has no special behavior for sparse arrays and simply returns undefined for any array elements that do not exist. 内置数组迭代器 for/of 循环按照升序返回数组元素。对于稀疏数组它没有特殊的行为，数组中不存在的元素只是单纯的返回 undefined。 If you want to use a for/of loop for an array and need to know the index of each array element, use the entries() method of the array, along with destructuring assignment, like this: 如果使用 for/of 循环一个数组时还需要知道每个元素的索引，可以像这样将数组的 entries() 方法和解构语句一同使用： let everyother = \"\"; for(let [index, letter] of letters.entries()) { if (index % 2 === 0) everyother += letter; // letters at even indexes } everyother // =\u003e \"Hlowrd\" Another good way to iterate arrays is with forEach(). This is not a new form of the for loop, but an array method that offers a functional approach to array iteration. You pass a function to the forEach() method of an array, and forEach() invokes your function once on each element of the array: 另一种不错的遍历数组方法是用 forEach()。这不是 for 循环的新形式，而是提供数组遍历功能方法的数组方法。可以给数组的 forEach() 方法传递一个函数，forEach() 会对数组中每一个元素调用这个方法： let uppercase = \"\"; letters.forEach(letter =\u003e { // Note arrow function syntax here uppercase += letter.toUpperCase(); }); uppercase // =\u003e \"HELLO WORLD\" As you would expect, forEach() iterates the array in order, and it actually passes the array index to your function as a second argument, which is occasionally useful. Unlike the for/of loop, the forEach() is aware of sparse arrays and does not invoke your function for elements that are not there. 正如期望的，forEach() 按顺序对数组进行计算，实际上它将数组索引作为第二个实参传递到函数，这有时很有用。与 for/of 循环不同，forEach() 能意识到稀疏数组，并且不会为不存在的元素调用函数。 §7.8.1 documents the forEach() method in more detail. That section also covers related methods such as map() and filter() that perform specialized kinds of array iteration. §7.8.1 更详细地记录了 forEach() 方法。该部分还介绍演示了特定类型的数组遍历方法，如 map() 和 filter()。 You can also loop through the elements of an array with a good old-fashioned for loop (§5.4.3): 也可以用一种非常老旧方式遍历数组的元素（§5.4.3）： let vowels = \"\"; for(let i = 0; i \u003c letters.length; i++) { // For each index in the array let letter = letters[i]; // Get the element at that index if (/[aeiou]/.test(letter)) { // Use a regular expression test vowels += letter; // If it is a vowel, remember it } } vowels // =\u003e \"eoo\" In nested loops, or other contexts where performance is critical, you may sometimes see this basic array iteration loop written so that the array length is only looked up once rather than on each iteration. Both of the following for loop forms are idiomatic, though not particularly common, and with modern JavaScript interpreters, it is not at all clear that they have any performance impact: 在嵌套循环或其他性能至关重要的上下文中，有时可能会看到这样的数组遍历，以便数组长度仅被查一次，而不是在每次循环都去查询。以下两种形式都是符合习惯的 for 循环，虽然不是特别常用，而且对于现代 JavaScript 解释器，它们是否对性能有任何影响尚不清楚： // Save the array length into a local variable for(let i = 0, len = letters.length; i \u003c len; i++) { // loop body remains the same } // Iterate backwards from the end of the array to the start for(let i = letters.length-1; i \u003e= 0; i--) { // loop body remains the same } These examples assume that the array is dense and that all elements contain valid data. If this is not the case, you should test the array elements before using them. If you want to skip undefined and nonexistent elements, you might write: 这些示例假定数组是稠密的，并且所有元素都包含有效的数据。如果不是这样，应该在使用数组元素之前测试它们。如果要跳过 undefined 和不存在的元素，可以编写： for(let i = 0; i \u003c a.length; i++) { if (a[i] === undefined) continue; // Skip undefined + nonexistent elements // loop body here } ","date":"2020-11-02","objectID":"/posts/ch7/:6:0","tags":null,"title":"第 7 章 数组","uri":"/posts/ch7/"},{"categories":null,"content":"7.7 Multidimensional Arrays JavaScript does not support true multidimensional arrays, but you can approximate them with arrays of arrays. To access a value in an array of arrays, simply use the [] operator twice. For example, suppose the variable matrix is an array of arrays of numbers. Every element in matrix[x] is an array of numbers. To access a particular number within this array, you would write matrix[x][y]. Here is a concrete example that uses a two-dimensional array as a multiplication table: JavaScript 不支持真正的多维数组，但可以用数组的数组来近似。访问数组的数组中的元素，只要简单地使用两次 [] 操作符即可。例如，假设变量 matrix 是一个数组的数组，它的基本元素是数值，那么 matrix[x] 的每个元素是包含一个数值数组，访问数组中特定数值的代码为 matrix[x][y]。这里有一个具体的例子，它使用二维数组作为一个九九乘法表： // Create a multidimensional array let table = new Array(10); // 10 rows of the table for(let i = 0; i \u003c table.length; i++) { table[i] = new Array(10); // Each row has 10 columns } // Initialize the array for(let row = 0; row \u003c table.length; row++) { for(let col = 0; col \u003c table[row].length; col++) { table[row][col] = row*col; } } // Use the multidimensional array to compute 5*7 table[5][7] // =\u003e 35 ","date":"2020-11-02","objectID":"/posts/ch7/:7:0","tags":null,"title":"第 7 章 数组","uri":"/posts/ch7/"},{"categories":null,"content":"7.8 Array Methods The preceding sections have focused on basic JavaScript syntax for working with arrays. In general, though, it is the methods defined by the Array class that are the most powerful. The next sections document these methods. While reading about these methods, keep in mind that some of them modify the array they are called on and some of them leave the array unchanged. A number of the methods return an array: sometimes, this is a new array, and the original is unchanged. Other times, a method will modify the array in place and will also return a reference to the modified array. 前面几节重点介绍了用于处理数组的基本 JavaScript 语法。但通常，由 Array 类定义的方法是最强大的。下一节将记录这些方法。在阅读有关这些方法时，请记住，其中一些方法修改了调用的数组，而其中一些方法使数组保持不变。许多方法返回数组：有时，这是一个新数组，原始数组保持不变。其他时候，方法将修改数组，并且返回对修改后数组的引用。 Each of the subsections that follows covers a group of related array methods: 以下每个小节都涵盖一组相关的数组方法： Iterator methods loop over the elements of an array, typically invoking a function that you specify on each of those elements. 迭代器方法循环遍历数组的元素，通常调用在每个元素上指定的函数。 Stack and queue methods add and remove array elements to and from the beginning and the end of an array. 堆栈和队列方法在数组的开头和结尾添加和删除数组元素。 Subarray methods are for extracting, deleting, inserting, filling, and copying contiguous regions of a larger array. 子数组方法用于提取、删除、插入、填充和复制一个更大数组中相邻的区域。 Searching and sorting methods are for locating elements within an array and for sorting the elements of an array. 搜索和排序方法用于查找数组中的元素和排序数组的元素。 The following subsections also cover the static methods of the Array class and a few miscellaneous methods for concatenating arrays and converting arrays to strings. 以下小节还介绍 Array 类的静态方法和一些用于连接数组和将数组转换为字符串的各种方法。 ","date":"2020-11-02","objectID":"/posts/ch7/:8:0","tags":null,"title":"第 7 章 数组","uri":"/posts/ch7/"},{"categories":null,"content":"7.8.1 Array Iterator Methods The methods described in this section iterate over arrays by passing array elements, in order, to a function you supply, and they provide convenient ways to iterate, map, filter, test, and reduce arrays. 本节中介绍的方法通过将数组元素按顺序传递到所指定的函数来遍历数组，它们提供了迭代、映射、筛选、测试和减少数组的便捷方法。 Before we explain the methods in detail, however, it is worth making some generalizations about them. First, all of these methods accept a function as their first argument and invoke that function once for each element (or some elements) of the array. If the array is sparse, the function you pass is not invoked for nonexistent elements. In most cases, the function you supply is invoked with three arguments: the value of the array element, the index of the array element, and the array itself. Often, you only need the first of these argument values and can ignore the second and third values. 然而，在详细解释这些方法之前，值得对它们进行一些概括。首先，所有这些方法都接受函数作为其第一个实参，并使用调用数组的每个元素（或某些元素）作为实参调用该函数。如果数组是稀疏的，则不会为不存在的元素调用传递的函数。在大多数情况下，提供的函数被调用时有三个实参：数组元素的值、数组元素的索引和数组本身。通常，只需要这些实参值中的第一个，并且可以忽略第二个和第三个值。 Most of the iterator methods described in the following subsections accept an optional second argument. If specified, the function is invoked as if it is a method of this second argument. That is, the second argument you pass becomes the value of the this keyword inside of the function you pass as the first argument. The return value of the function you pass is usually important, but different methods handle the return value in different ways. None of the methods described here modify the array on which they are invoked (though the function you pass can modify the array, of course). 以下小节中描述的大多数迭代器方法都接受可选的第二个实参。如果指定，则调用函数就像它是第二个实参的方法一样。也就是说，传递的第二个实参将成为第一个函数实参内部的 this 值。传递的函数的返回值通常很重要，但不同的方法以不同的方式处理返回值。此处描述的方法都没有修改调用它们的数组（当然，传递的函数可以修改这个数组）。 Each of these functions is invoked with a function as its first argument, and it is very common to define that function inline as part of the method invocation expression instead of using an existing function that is defined elsewhere. Arrow function syntax (see §8.1.3) works particularly well with these methods, and we will use it in the examples that follow. 这节的每个函数都调用它的第一个函数实参，并且通常将该函数内联定义为方法调用表达式的一部分，而不是使用在其他地方显示定义的函数。箭头函数语法（参见 §8.1.3）在这些方法中特别有效，我们将在下面的示例中使用它。 FOREACH() The forEach() method iterates through an array, invoking a function you specify for each element. As we’ve described, you pass the function as the first argument to forEach(). forEach() then invokes your function with three arguments: the value of the array element, the index of the array element, and the array itself. If you only care about the value of the array element, you can write a function with only one parameter—the additional arguments will be ignored: forEach() 方法遍历数组，调用为每个元素指定的函数。正如我们已经描述的那样，将函数作为第一个实参传递给 forEach()。forEach() 然后使用三个实参调用函数：数组元素的值、数组元素的索引和数组本身。如果只关心数组元素的值，则编写一个只有一个实参的函数（将忽略其他实参）： let data = [1,2,3,4,5], sum = 0; // Compute the sum of the elements of the array data.forEach(value =\u003e { sum += value; }); // sum == 15 // Now increment each array element data.forEach(function(v, i, a) { a[i] = v + 1; }); // data == [2,3,4,5,6] Note that forEach() does not provide a way to terminate iteration before all elements have been passed to the function. That is, there is no equivalent of the break statement you can use with a regular for loop. 请注意，forEach() 不提供在所有元素传递给函数之前终止迭代的方法。也就是说，没有等效于常规 for 循环的 break 语句可以使用。 MAP() The map() method passes each element of the array on which it is invoked to the function you specify and returns an array containing the values returned by your function. For example: map() 方法将调用数组的每个元素传递到指定的函数，并返回一个包含函数返回的值的数组。例如： let a = [1, 2, 3]; a.map(x =\u003e x*x) // =\u003e [1, 4, 9]: the function takes input x and returns x*x The function you pass to map() is invoked in the same way as a function passed to forEach(). For the map() method, however, the function you pass should return a value. Note that map() returns a new array: it does not modif","date":"2020-11-02","objectID":"/posts/ch7/:8:1","tags":null,"title":"第 7 章 数组","uri":"/posts/ch7/"},{"categories":null,"content":"7.8.2 Flattening arrays with flat() and flatMap() In ES2019, the flat() method creates and returns a new array that contains the same elements as the array it is called on, except that any elements that are themselves arrays are “flattened” into the returned array. For example: 在 ES2019 中，flat() 方法创建并返回一个新的数组，该数组包含与调用的数组相同的元素，只不过作为数组的任何元素都\"展平\"到返回的数组中。例如： [1, [2, 3]].flat() // =\u003e [1, 2, 3] [1, [2, [3]]].flat() // =\u003e [1, 2, [3]] When called with no arguments, flat() flattens one level of nesting. Elements of the original array that are themselves arrays are flattened, but array elements of those arrays are not flattened. If you want to flatten more levels, pass a number to flat(): 当调用时没有实参，flat() 将平展一个级别的嵌套。作为数组的原始数组的元素被展平，但这些数组的数组元素不会展平。如果要展平更多级别，需要传递数字给 flat()： let a = [1, [2, [3, [4]]]]; a.flat(1) // =\u003e [1, 2, [3, [4]]] a.flat(2) // =\u003e [1, 2, 3, [4]] a.flat(3) // =\u003e [1, 2, 3, 4] a.flat(4) // =\u003e [1, 2, 3, 4] The flatMap() method works just like the map() method (see “map()”) except that the returned array is automatically flattened as if passed to flat(). That is, calling a.flatMap(f) is the same as (but more efficient than) a.map(f).flat(): flatMap() 方法的工作方式与 map() 方法（见“map()”）类似，只不过返回的数组会自动展平，就像传递到 flat()。也就是说，调用 a.flatMap(f) 与 a.map(f).flat()（但更高效）相同： let phrases = [\"hello world\", \"the definitive guide\"]; let words = phrases.flatMap(phrase =\u003e phrase.split(\" \")); words // =\u003e [\"hello\", \"world\", \"the\", \"definitive\", \"guide\"]; You can think of flatMap() as a generalization of map() that allows each element of the input array to map to any number of elements of the output array. In particular, flatMap() allows you to map input elements to an empty array, which flattens to nothing in the output array: 可以将 flatMap() 视为 map() 的泛化，它允许输入数组的每个元素映射到输出数组的多个元素。特别的是，flatMap() 允许将输入元素映射到空数组，该数组在平展后不输出到数组中： // Map non-negative numbers to their square roots [-2, -1, 1, 2].flatMap(x =\u003e x \u003c 0 ? [] : Math.sqrt(x)) // =\u003e [1, 2**0.5] ","date":"2020-11-02","objectID":"/posts/ch7/:8:2","tags":null,"title":"第 7 章 数组","uri":"/posts/ch7/"},{"categories":null,"content":"7.8.3 Adding arrays with concat() The concat() method creates and returns a new array that contains the elements of the original array on which concat() was invoked, followed by each of the arguments to concat(). If any of these arguments is itself an array, then it is the array elements that are concatenated, not the array itself. Note, however, that concat() does not recursively flatten arrays of arrays. concat() does not modify the array on which it is invoked: concat() 方法创建并返回一个新数组，它的元素包括调用 concat() 的原始数组的元素和 concat() 的每个实参。如果这些实参中的任何一个自身是数组，则连接的是数组的元素，而非数组本身。但要注意，concat() 不会递归扁平化数组的数组。concat() 也不会修改调用的数组： let a = [1,2,3]; a.concat(4, 5) // =\u003e [1,2,3,4,5] a.concat([4,5],[6,7]) // =\u003e [1,2,3,4,5,6,7]; arrays are flattened a.concat(4, [5,[6,7]]) // =\u003e [1,2,3,4,5,[6,7]]; but not nested arrays a // =\u003e [1,2,3]; the original array is unmodified Note that concat() makes a new copy of the array it is called on. In many cases, this is the right thing to do, but it is an expensive operation. If you find yourself writing code like a = a.concat(x), then you should think about modifying your array in place with push() or splice() instead of creating a new one. 请注意，concat() 创建调用数组的新副本。在许多情况下，这是正确的做法，但它是一个昂贵的操作。如果您发现自己编写代码像 a = a.concat(x)，那么您应该考虑使用 push() 或 splice() 修改数组，而不是创建新的数组。 ","date":"2020-11-02","objectID":"/posts/ch7/:8:3","tags":null,"title":"第 7 章 数组","uri":"/posts/ch7/"},{"categories":null,"content":"7.8.4 Stacks and Queues with push(), pop(), shift(), and unshift() The push() and pop() methods allow you to work with arrays as if they were stacks. The push() method appends one or more new elements to the end of an array and returns the new length of the array. Unlike concat(), push() does not flatten array arguments. The pop() method does the reverse: it deletes the last element of an array, decrements the array length, and returns the value that it removed. Note that both methods modify the array in place. The combination of push() and pop() allows you to use a JavaScript array to implement a first-in, last-out stack. For example: push() 和 pop() 方法允许将数组当做栈来使用。push() 方法在数组的尾部添加一个或多个元素，并返回数组新的长度。pop() 方法则相反：它删除数组的最后一个元素，减小数组长度并返回它删除的值。注意，两个方法都修改并替换原始数组而非生成一个修改版的新数组。组合使用 push() 和 pop() 能够用 JavaScript 数组实现先进后出的栈。例如： let stack = []; // stack == [] stack.push(1,2); // stack == [1,2]; stack.pop(); // stack == [1]; returns 2 stack.push(3); // stack == [1,3] stack.pop(); // stack == [1]; returns 3 stack.push([4,5]); // stack == [1,[4,5]] stack.pop() // stack == [1]; returns [4,5] stack.pop(); // stack == []; returns 1 The push() method does not flatten an array you pass to it, but if you want to push all of the elements from one array onto another array, you can use the spread operator (§8.3.4) to flatten it explicitly: push() 方法不展平传入的数组，但如果想要将数组的元素全部压入另外一个数组，可以使用展开运算符（§8.3.4）来显示展开： a.push(...values); The unshift() and shift() methods behave much like push() and pop(), except that they insert and remove elements from the beginning of an array rather than from the end. unshift() adds an element or elements to the beginning of the array, shifts the existing array elements up to higher indexes to make room, and returns the new length of the array. shift() removes and returns the first element of the array, shifting all subsequent elements down one place to occupy the newly vacant space at the start of the array. You could use unshift() and shift() to implement a stack, but it would be less efficient than using push() and pop() because the array elements need to be shifted up or down every time an element is added or removed at the start of the array. Instead, though, you can implement a queue data structure by using push() to add elements at the end of an array and shift() to remove them from the start of the array: unshift() 和 shift() 方法的行为非常类似于 push() 和 pop()，不一样的是前者是在数组的头部而非尾部进行元素的插入和删除操作。unshift() 在数组的头部添加一个或多个元素，并将已存在的元素移动到更高索引的位置来获得足够的空间，最后返回数组新的长度。shift() 删除数组的第一个元素并将其返回，然后把所有随后的元素下移一个位置来填补数组头部的空缺。可以使用 unshift() 和 shift() 实现栈，但它比使用 push() 和 pop() 的效率低，因为每次在数组头部添加或删除元素时，都需要向上或向下移动数组元素。但是，您可以使用 push() 在数组末尾添加元素并 shift() 从数组的头部删除它们来实现队列数据解构： let q = []; // q == [] q.push(1,2); // q == [1,2] q.shift(); // q == [2]; returns 1 q.push(3) // q == [2, 3] q.shift() // q == [3]; returns 2 q.shift() // q == []; returns 3 There is one feature of unshift() that is worth calling out because you may find it surprising. When passing multiple arguments to unshift(), they are inserted all at once, which means that they end up in the array in a different order than they would be if you inserted them one at a time: unshift() 有一个特性是值得一提的，你可能会觉得它令人惊讶。将多个实参传入 unshift() 时，它们将一次全部插入，这意味着它们最终在数组中的顺序与一次插入一个实参的顺序时不同的： let a = []; // a == [] a.unshift(1) // a == [1] a.unshift(2) // a == [2, 1] a = []; // a == [] a.unshift(1,2) // a == [1, 2] ","date":"2020-11-02","objectID":"/posts/ch7/:8:4","tags":null,"title":"第 7 章 数组","uri":"/posts/ch7/"},{"categories":null,"content":"7.8.5 Subarrays with slice(), splice(), fill(), and copyWithin() Arrays define a number of methods that work on contiguous regions, or subarrays or “slices” of an array. The following sections describe methods for extracting, replacing, filling, and copying slices. 数组定义了许多在连续区域，子数组或数组的“片段”上工作的方法。 以下各节描述了提取，替换，填充和复制片段的方法。 SLICE() The slice() method returns a slice, or subarray, of the specified array. Its two arguments specify the start and end of the slice to be returned. The returned array contains the element specified by the first argument and all subsequent elements up to, but not including, the element specified by the second argument. If only one argument is specified, the returned array contains all elements from the start position to the end of the array. If either argument is negative, it specifies an array element relative to the length of the array. An argument of –1, for example, specifies the last element in the array, and an argument of –2 specifies the element before that one. Note that slice() does not modify the array on which it is invoked. Here are some examples: slice() 方法返回指定数组的一个片段或子数组。它的两个实参分别指定了片段的开始和结束的位置。返回的数组包含第一个实参指定的位置到（但不包含）第二个实参指定的位置之间的所有数组元素。如果只指定一个实参，返回的数组将包含从开始位置到数组结尾的所有元素。如实参中出现负数，它表示相对于数组 length 的位置。例如，实参 -1 指定了最后一个元素，而 -2 指定了它前面的元素。注意，slice() 不会修改调用的数组。下面有一些示例： let a = [1,2,3,4,5]; a.slice(0,3); // Returns [1,2,3] a.slice(3); // Returns [4,5] a.slice(1,-1); // Returns [2,3,4] a.slice(-3,-2); // Returns [3] SPLICE() splice() is a general-purpose method for inserting or removing elements from an array. Unlike slice() and concat(), splice() modifies the array on which it is invoked. Note that splice() and slice() have very similar names but perform substantially different operations. splice() 方法是在数组中插入或删除元素的通用方法。不同于 slice() 和 concat()，splice() 会修改调用的数组。注意，splice() 和 slice() 拥有非常相似的名字， 但它们的功能却有本质的区别。 splice() can delete elements from an array, insert new elements into an array, or perform both operations at the same time. Elements of the array that come after the insertion or deletion point have their indexes increased or decreased as necessary so that they remain contiguous with the rest of the array. The first argument to splice() specifies the array position at which the insertion and/or deletion is to begin. The second argument specifies the number of elements that should be deleted from (spliced out of) the array. (Note that this is another difference between these two methods. The second argument to slice() is an end position. The second argument to splice() is a length.) If this second argument is omitted, all array elements from the start element to the end of the array are removed. splice() returns an array of the deleted elements, or an empty array if no elements were deleted. For example: splice() 能够从数组中删除元素、插入元素到数组中或者同时完成这两种操作。在插入或删除点之后的数组元素会根据需要增加或减小它们的索引值，因此数组的其他部分仍然保持连续的。splice() 的第一个实参指定了插入和（或）删除的起始位置。第二个实参指定了应该从数组中删除的元素的个数。（注意这里是这两个方法的另外一个不同。slice() 的第二个实参是结束的位置。splice() 的第二个实参是长度。）如果省略第二个实参，从起始点开始到数组结尾的所有元素都将被删除。splice() 返回一个由删除元素组成的数组，或者如果没有删除元素就返回一个空数组。例如： let a = [1,2,3,4,5,6,7,8]; a.splice(4) // =\u003e [5,6,7,8]; a is now [1,2,3,4] a.splice(1,2) // =\u003e [2,3]; a is now [1,4] a.splice(1,1) // =\u003e [4]; a is now [1] The first two arguments to splice() specify which array elements are to be deleted. These arguments may be followed by any number of additional arguments that specify elements to be inserted into the array, starting at the position specified by the first argument. For example: splice() 的前两个实参指定了需要删除的数组元素。紧随其后的任意个数的实参指定了需要插入到数组中的元素，从第一个实参指定的位置开始插入。例如： let a = [1,2,3,4,5]; a.splice(2,0,\"a\",\"b\") // =\u003e []; a is now [1,2,\"a\",\"b\",3,4,5] a.splice(2,2,[1,2],3) // =\u003e [\"a\",\"b\"]; a is now [1,2,[1,2],3,3,4,5] Note that, unlike concat(), splice() inserts arrays themselves, not the elements of those arrays. 注意，不同于 concat()，splice() 插入数组本身，不是数组的元素。 FILL() The fill() method sets the elements of an array, or a slice of an array, to a specified value. It mutates the array it is called on,","date":"2020-11-02","objectID":"/posts/ch7/:8:5","tags":null,"title":"第 7 章 数组","uri":"/posts/ch7/"},{"categories":null,"content":"7.8.6 Array Searching and Sorting Methods Arrays implement indexOf(), lastIndexOf(), and includes() methods that are similar to the same-named methods of strings. There are also sort() and reverse() methods for reordering the elements of an array. These methods are described in the subsections that follow. 数组实现 indexOf()、lastIndexOf() 和 include() 方法，这些方法类似于名称相同的字符串方法。还有 sort() 和 reverse() 方法，用于对数组元素进行重新排序。这些方法在下面的小节中介绍。 INDEXOF() AND LASTINDEXOF() indexOf() and lastIndexOf() search an array for an element with a specified value and return the index of the first such element found, or -1 if none is found. indexOf() searches the array from beginning to end, and lastIndexOf() searches from end to beginning: indexOf() 和 lastIndexOf() 在数组中搜索具有指定值的元素，并返回找到的第一个元素的索引，如果未找到，则返回 -1。indexOf() 从头到尾搜索数组，lastIndexOf() 从尾到头搜索： let a = [0,1,2,1,0]; a.indexOf(1) // =\u003e 1: a[1] is 1 a.lastIndexOf(1) // =\u003e 3: a[3] is 1 a.indexOf(3) // =\u003e -1: no element has value 3 indexOf() and lastIndexOf() compare their argument to the array elements using the equivalent of the === operator. If your array contains objects instead of primitive values, these methods check to see if two references both refer to exactly the same object. If you want to actually look at the content of an object, try using the find() method with your own custom predicate function instead. indexOf() 和 lastIndexOf() 使用 === 运算符将其实参与数组元素进行比较。如果数组包含对象而不是原始值，则这些方法将检查两个引用是否都指向完全相同的对象。如果要实际查看对象的内容，尝试将 find() 方法代替自定义的断言函数。 indexOf() and lastIndexOf() take an optional second argument that specifies the array index at which to begin the search. If this argument is omitted, indexOf() starts at the beginning and lastIndexOf() starts at the end. Negative values are allowed for the second argument and are treated as an offset from the end of the array, as they are for the slice() method: a value of –1, for example, specifies the last element of the array. indexOf() 和 lastIndexOf() 采用可选的第二个实参，该实参指定开始搜索的数组索引。如果省略此参数，则 indexOf() 从开头开始，lastIndexOf() 从结尾开始。第二个参数允许使用负值，并将其视为距数组末端的偏移量，就像 slice() 方法一样：例如，值 –1 指定数组的最后一个元素。 The following function searches an array for a specified value and returns an array of all matching indexes. This demonstrates how the second argument to indexOf() can be used to find matches beyond the first. 以下函数在数组中搜索指定的值，并返回所有匹配索引的数组。这演示了如何使用 indexOf() 的第二个参数来查找第一个参数之外的匹配项。 // Find all occurrences of a value x in an array a and return an array // of matching indexes function findall(a, x) { let results = [], // The array of indexes we'll return len = a.length, // The length of the array to be searched pos = 0; // The position to search from while(pos \u003c len) { // While more elements to search... pos = a.indexOf(x, pos); // Search if (pos === -1) break; // If nothing found, we're done. results.push(pos); // Otherwise, store index in array pos = pos + 1; // And start next search at next element } return results; // Return array of indexes } Note that strings have indexOf() and lastIndexOf() methods that work like these array methods, except that a negative second argument is treated as zero. 请注意，字符串具有 indexOf() 和 lastIndexOf() 方法，它们与这些数组方法一样工作，不同之处在于第二个实参是负数时被视为零。 INCLUDES() The ES2016 includes() method takes a single argument and returns true if the array contains that value or false otherwise. It does not tell you the index of the value, only whether it exists. The includes() method is effectively a set membership test for arrays. Note, however, that arrays are not an efficient representation for sets, and if you are working with more than a few elements, you should use a real Set object (§11.1.1). ES2016 的 includes() 方法采用单个实参，如果数组包含该值返回 true 否则 false。它不会告诉你值的索引，只告诉你该值是否存在。includes() 方法实际上是数组集的成员身份测试。但是请注意，数组不是 Set 的高效表示形式，如果使用多个元素，则应使用真正的 Set 对象（§11.1.1）。 The includes() method is slightly different than the indexOf() method in one important way. indexOf() tests equality using the same algorithm that the === operator does, and that equality algorithm considers the not-a-number value to ","date":"2020-11-02","objectID":"/posts/ch7/:8:6","tags":null,"title":"第 7 章 数组","uri":"/posts/ch7/"},{"categories":null,"content":"7.8.7 Array to String Conversions The Array class defines three methods that can convert arrays to strings, which is generally something you might do when creating log and error messages. (If you want to save the contents of an array in textual form for later reuse, serialize the array with JSON.stringify() [§6.8] instead of using the methods described here.) Array 类定义了三个方法来将数组转化为字符串，通常在创建日志和错误信息时会用到。（如果要以文本形式保存数组的内容供以后重用，请使用 JSON.stringify()（§6.8）序列化数组，而不是使用此处描述的方法。） The join() method converts all the elements of an array to strings and concatenates them, returning the resulting string. You can specify an optional string that separates the elements in the resulting string. If no separator string is specified, a comma is used: join() 方法将数组的所有元素转换为字符串并连接它们，返回生成的字符串。可以指定一个可选字符串来分隔生成的字符串中的元素。如果未指定分隔符字符串，则使用逗号： let a = [1, 2, 3]; a.join() // =\u003e \"1,2,3\" a.join(\" \") // =\u003e \"1 2 3\" a.join(\"\") // =\u003e \"123\" let b = new Array(10); // An array of length 10 with no elements b.join(\"-\") // =\u003e \"---------\": a string of 9 hyphens The join() method is the inverse of the String.split() method, which creates an array by breaking a string into pieces. join() 方法是 String.split() 方法的反向方法，该方法通过将字符串拆分为多个片段来创建数组。 Arrays, like all JavaScript objects, have a toString() method. For an array, this method works just like the join() method with no arguments: 数组与所有 JavaScript 对象一样，具有 toString() 方法。对于数组，此方法的工作方式与没有参数的 join() 方法相同： [1,2,3].toString() // =\u003e \"1,2,3\" [\"a\", \"b\", \"c\"].toString() // =\u003e \"a,b,c\" [1, [2,\"c\"]].toString() // =\u003e \"1,2,c\" Note that the output does not include square brackets or any other sort of delimiter around the array value. 请注意，输出不包括方括号或数组值周围的任何其他分隔符。 toLocaleString() is the localized version of toString(). It converts each array element to a string by calling the toLocaleString() method of the element, and then it concatenates the resulting strings using a locale-specific (and implementation-defined) separator string. toLocaleString() 是 toString() 的本地化版本。它通过调用元素的 toLocaleString() 方法将每个数组元素转换为字符串，然后使用特定于区域设置（和实现定义）分隔符字符串连接生成的字符串。 ","date":"2020-11-02","objectID":"/posts/ch7/:8:7","tags":null,"title":"第 7 章 数组","uri":"/posts/ch7/"},{"categories":null,"content":"7.8.8 Static Array Functions In addition to the array methods we’ve already documented, the Array class also defines three static functions that you can invoke through the Array constructor rather than on arrays. Array.of() and Array.from() are factory methods for creating new arrays. They were documented in §7.1.4 and §7.1.5. 除了我们已经记录的数组方法之外，Array 类还定义了三个静态函数，可以通过 Array 构造函数而不是数组调用。Array.of() 和 Array.from() 是用于创建新数组的工厂方法。它们记录在 §7.1.4 和 §7.1.5 中。 The one other static array function is Array.isArray(), which is useful for determining whether an unknown value is an array or not: 另外一个静态数组方法是 Array.isArray()，用来判断一个未知值是否是数组： Array.isArray([]) // =\u003e true Array.isArray({}) // =\u003e false ","date":"2020-11-02","objectID":"/posts/ch7/:8:8","tags":null,"title":"第 7 章 数组","uri":"/posts/ch7/"},{"categories":null,"content":"7.9 Array-Like Objects As we’ve seen, JavaScript arrays have some special features that other objects do not have: 我们已经看到，JavaScript 数组的有一些特性是其他对象所没有的： The length property is automatically updated as new elements are added to the list. 当有新的元素添加到列表中时，自动更新 length 属性。 Setting length to a smaller value truncates the array. length 设置为一个较小值将截断数组。 Arrays inherit useful methods from Array.prototype. 从 Array.prototype 中继承一些有用的方法。 Array.isArray() returns true for arrays. 数组传入 Array.isArray() 方法返回 true。 These are the features that make JavaScript arrays distinct from regular objects. But they are not the essential features that define an array. It is often perfectly reasonable to treat any object with a numeric length property and corresponding non-negative integer properties as a kind of array. 这些特性让 JavaScript 数组和常规的对象有明显的区别。但是它们不是定义数组的本质特性。一种常常完全合理的看法是把拥有一个数值型 length 属性和对应非负整数属性的对象看作数组的同类。 These “array-like” objects actually do occasionally appear in practice, and although you cannot directly invoke array methods on them or expect special behavior from the length property, you can still iterate through them with the same code you’d use for a true array. It turns out that many array algorithms work just as well with array-like objects as they do with real arrays. This is especially true if your algorithms treat the array as read-only or if they at least leave the array length unchanged. 实际上这些“类数组”对象在实践中偶尔出现，虽然不能通过它们直接调用数组方法或者期望 length 属性有什么特殊的行为，但是仍然可以用针对真正数组遍历代码来遍历它们。结论就是很多数组算法针对类数组对象同样奏效，就像针对真正的数组一样。尤其是这种情况，算法把数组看成只读的或者如果保持数组长度不变。 The following code takes a regular object, adds properties to make it an array-like object, and then iterates through the “elements” of the resulting pseudo-array: 以下代码为一个常规对象增加了一些属性使其变成类数组对象，然后遍历生成的伪数组的“元素”： let a = {}; // Start with a regular empty object // Add properties to make it \"array-like\" let i = 0; while(i \u003c 10) { a[i] = i * i; i++; } a.length = i; // Now iterate through it as if it were a real array let total = 0; for(let j = 0; j \u003c a.length; j++) { total += a[j]; } In client-side JavaScript, a number of methods for working with HTML documents (such as document.querySelectorAll(), for example) return array-like objects. Here’s a function you might use to test for objects that work like arrays: 在客户端 JavaScript 中，很多作用于 HTML documents 的方法（例如 document.querySelectorAll()）返回类数组对象。下面这个函数可能会用于测试对象是否可以用作类数组： // Determine if o is an array-like object. // Strings and functions have numeric length properties, but are // excluded by the typeof test. In client-side JavaScript, DOM text // nodes have a numeric length property, and may need to be excluded // with an additional o.nodeType !== 3 test. function isArrayLike(o) { if (o \u0026\u0026 // o is not null, undefined, etc. typeof o === \"object\" \u0026\u0026 // o is an object Number.isFinite(o.length) \u0026\u0026 // o.length is a finite number o.length \u003e= 0 \u0026\u0026 // o.length is non-negative Number.isInteger(o.length) \u0026\u0026 // o.length is an integer o.length \u003c 4294967295) { // o.length \u003c 2^32 - 1 return true; // Then o is array-like. } else { return false; // Otherwise it is not. } } We’ll see in a later section that strings behave like arrays. Nevertheless, tests like this one for array-like objects typically return false for strings—they are usually best handled as strings, not as arrays. 我们会在下一节看到字符串的行为像数组一样。尽管如此，对于数组这种测试（对字符串通常返回 false ）它们通常最好作为字符串处理，而不是作为数组处理。 Most JavaScript array methods are purposely defined to be generic so that they work correctly when applied to array-like objects in addition to true arrays. Since array-like objects do not inherit from Array.prototype, you cannot invoke array methods on them directly. You can invoke them indirectly using the Function.call method, however (see §8.7.4 for details): 大多数 JavaScript 数组方法都特意定义为泛型，以便它们在应用于除数组之外的类数组可以正常工作。由于类数组对象不会从 Array.prototype 继承，因此不能直接在它们上调用数组方法。但是，可以使用 Function.call 方法间接调用它们（详情请参阅 §8.7.4）： let a = {\"0\": \"a\", \"1\": \"b\", \"2\": \"c\", length: 3}; // An array-like object Array.prototype.join.call(a, \"+\") // =\u003e \"a+b+c\" Array.","date":"2020-11-02","objectID":"/posts/ch7/:9:0","tags":null,"title":"第 7 章 数组","uri":"/posts/ch7/"},{"categories":null,"content":"7.10 Strings as Arrays JavaScript strings behave like read-only arrays of UTF-16 Unicode characters. Instead of accessing individual characters with the charAt() method, you can use square brackets: JavaScript 字符串的行为类似于 UTF-16 Unicode 字符的只读数组。可以使用方括号替代 charAt() 方法访问单个字符： let s = \"test\"; s.charAt(0) // =\u003e \"t\" s[1] // =\u003e \"e\" The typeof operator still returns “string” for strings, of course, and the Array.isArray() method returns false if you pass it a string. 当然，字符串使用 typeof 运算符仍然返回 “string”，如果将字符串传递给 Array.isArray() 方法，则返回 false。 The primary benefit of indexable strings is simply that we can replace calls to charAt() with square brackets, which are more concise and readable, and potentially more efficient. The fact that strings behave like arrays also means, however, that we can apply generic array methods to them. For example: 可索引字符串的主要好处是，我们可以用方括号替换对 charAt() 的调用，方括号更简洁、更可读，而且可能更高效。但是，字符串的行为类似于数组，也意味着我们可以对它们应用泛型数组方法。例如： Array.prototype.join.call(\"JavaScript\", \" \") // =\u003e \"J a v a S c r i p t\" Keep in mind that strings are immutable values, so when they are treated as arrays, they are read-only arrays. Array methods like push(), sort(), reverse(), and splice() modify an array in place and do not work on strings. Attempting to modify a string using an array method does not, however, cause an error: it simply fails silently. 请记住，字符串是不可变值，因此当字符串被视为数组时，它们是只读数组。数组方法 push()、sort()、reverse() 和 splice() 直接修改数组，它们不能处理字符串。但是，尝试使用数组方法修改字符串不会引发异常：它只是静默失败。 ","date":"2020-11-02","objectID":"/posts/ch7/:10:0","tags":null,"title":"第 7 章 数组","uri":"/posts/ch7/"},{"categories":null,"content":"7.11 Summary This chapter has covered JavaScript arrays in depth, including esoteric details about sparse arrays and array-like objects. The main points to take from this chapter are: 本章深入介绍了 JavaScript 数组，包括有关稀疏数组和类数组对象的深奥细节。本章要点包括： Array literals are written as comma-separated lists of values within square brackets. 数组字面量编写：方括号内逗号分隔值列表。 Individual array elements are accessed by specifying the desired array index within square brackets. 通过在方括号内指定所需的数组索引来访问单个数组元素。 The for/of loop and … spread operator introduced in ES6 are particularly useful ways to iterate arrays. for/of 循环和 ES6 中引入的 … 展开运算符是遍历数组的特别有用的方法。 The Array class defines a rich set of methods for manipulating arrays, and you should be sure to familiarize yourself with the Array API. Array 类定义了一组用于操作数组的丰富方法，应该确保熟悉 Array API。 ","date":"2020-11-02","objectID":"/posts/ch7/:11:0","tags":null,"title":"第 7 章 数组","uri":"/posts/ch7/"},{"categories":null,"content":"This chapter covers JavaScript functions. Functions are a fundamental building block for JavaScript programs and a common feature in almost all programming languages. You may already be familiar with the concept of a function under a name such as subroutine or procedure. 本章介绍了 JavaScript 函数。函数是 JavaScript 程序的基本构建块，也是几乎所有编程语言的共同特性。你可能已经了解函数的概念，如子例程或过程。 A function is a block of JavaScript code that is defined once but may be executed, or invoked, any number of times. JavaScript functions are parameterized: a function definition may include a list of identifiers, known as parameters, that work as local variables for the body of the function. Function invocations provide values, or arguments, for the function’s parameters. Functions often use their argument values to compute a return value that becomes the value of the function-invocation expression. In addition to the arguments, each invocation has another value—the invocation context—that is the value of the this keyword. 函数是一个 JavaScript 代码块，只定义一次，但可以执行或调用任意次数。JavaScript 函数是参数化的：一个函数定义可以包含一个标识符列表，称为参数，作为函数体的局部变量。函数调用为函数的参数提供值或实参。函数通常使用它们的实参值来计算一个返回值，该返回值成为函数调用表达式的值。除了参数之外，每次调用都有另一个值——调用上下文——即 this 关键字的值。 If a function is assigned to a property of an object, it is known as a method of that object. When a function is invoked on or through an object, that object is the invocation context or this value for the function. Functions designed to initialize a newly created object are called constructors. Constructors were described in §6.2 and will be covered again in Chapter 9. 如果函数挂载在一个对象上作为其属性，它就被称为方法。当该方法在对象中被调用或通过对象调用时，该对象就是该方法函数的调用上下文或 this 值。用于初始化新创建的对象的函数称为构造函数。构造函数在 §6.2 中有介绍，我们将在第 9 章中再次谈到它。 In JavaScript, functions are objects, and they can be manipulated by programs. JavaScript can assign functions to variables and pass them to other functions, for example. Since functions are objects, you can set properties on them and even invoke methods on them. 在 JavaScript 中，函数是对象，它们可以被程序操作。例如，JavaScript 可以将函数赋给变量，并将它们传递给其他函数。由于函数是对象，所以您可以给它们设置属性，甚至调用它们的方法。 JavaScript function definitions can be nested within other functions, and they have access to any variables that are in scope where they are defined. This means that JavaScript functions are closures, and it enables important and powerful programming techniques. JavaScript 函数可以嵌套在其他函数中定义，并且它们可以访问定义它们所处的作用域内任何变量。这意味着 JavaScript 函数是闭包，支持闭包是非常重要的，它是非常强大的编程技巧。 ","date":"2020-11-02","objectID":"/posts/ch8/:0:0","tags":null,"title":"第 8 章 函数","uri":"/posts/ch8/"},{"categories":null,"content":"8.1 Defining Functions The most straightforward way to define a JavaScript function is with the function keyword, which can be used as a declaration or as an expression. ES6 defines an important new way to define functions without the function keyword: “arrow functions” have a particularly compact syntax and are useful when passing one function as an argument to another function. The subsections that follow cover these three ways of defining functions. Note that some details of function definition syntax involving function parameters are deferred to §8.3. 定义 JavaScript 函数最直接的方法是使用 function 关键字，它既可以用作声明又可以用作表达式。ES6 定义了一种不使用 function 关键字的重要新方法来定义的函数：“箭头函数”，它具有特别简洁语法，并且在将一个函数作为参数传递给另一个函数的场景中非常实用。接下来的小节将介绍这三种定义函数的方法。注意，关于函数定义语法包含的函数参数相关内容将在 §8.3 中介绍。 In object literals and class definitions, there is a convenient shorthand syntax for defining methods. This shorthand syntax was covered in §6.10.5 and is equivalent to using a function definition expression and assigning it to an object property using the basic name:value object literal syntax. In another special case, you can use keywords get and set in object literals to define special property getter and setter methods. This function definition syntax was covered in §6.10.6. 在对象字面量和类定义中，有一种方便的快捷语法来定义方法。这种简写语法在 §6.10.5 中有介绍，相当于通过对象字面量语法将函数定义表达式用最基本的属性名：属性值的方式赋值给对象的属性。在另一种特殊情况下，可以在对象字面量中使用关键字 get 和 set 来定义特殊的属性 getter 和 setter 方法。这个函数定义语法在 §6.10.6 中介绍过。 Note that functions can also be defined with the Function() constructor, which is the subject of §8.7.7. Also, JavaScript defines some specialized kinds of functions. function* defines generator functions (see Chapter 12) and async function defines asynchronous functions (see Chapter 13). 注意，函数也可以用 Function() 构造函数来定义，这是 §8.7.7 的主题。此外，JavaScript 还定义了一些特殊类型的函数。function* 定义函数生成器（见第 12 章）和 async function 定义异步函数（见第 13 章）。 ","date":"2020-11-02","objectID":"/posts/ch8/:1:0","tags":null,"title":"第 8 章 函数","uri":"/posts/ch8/"},{"categories":null,"content":"8.1.1 Function Declarations Function declarations consist of the function keyword, followed by these components: An identifier that names the function. The name is a required part of function declarations: it is used as the name of a variable, and the newly defined function object is assigned to the variable. A pair of parentheses around a comma-separated list of zero or more identifiers. These identifiers are the parameter names for the function, and they behave like local variables within the body of the function. A pair of curly braces with zero or more JavaScript statements inside. These statements are the body of the function: they are executed whenever the function is invoked. 函数声明由 function 关键字组成，后面跟着这些组件: 函数名称标识符。名称是函数声明的必要部分:它用作变量的名称，并将新定义的函数对象赋值给该变量。 一对圆括号，其中包含由0个或者多个用逗号分隔的标识符组成的列表。这些标识符是函数的参数名，它们的行为类似于函数体中的局部变量。 一对花括号，其中包含由0条或者多条 JavaScript 语句。这些语句构成了函数体：每当函数调用时，就会执行这些语句。 Here are some example function declarations: 下面是一些函数声明的例子: // Print the name and value of each property of o. Return undefined. function printprops(o) { for(let p in o) { console.log(`${p}: ${o[p]}\\n`); } } // Compute the distance between Cartesian points (x1,y1) and (x2,y2). function distance(x1, y1, x2, y2) { let dx = x2 - x1; let dy = y2 - y1; return Math.sqrt(dx*dx + dy*dy); } // A recursive function (one that calls itself) that computes factorials // Recall that x! is the product of x and all positive integers less than it. function factorial(x) { if (x \u003c= 1) return 1; return x * factorial(x-1); } One of the important things to understand about function declarations is that the name of the function becomes a variable whose value is the function itself. Function declaration statements are “hoisted” to the top of the enclosing script, function, or block so that functions defined in this way may be invoked from code that appears before the definition. Another way to say this is that all of the functions declared in a block of JavaScript code will be defined throughout that block, and they will be defined before the JavaScript interpreter begins to execute any of the code in that block. 重中之重要理解函数声明是函数名变成一个变量，这个变量的值是函数本身。函数声明语句“被提前”到脚本、函数、块之前，因此这种方式定义的函数可以在它定义之前被调用。另一种说法是所有声明在 Javascript 代码块中的函数，在块内始终是有定义的，它们定义在 JavaScript 解释器开始解释执行块内任何语句之前。 The distance() and factorial() functions we’ve described are designed to compute a value, and they use return to return that value to their caller. The return statement causes the function to stop executing and to return the value of its expression (if any) to the caller. If the return statement does not have an associated expression, the return value of the function is undefined. distance() 和 factorial() 函数计算一个值，它们用 retrun 来将这个值返回给调用者。return 语句导致函数停止执行，并返回它的表达式的值（如果有的话）给调用者。如果 return 语句没有一个与之相关的表达式，则函数返回 undefined 值。 The printprops() function is different: its job is to output the names and values of an object’s properties. No return value is necessary, and the function does not include a return statement. The value of an invocation of the printprops() function is always undefined. If a function does not contain a return statement, it simply executes each statement in the function body until it reaches the end, and returns the undefined value to the caller. printprops() 函数不同：它负责输出对象属性的名称和值。没有返回值的必要，并且该函数也不包含一个 return 语句。 调用 printprops() 函数的返回值永远是 undefined。如果一个函数不包含一个 return 语句，它仅仅执行函数体内每一条语句直到结束，并返回 undefined 给调用者。 Prior to ES6, function declarations were only allowed at the top level within a JavaScript file or within another function. While some implementations bent the rule, it was not technically legal to define functions inside the body of loops, conditionals, or other blocks. In the strict mode of ES6, however, function declarations are allowed within blocks. A function defined within a block only exists within that block, however, and is not visible outside the block. 在 ES6 之前，函数只允许在 JavaScript 文件顶层或者其他函数中声明。然而一些实现违反规约，在循环体条件体或者其他块中定义函数。在 ES6 的严格模式下，函数允许在块内进行声明。一个定义在块内的函数只存在于该块内，块外是不可见的。 ","date":"2020-11-02","objectID":"/posts/ch8/:1:1","tags":null,"title":"第 8 章 函数","uri":"/posts/ch8/"},{"categories":null,"content":"8.1.2 Function Expressions Function expressions look a lot like function declarations, but they appear within the context of a larger expression or statement, and the name is optional. 函数表达式看起来很像函数声明，但是它出现在一个它的上层表达式或语句的上下文中，并且函数名称是可选项。 Here are some example function expressions: 下面是一些函数表达式的例子： // This function expression defines a function that squares its argument. // Note that we assign it to a variable const square = function(x) { return x*x; }; // Function expressions can include names, which is useful for recursion. const f = function fact(x) { if (x \u003c= 1) return 1; else return x*fact(x-1); }; // Function expressions can also be used as arguments to other functions: [3,2,1].sort(function(a,b) { return a-b; }); // Function expressions are sometimes defined and immediately invoked: let tensquared = (function(x) {return x*x;}(10)); Note that the function name is optional for functions defined as expressions, and most of the preceding function expressions we’ve shown omit it. A function declaration actually declares a variable and assigns a function object to it. A function expression, on the other hand, does not declare a variable: it is up to you to assign the newly defined function object to a constant or variable if you are going to need to refer to it multiple times. It is a good practice to use const with function expressions so you don’t accidentally overwrite your functions by assigning new values. 注意函数名称在函数表达式中是可选项，在大部分函数表达式中我们省略了它。函数声明实际上声明了一个变量并且将函数对象赋值给它。按照这个角度来看，函数表达式没有声明一个变量：可以根据它是否会多次调用由你自己决定是将新定义的函数对象赋值给一个常量还是变量。用 const 定义函数表达式是一个非常好的做法，你不会因为意外赋值而重写了你的函数。 A name is allowed for functions, like the factorial function, that need to refer to themselves. If a function expression includes a name, the local function scope for that function will include a binding of that name to the function object. In effect, the function name becomes a local variable within the function. Most functions defined as expressions do not need names, which makes their definition more compact (though not nearly as compact as arrow functions, described below). 可以给函数一个名称，就像 factorial 函数，它需要调用它自己。如果一个函数表达式包含一个名称，那这个函数的局部函数作用域内会包含一个属性名为该函数名的对象，其值绑定的是该函数。实际上，函数名变成这个函数的一个局部变量。大多数函数表达式不需要函数名称，这让它们的定义更简洁（但是并没有下面要讲的箭头函数简洁）。 There is an important difference between defining a function f() with a function declaration and assigning a function to the variable f after creating it as an expression. When you use the declaration form, the function objects are created before the code that contains them starts to run, and the definitions are hoisted so that you can call these functions from code that appears above the definition statement. This is not true for functions defined as expressions, however: these functions do not exist until the expression that defines them are actually evaluated. Furthermore, in order to invoke a function, you must be able to refer to it, and you can’t refer to a function defined as an expression until it is assigned to a variable, so functions defined with expressions cannot be invoked before they are defined. 在函数声明和函数表达式之间有一个非常重要的不同。当你用函数声明，该函数对象创建于该函数所在作用域的代码开始执行之前，也就是声明提前，所以你可以在函数定义之前调用他们。如果用函数表达式来定义一个函数，这样使用就是不对的：该函数不会存在，直到函数定义表达式真正被计算。因为，想要执行一个函数，你必须可以引用它，而一个函数表达式定义的函数一直到该函数赋值给一个变量后才能被引用，所以要使用函数表达式需要在函数被调用之前定义。 ","date":"2020-11-02","objectID":"/posts/ch8/:1:2","tags":null,"title":"第 8 章 函数","uri":"/posts/ch8/"},{"categories":null,"content":"8.1.3 Arrow Functions In ES6, you can define functions using a particularly compact syntax known as “arrow functions.” This syntax is reminiscent of mathematical notation and uses an =\u003e “arrow” to separate the function parameters from the function body. The function keyword is not used, and, since arrow functions are expressions instead of statements, there is no need for a function name, either. The general form of an arrow function is a comma-separated list of parameters in parentheses, followed by the =\u003e arrow, followed by the function body in curly braces: 在 ES6 之后，你可以用一个特别简洁的语法来定义函数，被称为“箭头函数”。这个语法联想到数学符号，用一个 =\u003e “箭头\"来分隔函数的参数和函数体。function 关键字未使用，并且，由于箭头函数是表达式而不是声明语句，也不需要一个函数名称。一般箭头函数用圆括号包含一个逗号分隔的参数列表，接一个 =\u003e 箭头，后面是花括号包含的函数体。 const sum = (x, y) =\u003e { return x + y; }; But arrow functions support an even more compact syntax. If the body of the function is a single return statement, you can omit the return keyword, the semicolon that goes with it, and the curly braces, and write the body of the function as the expression whose value is to be returned: 但是箭头函数支持更加简洁的语法。如果函数体只有一个简单的 return 语句，你可以省略 return 关键字，分号和花括号都一起省略，将函数体写成一个计算返回值的表达式。 const sum = (x, y) =\u003e x + y; Furthermore, if an arrow function has exactly one parameter, you can omit the parentheses around the parameter list: 而且，如果一个箭头函数只有一个参数，你可以省略参数列表的圆括号。 const polynomial = x =\u003e x*x + 2*x + 3; Note, however, that an arrow function with no arguments at all must be written with an empty pair of parentheses: 注意，如果箭头函数没有参数，必须写一对空圆括号。 const constantFunc = () =\u003e 42; Note that, when writing an arrow function, you must not put a new line between the function parameters and the =\u003e arrow. Otherwise, you could end up with a line like const polynomial = x, which is a syntactically valid assignment statement on its own. 注意，当写一个箭头函数时，函数参数和箭头之间不能换行。否则，可能会直接在赋值后中止，就像 const polynomial = x，因为它本身是一个语法上合法的赋值语句。 Also, if the body of your arrow function is a single return statement but the expression to be returned is an object literal, then you have to put the object literal inside parentheses to avoid syntactic ambiguity between the curly braces of a function body and the curly braces of an object literal: 此外，如果箭头函数体是一个单一的 return 语句，而且他返回的是一个对象字面量，那必须将对象字面量用圆括号包起来，避免将对象字面量的大括号误解成函数体的大括号。 const f = x =\u003e { return { value: x }; }; // Good: f() returns an object const g = x =\u003e ({ value: x }); // Good: g() returns an object const h = x =\u003e { value: x }; // Bad: h() returns nothing const i = x =\u003e { v: x, w: x }; // Bad: Syntax Error In the third line of this code, the function h() is truly ambiguous: the code you intended as an object literal can be parsed as a labeled statement, so a function that returns undefined is created. On the fourth line, however, the more complicated object literal is not a valid statement, and this illegal code causes a syntax error. 这段代码的第三行，函数 h() 就有歧义：这段代码原本返回对象字面量被转化为一个标签语句，所以一个返回 undefined 的函数被创建。第四行，结构更复杂的对象字面量不是一个合法的语句，这段代码会抛出一个语法异常。 The concise syntax of arrow functions makes them ideal when you need to pass one function to another function, which is a common thing to do with array methods like map(), filter(), and reduce() (see §7.8.1), for example: 简洁的箭头函数可以完美的传递一个函数给另外一个函数，比如一些数组的常规操作方法 map()，filter() 和 reduce()（见 §7.8.1），例如： // Make a copy of an array with null elements removed. let filtered = [1,null,2,3].filter(x =\u003e x !== null); // filtered == [1,2,3] // Square some numbers: let squares = [1,2,3,4].map(x =\u003e x*x); // squares == [1,4,9,16] Arrow functions differ from functions defined in other ways in one critical way: they inherit the value of the this keyword from the environment in which they are defined rather than defining their own invocation context as functions defined in other ways do. This is an important and very useful feature of arrow functions, and we’ll return to it again later in this chapter. Arrow functions also differ from other functions in that they do not have a prototype property, which means that they cannot be used as constructor funct","date":"2020-11-02","objectID":"/posts/ch8/:1:3","tags":null,"title":"第 8 章 函数","uri":"/posts/ch8/"},{"categories":null,"content":"8.1.4 Nested Functions In JavaScript, functions may be nested within other functions. For example: 在 JavaScript 中，函数可以嵌套在其他函数内。例如： function hypotenuse(a, b) { function square(x) { return x*x; } return Math.sqrt(square(a) + square(b)); } The interesting thing about nested functions is their variable scoping rules: they can access the parameters and variables of the function (or functions) they are nested within. In the code shown here, for example, the inner function square() can read and write the parameters a and b defined by the outer function hypotenuse(). These scope rules for nested functions are very important, and we will consider them again in §8.6. 嵌套函数的有趣之处在于它的变量作用域规则：它们可以访问嵌套它们（或多重嵌套）的函数的参数和变量。例如，在上面的代码里，内部函数 square() 可以读写外部函数 hypotenuse() 定义的参数 a 和 b。这些作用域规则对嵌套函数非常重要，我们会在 §8.6 再深入了解它们。 ","date":"2020-11-02","objectID":"/posts/ch8/:1:4","tags":null,"title":"第 8 章 函数","uri":"/posts/ch8/"},{"categories":null,"content":"8.2 Invoking Functions The JavaScript code that makes up the body of a function is not executed when the function is defined, but rather when it is invoked. JavaScript functions can be invoked in five ways: 构成函数主体的 JavaScript 代码在定义之时并不会执行，只有调用该函数时，它们才会执行。JavaScript 函数可以以五种方式被调用。 As functions As methods As constructors Indirectly through their call() and apply() methods Implicitly, via JavaScript language features that do not appear like normal function invocations 作为函数 作为方法 作为构造函数 通过它们的 call() 和 apply() 方法间接调用 隐式调用，不同于普通函数调，通过 JavaScript 语言特性调用函数。 ","date":"2020-11-02","objectID":"/posts/ch8/:2:0","tags":null,"title":"第 8 章 函数","uri":"/posts/ch8/"},{"categories":null,"content":"8.2.1 Function Invocation Functions are invoked as functions or as methods with an invocation expression (§4.5). An invocation expression consists of a function expression that evaluates to a function object followed by an open parenthesis, a comma-separated list of zero or more argument expressions, and a close parenthesis. If the function expression is a property-access expression—if the function is the property of an object or an element of an array—then it is a method invocation expression. That case will be explained in the following example. The following code includes a number of regular function invocation expressions: 函数或方法通过调用表达式（§4.5）被调用。调用表达式由以下部分组成，计算函数对象的函数表达式，一个开放圆括号，逗号分隔的零个或多个实参表达式列表，一个闭合圆括号。如果函数表达式是属性访问表达式（函数是一个对象的属性或者一个数组的元素）那么它是一个方法调用表达式。这种情况会通过下面的例子说明，接下来这个代码包含了一些常规的函数调用表达式： printprops({x: 1}); let total = distance(0,0,2,1) + distance(2,1,3,5); let probability = factorial(5)/factorial(13); In an invocation, each argument expression (the ones between the parentheses) is evaluated, and the resulting values become the arguments to the function. These values are assigned to the parameters named in the function definition. In the body of the function, a reference to a parameter evaluates to the corresponding argument value. 在调用中，每个实参表达式（圆括号内的）执行计算，返回值作为函数的实参。这些值传给函数定义的参数。在函数体内，参数的引用指向对应实参的值。 For regular function invocation, the return value of the function becomes the value of the invocation expression. If the function returns because the interpreter reaches the end, the return value is undefined. If the function returns because the interpreter executes a return statement, then the return value is the value of the expression that follows the return or is undefined if the return statement has no value. 对于常规的函数调用，函数返回值变成函数调用表达式的值。如果因解释器执行到函数结尾而返回，返回值就是 undefined。如果函数返回是因为解释器执行一个 return 语句，那么返回值是 return 后面的表达式的计算结果，如果 return 语句没有值也返回 undefined。 CONDITIONAL INVOCATION In ES2020 you can insert ?. after the function expression and before the open parenthesis in a function invocation in order to invoke the function only if it is not null or undefined. That is, the expression f?.(x) is equivalent (assuming no side effects) to: 在 ES2020 中你可以通过在函数表达式和圆括号之间插入 ?. 符号，使函数只有在不为 null 和 undefined 时候再调用。表达式 f?.(x) 等价（假设没有副作用）于： (f !== null \u0026\u0026 f !== undefined) ? f(x) : undefined Full details on this conditional invocation syntax are in §4.5.1. 详细的条件执行语法描述在 §4.5.1。 For function invocation in non-strict mode, the invocation context (the this value) is the global object. In strict mode, however, the invocation context is undefined. Note that functions defined using the arrow syntax behave differently: they always inherit the this value that is in effect where they are defined. 函数调用在非严格模式下，调用上下文（ this ）是全局对象。然而在严格模式下，调用上下文是 undefined。注意箭头语法定义的函数行为是不同的：实际上它们总是继承它们定义位置的 this 值。 Functions written to be invoked as functions (and not as methods) do not typically use the this keyword at all. The keyword can be used, however, to determine whether strict mode is in effect: 以函数形式调用的函数通常不使用 this 关键字。不过，this 关键字可以用来判断当前是否是严格模式。 // Define and invoke a function to determine if we're in strict mode. const strict = (function() { return !this; }()); RECURSIVE FUNCTIONS AND THE STACK A recursive function is one, like the factorial() function at the start of this chapter, that calls itself. Some algorithms, such as those involving tree-based data structures, can be implemented particularly elegantly with recursive functions. When writing a recursive function, however, it is important to think about memory constraints. When a function A calls function B, and then function B calls function C, the JavaScript interpreter needs to keep track of the execution contexts for all three functions. When function C completes, the interpreter needs to know where to resume executing function B, and when function B completes, it needs to know where to resume executing function A. You can imagine these execution contexts as a stack. When a function calls another functi","date":"2020-11-02","objectID":"/posts/ch8/:2:1","tags":null,"title":"第 8 章 函数","uri":"/posts/ch8/"},{"categories":null,"content":"8.2.2 Method Invocation A method is nothing more than a JavaScript function that is stored in a property of an object. If you have a function f and an object o, you can define a method named m of o with the following line: 方法只不过是对象属性函数。如果有一个函数 f 和一个对象 o，可以用下面的代码给对象 o 定义一个名为 m 的方法： o.m = f; Having defined the method m() of the object o, invoke it like this: 给对象 o 定义了方法 m()，用这种方式调用它： o.m(); Or, if m() expects two arguments, you might invoke it like this: 或者 m() 需要两个实参，可以这样调用它： o.m(x, y); The code in this example is an invocation expression: it includes a function expression o.m and two argument expressions, x and y. The function expression is itself a property access expression, and this means that the function is invoked as a method rather than as a regular function. 示例中的代码是一个调用表达式：它包含一个函数表达式 o.m 和两个实参表达式 x 和 y。函数表达式本身是一个属性访问表达式，这意味着该函数被当作一个方法调用，而不是一个普通的函数。 The arguments and return value of a method invocation are handled exactly as described for regular function invocation. Method invocations differ from function invocations in one important way, however: the invocation context. Property access expressions consist of two parts: an object (in this case o) and a property name (m). In a method-invocation expression like this, the object o becomes the invocation context, and the function body can refer to that object by using the keyword this. Here is a concrete example: 对方法调用的参数和返回值的处理，和上面所描述的普通函数调用完全一致。但是，方法调用和函数调用有一个重要的区别，即：调用上下文。属性访问表达式由两部分组成：一个对象（本例中的 o）和属性名称（m）。在像这样的方法调用表达式里，对象 o 成为调用上下文，函数体可以使用关键字this引用该对象。下面是一个具体的例子： let calculator = { // An object literal operand1: 1, operand2: 1, add() { // We're using method shorthand syntax for this function // Note the use of the this keyword to refer to the containing object. this.result = this.operand1 + this.operand2; } }; calculator.add(); // A method invocation to compute 1+1. calculator.result // =\u003e 2 Most method invocations use the dot notation for property access, but property access expressions that use square brackets also cause method invocation. The following are both method invocations, for example: 大多数方法调用使用点符号来访问属性，使用方括号（属性访问表达式）也可以进行属性访问操作。下面两个例子都是函数调用： o[\"m\"](x,y); // Another way to write o.m(x,y). a[0](z) // Also a method invocation (assuming a[0] is a function). Method invocations may also involve more complex property access expressions: 方法调用可能包括更复杂的属性访问表达式： customer.surname.toUpperCase(); // Invoke method on customer.surname f().m(); // Invoke method m() on return value of f() Methods and the this keyword are central to the object-oriented programming paradigm. Any function that is used as a method is effectively passed an implicit argument—the object through which it is invoked. Typically, a method performs some sort of operation on that object, and the method-invocation syntax is an elegant way to express the fact that a function is operating on an object. Compare the following two lines: 方法和 this 关键字是面向对象编程范式的核心。任何函数只要作为方法调用实际上都会传入一个隐式的实参对象，就是调用这个方法对象本身。通常来讲，方法执行就是对象的某种操作，方法调用的语法也清晰的表达了它是操作对象的函数，比较下面两行代码： rect.setSize(width, height); setRectSize(rect, width, height); The hypothetical functions invoked in these two lines of code may perform exactly the same operation on the (hypothetical) object rect, but the method-invocation syntax in the first line more clearly indicates the idea that it is the object rect that is the primary focus of the operation. 我们假设这两行代码的功能完全一样，它们都作用于一个假定的对象 rect。可以看出，第一行的方法调用语法非常清晰地表明这个函数执行的载体是 rect 对象，函数中的所有操作都将基于这个对象。 METHOD CHAINING When methods return objects, you can use the return value of one method invocation as part of a subsequent invocation. This results in a series (or “chain”) of method invocations as a single expression. When working with Promise-based asynchronous operations (see Chapter 13), for example, it is common to write code structured like this: 当方法返回一个对象，这个对象还可以再调用它的方法。这种方法调用序列中（或“链”）每次的调用结果都是另外一个表达式的组成部分。比如，基于 Promise 的异步操作（参见第 13 章），我们常常会这样写代码： // Run three asynchronous operations in sequence, handling errors. ","date":"2020-11-02","objectID":"/posts/ch8/:2:2","tags":null,"title":"第 8 章 函数","uri":"/posts/ch8/"},{"categories":null,"content":"8.2.3 Constructor Invocation If a function or method invocation is preceded by the keyword new, then it is a constructor invocation. (Constructor invocations were introduced in §4.6 and §6.2.2, and constructors will be covered in more detail in Chapter 9.) Constructor invocations differ from regular function and method invocations in their handling of arguments, invocation context, and return value. 如果函数或者方法调用之前带有关键字 new，它就构成构造函数调用（构造函数调用在 §4.6 和 §6.2.2 节有简单介绍，第 9 章会对构造函数做更详细的讨论）。构造函数调用和普通的函数调用以及方法调用在实参处理、调用上下文和返回值方面都有不同。 If a constructor invocation includes an argument list in parentheses, those argument expressions are evaluated and passed to the function in the same way they would be for function and method invocations. It is not common practice, but you can omit a pair of empty parentheses in a constructor invocation. The following two lines, for example, are equivalent: 如果构造函数调用在圆括号内包含一组实参列表，先计算这些实参表达式，然后传入函数内，这和函数调用和方法调用是一致的。但如果构造函数没有形参，JavaScript 构造函数调用的语法是允许省略实参列表和圆括号的。凡是没有形参的构造函数调用都可以省略圆括号，比如，下面这两行代码就是等价的： o = new Object(); o = new Object; A constructor invocation creates a new, empty object that inherits from the object specified by the prototype property of the constructor. Constructor functions are intended to initialize objects, and this newly created object is used as the invocation context, so the constructor function can refer to it with the this keyword. Note that the new object is used as the invocation context even if the constructor invocation looks like a method invocation. That is, in the expression new o.m(), o is not used as the invocation context. 构造函数调用创建一个新的空对象，这个对象继承自构造函数的 prototype 属性。构造函数试图初始化这个新创建的对象，并将这个对象用做其调用上下文，因此构造函数内可以使用 this 关键字来引用这个新创建的对象。注意，尽管构造函数看起来像一个方法调用，它依然会使用这个新对象作为调用上下文。也就是说，在表达式 new o.m() 中，调用上下文并不是 o。 Constructor functions do not normally use the return keyword. They typically initialize the new object and then return implicitly when they reach the end of their body. In this case, the new object is the value of the constructor invocation expression. If, however, a constructor explicitly uses the return statement to return an object, then that object becomes the value of the invocation expression. If the constructor uses return with no value, or if it returns a primitive value, that return value is ignored and the new object is used as the value of the invocation. 构造函数通常不使用 return 关键字，它们通常初始化新对象，当构造函数的函数体执行完毕时，它会隐式返回。在这种情况下，构造函数调用表达式的计算结果就是这个新对象的值。然而如果构造函数显式地使用 return 语句返回一个对象，那么调用表达式的值就是这个对象。如果构造函数使用 return 语句但没有指定返回值，或者返回一个原始值，那么这时将忽略返回值，同时使用这个新对象作为调用结果。 ","date":"2020-11-02","objectID":"/posts/ch8/:2:3","tags":null,"title":"第 8 章 函数","uri":"/posts/ch8/"},{"categories":null,"content":"8.2.4 Indirect Invocation JavaScript functions are objects, and like all JavaScript objects, they have methods. Two of these methods, call() and apply(), invoke the function indirectly. Both methods allow you to explicitly specify the this value for the invocation, which means you can invoke any function as a method of any object, even if it is not actually a method of that object. Both methods also allow you to specify the arguments for the invocation. The call() method uses its own argument list as arguments to the function, and the apply() method expects an array of values to be used as arguments. The call() and apply() methods are described in detail in §8.7.4. JavaScript 中的函数也是对象，和其他 JavaScript 对象没什么两样，函数对象也可以包含方法。其中的两个方法 call() 和 apply() 可以用来间接地调用函数。两个方法都允许显式指定调用所需的 this 值，也就是说，任何函数可以作为任何对象的方法来调用，哪怕这个函数不是那个对象的方法。两个方法都可以指定调用的实参。call() 方法使用它自有的实参列表作为函数的实参，apply() 方法则要求以数组的形式传入实参。§8.7.4 节会有关于 call() 和apply () 方法的详细讨论。 ","date":"2020-11-02","objectID":"/posts/ch8/:2:4","tags":null,"title":"第 8 章 函数","uri":"/posts/ch8/"},{"categories":null,"content":"8.2.5 Implicit Function Invocation There are various JavaScript language features that do not look like function invocations but that cause functions to be invoked. Be extra careful when writing functions that may be implicitly invoked, because bugs, side effects, and performance issues in these functions are harder to diagnose and fix than in regular functions for the simple reason that it may not be obvious from a simple inspection of your code when they are being called. 有各种各样的 JavaScript 语言特性，它们看起来不像函数调用但是却能调用函数。额外小心编写函数时可能会隐式调用，因为在隐式函数调用中 bug、副作用和性能问题都比普通的函数更难诊断和修复。 The language features that can cause implicit function invocation include: 可能引起函数隐式调用的语言特性包括： If an object has getters or setters defined, then querying or setting the value of its properties may invoke those methods. See §6.10.6 for more information. 如果一个对象定义了 getter 或者 setter 方法，获取或者设置它的属性值可能调用这些方法。见 §6.10.6 有更多相关描述。 When an object is used in a string context (such as when it is concatenated with a string), its toString() method is called. Similarly, when an object is used in a numeric context, its valueOf() method is invoked. See §3.9.3 for details. 当对象用作一个字符串文本时（例如对象和一个字符串连接），它的 toString() 方法会被调用。同样的，对象用作一个数值型文本时，它的 valueOf() 方法被调用。详见 §3.9.3。 When you loop over the elements of an iterable object, there are a number of method calls that occur. Chapter 12 explains how iterators work at the function call level and demonstrates how to write these methods so that you can define your own iterable types. 当循环可迭代对象的元素时会产生很多方法调用。第 12 章介绍了迭代器在函数调用级别如何工作，并演示如何编写方法来定义自己的可迭代类型。 A tagged template literal is a function invocation in disguise. §14.5 demonstrates how to write functions that can be used in conjunction with template literal strings. 可以伪装在模板字面量中 。在 §14.5 中演示如何在模板字符串中调用函数。 Proxy objects (described in §14.7) have their behavior completely controlled by functions. Just about any operation on one of these objects will cause a function to be invoked. Proxy 对象（在 §14.7 中描述）的行为完全由函数控制。它的任何一个操作都会导致函数调用。 ","date":"2020-11-02","objectID":"/posts/ch8/:2:5","tags":null,"title":"第 8 章 函数","uri":"/posts/ch8/"},{"categories":null,"content":"8.3 Function Arguments and Parameters JavaScript function definitions do not specify an expected type for the function parameters, and function invocations do not do any type checking on the argument values you pass. In fact, JavaScript function invocations do not even check the number of arguments being passed. The subsections that follow describe what happens when a function is invoked with fewer arguments than declared parameters or with more arguments than declared parameters. They also demonstrate how you can explicitly test the type of function arguments if you need to ensure that a function is not invoked with inappropriate arguments. JavaScript 中的函数定义并未指定函数形参的类型，函数调用也未对传入的实参值做任何类型检查。实际上，JavaScript 函数调用甚至不检查传入形参的个数。下面几节将会讨论当调用函数时的实参个数和声明的形参个数不匹配时出现的状况，同样介绍了如何显式测试函数实参的类型，以避免非法的实参传入函数。 ","date":"2020-11-02","objectID":"/posts/ch8/:3:0","tags":null,"title":"第 8 章 函数","uri":"/posts/ch8/"},{"categories":null,"content":"8.3.1 Optional Parameters and Defaults When a function is invoked with fewer arguments than declared parameters, the additional parameters are set to their default value, which is normally undefined. It is often useful to write functions so that some arguments are optional. Following is an example: 当调用函数的时候传入的实参比函数声明时指定的形参个数要少，剩下的形参都将设置为 undefined 值。所以一些参数设置成可选的是非常实用的。看下面这个例子： // Append the names of the enumerable properties of object o to the // array a, and return a. If a is omitted, create and return a new array. function getPropertyNames(o, a) { if (a === undefined) a = []; // If undefined, use a new array for(let property in o) a.push(property); return a; } // getPropertyNames() can be invoked with one or two arguments: let o = {x: 1}, p = {y: 2, z: 3}; // Two objects for testing let a = getPropertyNames(o); // a == [\"x\"]; get o's properties in a new array getPropertyNames(p, a); // a == [\"x\",\"y\",\"z\"]; add p's properties to it Instead of using an if statement in the first line of this function, you can use the || operator in this idiomatic way: 第一行代码中可以使用 || 运算符来代替一个 if 语句，这是一种习惯用法： a = a || []; Recall from §4.10.2 that the || operator returns its first argument if that argument is truthy and otherwise returns its second argument. In this case, if any object is passed as the second argument, the function will use that object. But if the second argument is omitted (or null or another falsy value is passed), a newly created empty array will be used instead. 回忆一下，§4.10.2 介绍了“||”运算符，如果第一个实参是真值的话就返回第一个实参；否则返回第二个实参。在这个场景下，如果作为第二个实参传入任意对象，那么函数就会使用这个对象。如果省略掉第二个实参（或者传递 null 以及其他任何假值），那么就新创建一个空数组，并赋值给 a。 Note that when designing functions with optional arguments, you should be sure to put the optional ones at the end of the argument list so that they can be omitted. The programmer who calls your function cannot omit the first argument and pass the second: they would have to explicitly pass undefined as the first argument. 需要注意的是，当用这种可选实参来实现函数时，需要将可选实参放在实参列表的最后。那些调用你的函数的程序员是没办法省略第一个实参并传入第二个实参，他们必须显地的将 undefined 传入作为第一个实参 。 In ES6 and later, you can define a default value for each of your function parameters directly in the parameter list of your function. Simply follow the parameter name with an equals sign and the default value to use when no argument is supplied for that parameter: 在 ES6 之后，可以直接在函数的参数列表中为每个函数参数定义默认值。直接在参数名后面接一个等号再接一个默认值（用于没有实参提供给参数时参数的值）： // Append the names of the enumerable properties of object o to the // array a, and return a. If a is omitted, create and return a new array. function getPropertyNames(o, a = []) { for(let property in o) a.push(property); return a; } Parameter default expressions are evaluated when your function is called, not when it is defined, so each time this getPropertyNames() function is invoked with one argument, a new empty array is created and passed.2 It is probably easiest to reason about functions if the parameter defaults are constants (or literal expressions like [] and {}). But this is not required: you can use variables, or function invocations, for example, to compute the default value of a parameter. One interesting case is that, for functions with multiple parameters, you can use the value of a previous parameter to define the default value of the parameters that follow it: 默认参数表达式只有在函数调用时进行计算，而不是在它定义时，所以每一次 getPropertyNames() 函数只传一个实参调用时，一个新的空数组被创建并传给参数。2 最容易理解的就是参数默认值是常量（或者字面量表达式 [] 和 {}）。但这并不是必须的：举个例子，你可以用变量或者函数调用，计算一个默认参数的值。一个很有趣的情况是，对于有多个参数的函数，可以用前面的参数值来定义后面的参数默认值。 // This function returns an object representing a rectangle's dimensions. // If only width is supplied, make it twice as high as it is wide. const rectangle = (width, height=width*2) =\u003e ({width, height}); rectangle(1) // =\u003e { width: 1, height: 2 } This code demonstrates that parameter defaults work with arrow functions. The same is true for method shorthand functions and all other forms of function definitions. 这段代码描述了箭头函数中的参数默认值。方法函数和其他形式的函数定义也是如此。 ","date":"2020-11-02","objectID":"/posts/ch8/:3:1","tags":null,"title":"第 8 章 函数","uri":"/posts/ch8/"},{"categories":null,"content":"8.3.2 Rest Parameters and Variable-Length Argument Lists Parameter defaults enable us to write functions that can be invoked with fewer arguments than parameters. Rest parameters enable the opposite case: they allow us to write functions that can be invoked with arbitrarily more arguments than parameters. Here is an example function that expects one or more numeric arguments and returns the largest one: 调用函数时允许传入的实参比函数声明时指定的形参个数少。剩余参数允许相反的情况：它允许我们在调用函数时，传入比型参多任意个数的实参。下面是一个可以传入一个或多个数值型实参的例子，并且返回其中最大的数： function max(first=-Infinity, ...rest) { let maxValue = first; // Start by assuming the first arg is biggest // Then loop through the rest of the arguments, looking for bigger for(let n of rest) { if (n \u003e maxValue) { maxValue = n; } } // Return the biggest return maxValue; } max(1, 10, 100, 2, 3, 1000, 4, 5, 6) // =\u003e 1000 A rest parameter is preceded by three periods, and it must be the last parameter in a function declaration. When you invoke a function with a rest parameter, the arguments you pass are first assigned to the non-rest parameters, and then any remaining arguments (i.e., the “rest” of the arguments) are stored in an array that becomes the value of the rest parameter. This last point is important: within the body of a function, the value of a rest parameter will always be an array. The array may be empty, but a rest parameter will never be undefined. (It follows from this that it is never useful—and not legal—to define a parameter default for a rest parameter.) 剩余参数由三个 . 开始，必须是函数声明的最后一个参数。调用有剩余参数的函数时，传递的实参先赋值给非剩余参数，然后其余所有的实参（也就是“剩余”实参）存储在一个数组中变成剩余参数的值，最后一点非常重要：在一个函数体中，剩余参数的值总是一个数组。这个数组可能是空的，但是剩余参数永远不会是 undefined。（因此，从不会给剩余参数设置默认值，并且这也是不合法的。） Functions like the previous example that can accept any number of arguments are called variadic functions, variable arity functions, or vararg functions. This book uses the most colloquial term, varargs, which dates to the early days of the C programming language. 类似这种函数可以接收任意个数的实参，这种函数也称为“不定实参函数”，这个术语源自古老的C语言。 Don’t confuse the … that defines a rest parameter in a function definition with the … spread operator, described in §8.3.4, which can be used in function invocations. 不要混淆 … 定义函数的剩余参数和 … 展开运算符，将在 §8.3.4 描述展开运算符在函数调用中的应用。 ","date":"2020-11-02","objectID":"/posts/ch8/:3:2","tags":null,"title":"第 8 章 函数","uri":"/posts/ch8/"},{"categories":null,"content":"8.3.3 The Arguments Object Rest parameters were introduced into JavaScript in ES6. Before that version of the language, varargs functions were written using the Arguments object: within the body of any function, the identifier arguments refers to the Arguments object for that invocation. The Arguments object is an array-like object (see §7.9) that allows the argument values passed to the function to be retrieved by number, rather than by name. Here is the max() function from earlier, rewritten to use the Arguments object instead of a rest parameter: 剩余参数是在 ES6 中加入的概念。在这之前，不定实参函数是用 Arguments 对象实现的：在函数体中，标识符 Arguments 是指向实参对象的引用。Arguments 对象是一个类数组对象（参照 §7.9），这样可以通过数字下标就能访问传入函数的实参值，而不用非要通过名字来得到实参。下面的 max() 函数就是以前用 Arguments 对象代替剩余参数的例子： function max(x) { let maxValue = -Infinity; // Loop through the arguments, looking for, and remembering, the biggest. for(let i = 0; i \u003c arguments.length; i++) { if (arguments[i] \u003e maxValue) maxValue = arguments[i]; } // Return the biggest return maxValue; } max(1, 10, 100, 2, 3, 1000, 4, 5, 6) // =\u003e 1000 The Arguments object dates back to the earliest days of JavaScript and carries with it some strange historical baggage that makes it inefficient and hard to optimize, especially outside of strict mode. You may still encounter code that uses the Arguments object, but you should avoid using it in any new code you write. When refactoring old code, if you encounter a function that uses arguments, you can often replace it with a …args rest parameter. Part of the unfortunate legacy of the Arguments object is that, in strict mode, arguments is treated as a reserved word, and you cannot declare a function parameter or a local variable with that name. Arguments 对象可追溯到 JavaScript 的最早时代，并带有一些奇怪的历史包袱，这使得它效率低下且难以优化，尤其是不在严格模式下。可能还会遇到一些代码使用 Arguments 对象，但是在编写新代码时要避免使用，可以用 … 剩余函数来替代。Arguments 对象还有部分令人遗憾的遗产，在严格模式下，arguments 被视为保留字，不能声明具有该名称的局部变量来定义函数的参数。 ","date":"2020-11-02","objectID":"/posts/ch8/:3:3","tags":null,"title":"第 8 章 函数","uri":"/posts/ch8/"},{"categories":null,"content":"8.3.4 The Spread Operator for Function Calls The spread operator … is used to unpack, or “spread out,” the elements of an array (or any other iterable object, such as strings) in a context where individual values are expected. We’ve seen the spread operator used with array literals in §7.1.2. The operator can be used, in the same way, in function invocations: 当需要单个值时，… 展开运算符用来拆包，或者说将元素从数组（或者其他的任何和迭代对象，例如字符串）中“展开”到上下文。我们已经在 §7.1.2 见到了展开运算符在数组字面量上的使用。展开运算符可以在函数调用中以同样方式使用： let numbers = [5, 2, 10, -1, 9, 100, 1]; Math.min(...numbers) // =\u003e -1 Note that … is not a true operator in the sense that it cannot be evaluated to produce a value. Instead, it is a special JavaScript syntax that can be used in array literals and function invocations. 注意 … 不是一个真正的运算符，因为它不能通过计算来提供一个值。它是一个可以用在数组字面量和函数调用中的特殊的 JavaScript 语法。 When we use the same … syntax in a function definition rather than a function invocation, it has the opposite effect to the spread operator. As we saw in §8.3.2, using … in a function definition gathers multiple function arguments into an array. Rest parameters and the spread operator are often useful together, as in the following function, which takes a function argument and returns an instrumented version of the function for testing: 在函数定义和函数调用中使用相同的 … 语法时，和展开运算符有着相仿的效果。在 §8.3.2 中我们看到函数定义使用 … 将复数个函数实参合并到一个数组中。剩余参数和展开运算符经常一同使用，就像下面这个函数： // This function takes a function and returns a wrapped version function timed(f) { return function(...args) { // Collect args into a rest parameter array console.log(`Entering function ${f.name}`); let startTime = Date.now(); try { // Pass all of our arguments to the wrapped function return f(...args); // Spread the args back out again } finally { // Before we return the wrapped return value, print elapsed time. console.log(`Exiting ${f.name}after ${Date.now()-startTime}ms`); } }; } // Compute the sum of the numbers between 1 and n by brute force function benchmark(n) { let sum = 0; for(let i = 1; i \u003c= n; i++) sum += i; return sum; } // Now invoke the timed version of that test function timed(benchmark)(1000000) // =\u003e 500000500000; this is the sum of the numbers ","date":"2020-11-02","objectID":"/posts/ch8/:3:4","tags":null,"title":"第 8 章 函数","uri":"/posts/ch8/"},{"categories":null,"content":"8.3.5 Destructuring Function Arguments into Parameters When you invoke a function with a list of argument values, those values end up being assigned to the parameters declared in the function definition. This initial phase of function invocation is a lot like variable assignment. So it should not be surprising that we can use the techniques of destructuring assignment (see §3.10.3) with functions. 用实参列表调用函数时，实参的值最终赋值给函数定义的参数。函数调用初始化阶段非常像变量赋值。所以我们不必惊讶于可以将解构赋值（见 §3.10.3）用于函数。 If you define a function that has parameter names within square brackets, you are telling the function to expect an array value to be passed for each pair of square brackets. As part of the invocation process, the array arguments will be unpacked into the individually named parameters. As an example, suppose we are representing 2D vectors as arrays of two numbers, where the first element is the X coordinate and the second element is the Y coordinate. With this simple data structure, we could write the following function to add two vectors: 如果一个函数的参数带有方括号，就说明函数要给每一个方括号传一个数组。在一个调用进程中，数组实参会被拆包传递给对应的参数。例如，假设我们将 2D 矢量表示为两个数字的数组，其中第一个元素是 X 坐标，第二个元素是 Y 坐标。用这个简单的数据结构，编写下面这个函数计算两个矢量的和： function vectorAdd(v1, v2) { return [v1[0] + v2[0], v1[1] + v2[1]]; } vectorAdd([1,2], [3,4]) // =\u003e [4,6] The code would be easier to understand if we destructured the two vector arguments into more clearly named parameters: 如果下面这种方式解构这两个矢量实参，这段代码将更容易理解： function vectorAdd([x1,y1], [x2,y2]) { // Unpack 2 arguments into 4 parameters return [x1 + x2, y1 + y2]; } vectorAdd([1,2], [3,4]) // =\u003e [4,6] Similarly, if you are defining a function that expects an object argument, you can destructure parameters of that object. Let’s use a vector example again, except this time, let’s suppose that we represent vectors as objects with x and y parameters: 同样，如果定义一个函数时需要对象实参，你能对这个对象进行参数解构。再次实用矢量的例子，这一次，我们用 x 和 y 参数包装成对象来描述矢量： // Multiply the vector {x,y} by a scalar value function vectorMultiply({x, y}, scalar) { return { x: x*scalar, y: y*scalar }; } vectorMultiply({x: 1, y: 2}, 2) // =\u003e {x: 2, y: 4} This example of destructuring a single object argument into two parameters is a fairly clear one because the parameter names we use match the property names of the incoming object. The syntax is more verbose and more confusing when you need to destructure properties with one name into parameters with different names. Here’s the vector addition example, implemented for object-based vectors: 这个例子将一个简单的对象实参解构成两个参数是很简单的，因为参数的名字和我们在对象中使用的属性名是匹配的。当您需要将同一个名称的属性解构为具有不同名称的参数时，语法更加冗长和难懂。下面是一个矢量加法的例子，基于对象矢量的实现： function vectorAdd( {x: x1, y: y1}, // Unpack 1st object into x1 and y1 params {x: x2, y: y2} // Unpack 2nd object into x2 and y2 params ) { return { x: x1 + x2, y: y1 + y2 }; } vectorAdd({x: 1, y: 2}, {x: 3, y: 4}) // =\u003e {x: 4, y: 6} The tricky thing about destructuring syntax like {x:x1, y:y1} is remembering which are the property names and which are the parameter names. The rule to keep in mind for destructuring assignment and destructuring function calls is that the variables or parameters being declared go in the spots where you’d expect values to go in an object literal. So property names are always on the lefthand side of the colon, and the parameter (or variable) names are on the right. 像 {x:x1, y:y1} 的解构语法棘手的是记住哪一个是属性名哪一个是参数名。牢记解构赋值和解构函数调用的规则，声明的变量或参数在对象字面量中的位置固定。属性名总是在冒号的左边，参数（或变量）名在右边。 You can define parameter defaults with destructured parameters. Here’s vector multiplication that works with 2D or 3D vectors: 可以使用解构参数定义参数默认值。下面是适用于 2D 或 3D 矢量的矢量乘法： // Multiply the vector {x,y} or {x,y,z} by a scalar value function vectorMultiply({x, y, z=0}, scalar) { return { x: x*scalar, y: y*scalar, z: z*scalar }; } vectorMultiply({x: 1, y: 2}, 2) // =\u003e {x: 2, y: 4, z: 0} Some languages (like Python) allow the caller of a function to invoke a function with arguments specified in name=value form, which is convenient when there are many optional arguments or when the parameter list is long enough that it is har","date":"2020-11-02","objectID":"/posts/ch8/:3:5","tags":null,"title":"第 8 章 函数","uri":"/posts/ch8/"},{"categories":null,"content":"8.3.6 Argument Types JavaScript method parameters have no declared types, and no type checking is performed on the values you pass to a function. You can help make your code self-documenting by choosing descriptive names for function arguments and by documenting them carefully in the comments for each function. (Alternatively, see §17.8 for a language extension that allows you to layer type checking on top of regular JavaScript.) JavaScript 方法的形参并未声明类型，在形参传入函数体之前也未做任何类型检查。可以采用语义化的单词来给函数实参命名，并在函数注释给每一个实参详细描述，以此使代码自文本化。 As described in §3.9, JavaScript performs liberal type conversion as needed. So if you write a function that expects a string argument and then call that function with a value of some other type, the value you passed will simply be converted to a string when the function tries to use it as a string. All primitive types can be converted to strings, and all objects have toString() methods (if not necessarily useful ones), so an error never occurs in this case. §3.9 已经提到，JavaScript 在必要时会进行类型转换。因此如果函数期 望接收一个字符串实参，而调用函数时传入其他类型的值，所传入的值会在函数体内将其用做字符串的地方转换为字符串类型。所有的原始类型都可以转换为字符串，所有的对象都包含 toString() 方法（尽管不一定有用），所以这种场景下是不会有任何错误的。 This is not always true, however. Consider again the arraycopy() method shown earlier. It expects one or two array arguments and will fail if these arguments are of the wrong type. Unless you are writing a private function that will only be called from nearby parts of your code, it may be worth adding code to check the types of arguments like this. It is better for a function to fail immediately and predictably when passed bad values than to begin executing and fail later with an error message that is likely to be unclear. Here is an example function that performs type-checking: 然而事情不总是这样，回头看一下刚才提到的 arraycopy() 方法。这个方法期望获得一个或两个实参，并且这些实参的类型错误会导致函数执行失败。除非所写的私有函数只会被附近的代码调用，你应当添加类似的实参类型检查逻辑。因为宁愿程序在传入非法值时报错，也不愿非法值导致程序在执行时报错，相比而言，逻辑执行时的报错消息不甚清晰且更难处理。下面这个例子中的函数就做了这种类型检查： // Return the sum of the elements an iterable object a. // The elements of a must all be numbers. function sum(a) { let total = 0; for(let element of a) { // Throws TypeError if a is not iterable if (typeof element !== \"number\") { throw new TypeError(\"sum(): elements must be numbers\"); } total += element; } return total; } sum([1,2,3]) // =\u003e 6 sum(1, 2, 3); // !TypeError: 1 is not iterable sum([1,2,\"3\"]); // !TypeError: element 2 is not a number ","date":"2020-11-02","objectID":"/posts/ch8/:3:6","tags":null,"title":"第 8 章 函数","uri":"/posts/ch8/"},{"categories":null,"content":"8.4 Functions as Values The most important features of functions are that they can be defined and invoked. Function definition and invocation are syntactic features of JavaScript and of most other programming languages. In JavaScript, however, functions are not only syntax but also values, which means they can be assigned to variables, stored in the properties of objects or the elements of arrays, passed as arguments to functions, and so on.3 函数可以定义，也可以调用，这是函数最重要的特性。函数定义和调用是 JavaScript 的词法特性，对于其他大多数编程语言来说亦是如此。然而在 JavaScript 中，函数不仅是一种语法，也是值，也就是说，可以将函数赋值给变量，存储在对象的属性或数组的元素中，作为参数传入另外一个函数等。3 To understand how functions can be JavaScript data as well as JavaScript syntax, consider this function definition: 为了便于理解 JavaScript 中的函数是如何用做 Javascript 数据以及 JavaScript 语法的，来看一下这样一个函数定义： function square(x) { return x*x; } This definition creates a new function object and assigns it to the variable square. The name of a function is really immaterial; it is simply the name of a variable that refers to the function object. The function can be assigned to another variable and still work the same way: 这个定义创建一个新的函数对象，并将其赋值给变量 square。函数的名字实际上是无形的，它（square）仅仅是变量的名称，这个变量是函数对象的引用。函数还可以赋值给其他的变量，并且仍可以正常工作： let s = square; // Now s refers to the same function that square does square(4) // =\u003e 16 s(4) // =\u003e 16 Functions can also be assigned to object properties rather than variables. As we’ve already discussed, we call the functions “methods” when we do this: 除了可以将函数赋值给变量，同样可以将函数赋值给对象的属性。当函数作为对象的属性调用时，函数就称为“方法”： let o = {square: function(x) { return x*x; }}; // An object literal let y = o.square(16); // y == 256 Functions don’t even require names at all, as when they’re assigned to array elements: 函数甚至不需要带名字，就像把它们赋值给数组元素： let a = [x =\u003e x*x, 20]; // An array literal a[0](a[1]) // =\u003e 400 The syntax of this last example looks strange, but it is still a legal function invocation expression! 上面的例子看起来很奇怪，但的确是合法的函数调用表达式！ As an example of how useful it is to treat functions as values, consider the Array.sort() method. This method sorts the elements of an array. Because there are many possible orders to sort by (numerical order, alphabetical order, date order, ascending, descending, and so on), the sort() method optionally takes a function as an argument to tell it how to perform the sort. This function has a simple job: for any two values it is passed, it returns a value that specifies which element would come first in a sorted array. This function argument makes Array.sort() perfectly general and infinitely flexible; it can sort any type of data into any conceivable order. Examples are shown in §7.8.6. 举一个例子来说明将函数当作值来对待的益处，考虑下 Array.sort() 方法。这个方法用来对数组元素进行排序。因为排序的规则有很多（基于数值大小、字母表顺序、日期大小、从小到大、从大到小等），sort() 方法可以接收一个函数作为参数，用来处理具体的排序操作。这个函数的作用非常简单：对于任意两个值都返回一个值，以指定它们在排序后的数组中的先后顺序。这个函数参数使得 Array.sort() 具有更完美的通用性和无限可扩展性，它可以对任何类型的数据进行任意排序。§7.8.6 有示例代码。 Example 8-1 demonstrates the kinds of things that can be done when functions are used as values. This example may be a little tricky, but the comments explain what is going on. 示例 8-1 展示了将函数用做值时的一些例子，这段代码可能会难读一些，但注释解释了代码的具体含义： Example 8-1. Using functions as data 示例 8-1：用函数做值 // We define some simple functions here function add(x,y) { return x + y; } function subtract(x,y) { return x - y; } function multiply(x,y) { return x * y; } function divide(x,y) { return x / y; } // Here's a function that takes one of the preceding functions // as an argument and invokes it on two operands function operate(operator, operand1, operand2) { return operator(operand1, operand2); } // We could invoke this function like this to compute the value (2+3) + (4*5): let i = operate(add, operate(add, 2, 3), operate(multiply, 4, 5)); // For the sake of the example, we implement the simple functions again, // this time within an object literal; const operators = { add: (x,y) =\u003e x+y, subtract: (x,y) =\u003e x-y, multiply: (x,y) =\u003e x*y, divide: (x,y) =\u003e x/y, pow: Math.pow // This works for predefined functions too }; // This function takes the name of an o","date":"2020-11-02","objectID":"/posts/ch8/:4:0","tags":null,"title":"第 8 章 函数","uri":"/posts/ch8/"},{"categories":null,"content":"8.4.1 Defining Your Own Function Properties Functions are not primitive values in JavaScript, but a specialized kind of object, which means that functions can have properties. When a function needs a “static” variable whose value persists across invocations, it is often convenient to use a property of the function itself. For example, suppose you want to write a function that returns a unique integer whenever it is invoked. The function must never return the same value twice. In order to manage this, the function needs to keep track of the values it has already returned, and this information must persist across function invocations. You could store this information in a global variable, but that is unnecessary, because the information is used only by the function itself. It is better to store the information in a property of the Function object. Here is an example that returns a unique integer whenever it is called: JavaScript 中的函数并不是原始值，而是一种特殊的对象，也就是说，函数可以拥有属性。当函数需要一个“静态”变量来在调用时保持某个值不变，最方便的方式就是给函数定义属性，而不是定义全局变量，显然定义全局变量会让命名空间变得更加杂乱无章。比如，假设你想写一个返回一个唯一整数的函数，不管在哪里调用函数都会返回这个整数。而函数不能两次返回同一个值，为了做到这一点，函数必须能够跟踪它每次返回的值，而且这些值的信息需要在不同的函数调过程中持久化。可以将这些信息存放到全局变量中，但这并不是必需的，因为这个信息仅仅是函数本身用到的。最好将这个信息保存到函数对象的一个属性中，下面这个例子就实现了这样一个函数，每次调用函数都会返回一个唯一的整数： // Initialize the counter property of the function object. // Function declarations are hoisted so we really can // do this assignment before the function declaration. uniqueInteger.counter = 0; // This function returns a different integer each time it is called. // It uses a property of itself to remember the next value to be returned. function uniqueInteger() { return uniqueInteger.counter++; // Return and increment counter property } uniqueInteger() // =\u003e 0 uniqueInteger() // =\u003e 1 As another example, consider the following factorial() function that uses properties of itself (treating itself as an array) to cache previously computed results: 来看另外一个例子，下面这个函数 factorial() 使用了自身的属性（将自身当做数组来对待）来缓存上一次的计算结果： // Compute factorials and cache results as properties of the function itself. function factorial(n) { if (Number.isInteger(n) \u0026\u0026 n \u003e 0) { // Positive integers only if (!(n in factorial)) { // If no cached result factorial[n] = n * factorial(n-1); // Compute and cache it } return factorial[n]; // Return the cached result } else { return NaN; // If input was bad } } factorial[1] = 1; // Initialize the cache to hold this base case. factorial(6) // =\u003e 720 factorial[5] // =\u003e 120; the call above caches this value ","date":"2020-11-02","objectID":"/posts/ch8/:4:1","tags":null,"title":"第 8 章 函数","uri":"/posts/ch8/"},{"categories":null,"content":"8.5 Functions as Namespaces Variables declared within a function are not visible outside of the function. For this reason, it is sometimes useful to define a function simply to act as a temporary namespace in which you can define variables without cluttering the global namespace. 变量声明在函数内对于函数体外是不可见的。因此，有时定义函数作为临时命名空间非常有用，您可以在其中定义变量而不弄乱全局命名空间。 Suppose, for example, you have a chunk of JavaScript code that you want to use in a number of different JavaScript programs (or, for client-side JavaScript, on a number of different web pages). Assume that this code, like most code, defines variables to store the intermediate results of its computation. The problem is that since this chunk of code will be used in many different programs, you don’t know whether the variables it creates will conflict with variables created by the programs that use it. The solution is to put the chunk of code into a function and then invoke the function. This way, variables that would have been global become local to the function: 比如，假设你写了一段 JavaScript 模块代码，这段代码将要用在不同的 JavaScript 程序中（对于客户端 JavaScript 来讲通常是用在各种各样的网页中）。和大多数代码一样，假定这段代码定义了一个用以存储中间计算结果的变量。这样问题就来了，当模块代码放到不同的程序中运行时，你无法得知这个变量是否已经创建了，如果已经存在这个变量，那么将会和代码发生冲突。解决办法当然是将代码放入一个函数内，然后调用这个函数。这样全局变量就变成了函数内的局部变量： function chunkNamespace() { // Chunk of code goes here // Any variables defined in the chunk are local to this function // instead of cluttering up the global namespace. } chunkNamespace(); // But don't forget to invoke the function! This code defines only a single global variable: the function name chunkNamespace. If defining even a single property is too much, you can define and invoke an anonymous function in a single expression: 这段代码仅仅定义了一个单独的全局变量：名为 chunkNamespace 的函数。如果还是太麻烦，可以用一个单独的表达式定义一个匿名函数并调用它： (function() { // chunkNamespace() function rewritten as an unnamed expression. // Chunk of code goes here }()); // End the function literal and invoke it now. This technique of defining and invoking a function in a single expression is used frequently enough that it has become idiomatic and has been given the name “immediately invoked function expression.” Note the use of parentheses in the previous code example. The open parenthesis before function is required because without it, the JavaScript interpreter tries to parse the function keyword as a function declaration statement. With the parenthesis, the interpreter correctly recognizes this as a function definition expression. The leading parenthesis also helps human readers recognize when a function is being defined to be immediately invoked instead of defined for later use. 这种定义匿名函数并立即在单个表达式中调用它的写法非常常见，并给它起了个名字“匿名调用函数表达式”。注意上面代码的圆括号的用法，function 之前的左圆括号是必需的，因为如果不写这个左圆括号，JavaScript 解释器会试图将关键字 function 解析为函数声明语句。使用圆括号 JavaScript 解释器才会正确地将其解析为函数定义表达式。使用前导括号也有助于人类阅读时区分函数定义是立即执行还是供以后使用。 This use of functions as namespaces becomes really useful when we define one or more functions inside the namespace function using variables within that namesapce, but then pass them back out as the return value of the namespace function. Functions like this are known as closures, and they’re the topic of the next section. 函数用作命名空间很常用，在命名空间函数中定义一个或多个函数使用其中的变量，然后将他们作为函数命名空间的返回值。这样的函数称为闭包，它们是下一节的主题。 ","date":"2020-11-02","objectID":"/posts/ch8/:5:0","tags":null,"title":"第 8 章 函数","uri":"/posts/ch8/"},{"categories":null,"content":"8.6 Closures Like most modern programming languages, JavaScript uses lexical scoping. This means that functions are executed using the variable scope that was in effect when they were defined, not the variable scope that is in effect when they are invoked. In order to implement lexical scoping, the internal state of a JavaScript function object must include not only the code of the function but also a reference to the scope in which the function definition appears. This combination of a function object and a scope (a set of variable bindings) in which the function’s variables are resolved is called a closure in the computer science literature. 和其他大多数现代编程语言一样，JavaScript 也采用词法作用域。也就是说，函数的执行依赖于变量作用域，这个作用域是在函数定义时决定的，而不是函数调用时决定的。为了实现这种词法作用域，JavaScript 函数对象的内部状态不仅包含函数的代码逻辑，还必须包括对函数定义出现的作用域的引用。将函数对象可和作用域相互关联起来（一对变量的绑定），函数体内部的变量都可以保存在函数作用域内，这种特性在计算机科学文献中称为闭包。 Technically, all JavaScript functions are closures, but because most functions are invoked from the same scope that they were defined in, it normally doesn’t really matter that there is a closure involved. Closures become interesting when they are invoked from a different scope than the one they were defined in. This happens most commonly when a nested function object is returned from the function within which it was defined. There are a number of powerful programming techniques that involve this kind of nested function closures, and their use has become relatively common in JavaScript programming. Closures may seem confusing when you first encounter them, but it is important that you understand them well enough to use them comfortably. 从技术的角度讲，所有的 JavaScript 函数都是闭包，但是大多数函数调用和定义在同一个作用域内，通常不会注意这里有涉及到闭包。当调用函数不和其定义处于同一作用域内时，事情就变得非常微妙。当一个函数嵌套了另外一个函数，外部函数将嵌套的函数对象作为返回值返回的时候往往会发生这种事情。有很多强大的编程技术都利用到了这类嵌套的函数闭包，以至于这种编程模式在 JavaScript 中非常常见。当你第一次碰到闭包时可能会觉得非常让人费解，一旦你理解掌握了闭包之后，就能非常自如地使用它了，了解这一点至关重要。 The first step to understanding closures is to review the lexical scoping rules for nested functions. Consider the following code: 理解闭包首先要了解嵌套函数的词法作用域规则。看一下这段代码： let scope = \"global scope\"; // A global variable function checkscope() { let scope = \"local scope\"; // A local variable function f() { return scope; } // Return the value in scope here return f(); } checkscope() // =\u003e \"local scope\" The checkscope() function declares a local variable and then defines and invokes a function that returns the value of that variable. It should be clear to you why the call to checkscope() returns “local scope”. Now, let’s change the code just slightly. Can you tell what this code will return? checkscope() 函数声明了一个局部变量，然后定义并执行了一个函数 f() ，函数 f() 返回了这个变量的值，最后将函数 f() 的执行结果返回。你应当非常清楚为什么调用 checkscope() 会返回 local scope。现在我们对这段代码做一点改动。你知道这段代码返回什么吗？ let scope = \"global scope\"; // A global variable function checkscope() { let scope = \"local scope\"; // A local variable function f() { return scope; } // Return the value in scope here return f; } let s = checkscope()(); // What does this return? In this code, a pair of parentheses has moved from inside checkscope() to outside of it. Instead of invoking the nested function and returning its result, checkscope() now just returns the nested function object itself. What happens when we invoke that nested function (with the second pair of parentheses in the last line of code) outside of the function in which it was defined? 在这段代码中，我们将函数内的一对圆括号移动到了 checkscope() 之后。checkscope() 现在仅仅返回函数内嵌套的一个函数对象，而不是直接返回结果。在定义函数的作用域外面，调用这个嵌套的函数（包含最后一行代码的最后一对圆括号）会发生什么事情呢？ Remember the fundamental rule of lexical scoping: JavaScript functions are executed using the scope they were defined in. The nested function f() was defined in a scope where the variable scope was bound to the value “local scope”. That binding is still in effect when f is executed, no matter where it is executed from. So the last line of the preceding code example returns “local scope”, not “global scope”. This, in a nutshell, is the surprising and powerful nature of closures: they capture the local variable (and parameter) bindings","date":"2020-11-02","objectID":"/posts/ch8/:6:0","tags":null,"title":"第 8 章 函数","uri":"/posts/ch8/"},{"categories":null,"content":"8.7 Function Properties, Methods, and Constructor We’ve seen that functions are values in JavaScript programs. The typeof operator returns the string “function” when applied to a function, but functions are really a specialized kind of JavaScript object. Since functions are objects, they can have properties and methods, just like any other object. There is even a Function() constructor to create new function objects. The subsections that follow document the length, name, and prototype properties; the call(), apply(), bind(), and toString() methods; and the Function() constructor. 我们看到在 JavaScript 程序中，函数是值。对函数执行 typeof 运算会返回字符串“function”，但是函数是 JavaScript 中特殊的对象。因为函数也是对象，它们也可以拥有属性和方法，就像普通的对象可以拥有属性和方法一样。甚至可以用 Function() 构造函数来创建新的函数对象。接下来几节就会着重介绍函数 length、name 和 prototype 属性；call()、 apply()、 bind() 和 toString() 方法；以及 Function() 构造函数。 ","date":"2020-11-02","objectID":"/posts/ch8/:7:0","tags":null,"title":"第 8 章 函数","uri":"/posts/ch8/"},{"categories":null,"content":"8.7.1 The length Property The read-only length property of a function specifies the arity of the function—the number of parameters it declares in its parameter list, which is usually the number of arguments that the function expects. If a function has a rest parameter, that parameter is not counted for the purposes of this length property. 函数的只读属性 length 指定函数参数个数–声明在其参数列表中的参数个数，大多数函数期望的实参个数。如果一个函数有一个剩余函数，它的参数个数不被计算入 length 属性。（经测试，可选参数也不计算 length。） ","date":"2020-11-02","objectID":"/posts/ch8/:7:1","tags":null,"title":"第 8 章 函数","uri":"/posts/ch8/"},{"categories":null,"content":"8.7.2 The name Property The read-only name property of a function specifies the name that was used when the function was defined, if it was defined with a name, or the name of the variable or property that an unnamed function expression was assigned to when it was first created. This property is primarily useful when writing debugging or error messages. 如果使用名称定义函数，只读属性 name 指定函数定义时用的名称，或未命名函数表达式在首次创建时分配给的变量或属性的名称。此属性在编写调试或错误消息时很有用。 ","date":"2020-11-02","objectID":"/posts/ch8/:7:2","tags":null,"title":"第 8 章 函数","uri":"/posts/ch8/"},{"categories":null,"content":"8.7.3 The prototype Property All functions, except arrow functions, have a prototype property that refers to an object known as the prototype object. Every function has a different prototype object. When a function is used as a constructor, the newly created object inherits properties from the prototype object. Prototypes and the prototype property were discussed in §6.2.3 and will be covered again in Chapter 9. 所有函数都包含一个 prototype 属性，这个属性是指向一个对象的引用，这个对象称做原型对象。每一个函数都包含不同的原型对象。当将函数用作构造函数的时候，新创建的对象会从原型对象上继承属性。§6.2.3 讨论了原型和 prototype 属性，在第 9 章里会有进一步讨论。 ","date":"2020-11-02","objectID":"/posts/ch8/:7:3","tags":null,"title":"第 8 章 函数","uri":"/posts/ch8/"},{"categories":null,"content":"8.7.4 The call() and apply() Methods call() and apply() allow you to indirectly invoke (§8.2.4) a function as if it were a method of some other object. The first argument to both call() and apply() is the object on which the function is to be invoked; this argument is the invocation context and becomes the value of the this keyword within the body of the function. To invoke the function f() as a method of the object o (passing no arguments), you could use either call() or apply(): 我们可以将 call() 和 apply () 看做是某个对象的方法，通过调用方法的形式来间接调用（见 §8.2.4）函数。call() 和 apply() 的第一个实参是要调用函数的母对象，它是调用上下文，在函数体内变成 this 关键字的值。要想以对象 o 的方法来调用函数 f()（没有实参传递），可以这样使用 call() 和 apply()： f.call(o); f.apply(o); Either of these lines of code are similar to the following (which assume that o does not already have a property named m): 每行代码和下面代码的功能类似（假设对象 o 中预先不存在名为 m 的属性）: o.m = f; // Make f a temporary method of o. o.m(); // Invoke it, passing no arguments. delete o.m; // Remove the temporary method. Remember that arrow functions inherit the this value of the context where they are defined. This cannot be overridden with the call() and apply() methods. If you call either of those methods on an arrow function, the first argument is effectively ignored. 不要忘了，箭头函数从它定义的位置的上下文继承 this 值。这不能被 call() 和 apply() 方法重写。如果通过箭头函数调用它俩任何一个方法，第一个实参实际上都被忽略。 Any arguments to call() after the first invocation context argument are the values that are passed to the function that is invoked (and these arguments are not ignored for arrow functions). For example, to pass two numbers to the function f() and invoke it as if it were a method of the object o, you could use code like this: 对于 call() 来说，除了第一个作为调用上下文实参，之后的所有实参就是要传入待调用函数的值（并且，这部分实参对于箭头函数来说不被忽略）。比如，以对象 o 的方法的形式调用函数 f()，并传入两个数，可以使用这样的代码： f.call(o, 1, 2); The apply() method is like the call() method, except that the arguments to be passed to the function are specified as an array: apply() 方法和 call() 类似，但传入实参的形式和 call() 有所不同，它的实参都放入一个数组中： f.apply(o, [1,2]); If a function is defined to accept an arbitrary number of arguments, the apply() method allows you to invoke that function on the contents of an array of arbitrary length. In ES6 and later, we can just use the spread operator, but you may see ES5 code that uses apply() instead. For example, to find the largest number in an array of numbers without using the spread operator, you could use the apply() method to pass the elements of the array to the Math.max() function: 如果一个函数的实参可以是任意数量，用 apply() 方法允许你传入的参数数组可以是任意长度的。在 ES6 之后，我们可以用展开运算符，但是在 ES5 的代码中你可以看到这种情况是用 apply() 来替代。比如，不用展开运算符找出数组中最大的数值元素，调用 Math.max() 方法的时候可以给 apply() 传入一个包含任意个元素的数组： let biggest = Math.max.apply(Math, arrayOfNumbers); The trace() function defined in the following is similar to the timed() function defined in §8.3.4, but it works for methods instead of functions. It uses the apply() method instead of a spread operator, and by doing that, it is able to invoke the wrapped method with the same arguments and the same this value as the wrapper method: 下面定义的 trace() 与 §8.3.4 中定义的 timed() 函数类似，但是它对方法有效而不是函数。它使用 apply() 方法而不是展开运算符，通过这样做，它能够调用具有相同参数和与被包装方法相同的 this 值的包装方法。 // Replace the method named m of the object o with a version that logs // messages before and after invoking the original method. function trace(o, m) { let original = o[m]; // Remember original method in the closure. o[m] = function(...args) { // Now define the new method. console.log(new Date(), \"Entering:\", m); // Log message. let result = original.apply(this, args); // Invoke original. console.log(new Date(), \"Exiting:\", m); // Log message. return result; // Return result. }; } ","date":"2020-11-02","objectID":"/posts/ch8/:7:4","tags":null,"title":"第 8 章 函数","uri":"/posts/ch8/"},{"categories":null,"content":"8.7.5 The bind() Method The primary purpose of bind() is to bind a function to an object. When you invoke the bind() method on a function f and pass an object o, the method returns a new function. Invoking the new function (as a function) invokes the original function f as a method of o. Any arguments you pass to the new function are passed to the original function. For example: bind() 方法的主要作用就是将函数绑定至某个对象。当在函数 f() 上调用 bind() 方法并传入一个对象 o 作为参数，这个方法将返回一个新的函数。（以函数调用的方式）调用新的函数将会把原始的函数 f() 当做 o 的方法来调用。传入新函数的任何实参都将传入原始函数，比如： function f(y) { return this.x + y; } // This function needs to be bound let o = { x: 1 }; // An object we'll bind to let g = f.bind(o); // Calling g(x) invokes f() on o g(2) // =\u003e 3 let p = { x: 10, g }; // Invoke g() as a method of this object p.g(2) // =\u003e 3: g is still bound to o, not p. Arrow functions inherit their this value from the environment in which they are defined, and that value cannot be overridden with bind(), so if the function f() in the preceding code was defined as an arrow function, the binding would not work. The most common use case for calling bind() is to make non-arrow functions behave like arrow functions, however, so this limitation on binding arrow functions is not a problem in practice. 箭头函数从它们定义的上下文中继承 this 值，并且其不可被 bind() 方法重写，所以如果上面的代码用箭头函数定义函数 f()，这个绑定不会生效。调用 bind() 方法的最常用场景是让不带箭头的函数的行为像箭头函数一样，所以实际上绑定箭头函数的 this 局限性并不是一个问题。 The bind() method does more than just bind a function to an object, however. It can also perform partial application: any arguments you pass to bind() after the first are bound along with the this value. This partial application feature of bind() does work with arrow functions. Partial application is a common technique in functional programming and is sometimes called currying. Here are some examples of the bind() method used for partial application: 但是 bind() 方法不仅仅是将函数绑定至一个对象。它还附带一些其他应用：除了第一个实参之外，传入 bind() 的实参也会绑定至 this 值。这个附带的应用在箭头函数上也同样生效。是一种常见的函数式编程技术，有时也被称为“柯里化”。参照下面这个例子中的 bind() 方法的实现： let sum = (x,y) =\u003e x + y; // Return the sum of 2 args let succ = sum.bind(null, 1); // Bind the first argument to 1 succ(2) // =\u003e 3: x is bound to 1, and we pass 2 for the y argument function f(y,z) { return this.x + y + z; } let g = f.bind({x: 1}, 2); // Bind this and y g(3) // =\u003e 6: this.x is bound to 1, y is bound to 2 and z is 3 The name property of the function returned by bind() is the name property of the function that bind() was called on, prefixed with the word “bound”. bind() 返回函数的名称属性是调用 bind() 的函数的名称属性前面加上前缀为单词\"bound”。 ","date":"2020-11-02","objectID":"/posts/ch8/:7:5","tags":null,"title":"第 8 章 函数","uri":"/posts/ch8/"},{"categories":null,"content":"8.7.6 The toString() Method Like all JavaScript objects, functions have a toString() method. The ECMAScript spec requires this method to return a string that follows the syntax of the function declaration statement. In practice, most (but not all) implementations of this toString() method return the complete source code for the function. Built-in functions typically return a string that includes something like “[native code]” as the function body. 和所有的 JavaScript 对象一样，函数也有 toString() 方法，ECMAScript 规范规定这个方法返回一个字符串，这个字符串和函数声明语句的语法相关。实际上，大多数（非全部）的 toString() 方法的实现都返回函数的完整源码。内置函数往往返回一个类似”[native code]”的字符串作为函数体。 ","date":"2020-11-02","objectID":"/posts/ch8/:7:6","tags":null,"title":"第 8 章 函数","uri":"/posts/ch8/"},{"categories":null,"content":"8.7.7 The Function() Constructor Because functions are objects, there is a Function() constructor that can be used to create new functions: 因为函数是对象，有一个 Function() 构造函数可以用来创建新的函数： const f = new Function(\"x\", \"y\", \"return x*y;\"); This line of code creates a new function that is more or less equivalent to a function defined with the familiar syntax: 这一行代码创建一个新的函数，这个函数和通过下面代码定义的函数几乎等价： const f = function(x, y) { return x*y; }; The Function() constructor expects any number of string arguments. The last argument is the text of the function body; it can contain arbitrary JavaScript statements, separated from each other by semicolons. All other arguments to the constructor are strings that specify the parameter names for the function. If you are defining a function that takes no arguments, you would simply pass a single string—the function body—to the constructor. Function() 构造函数可以传入任意数量的字符串实参，最后一个实参所表示的文本就是函数体；它可以包含任意的 JavaScript 语句，每两条语句之间用分号分隔。传入构造函数的其他所有的实参字符串是指定函数的形参名字的字符串。如果定义的函数不包含任何参数，只须给构造函数简单地传入一个字符串——函数体——即可。 Notice that the Function() constructor is not passed any argument that specifies a name for the function it creates. Like function literals, the Function() constructor creates anonymous functions. 注意，Function() 构造函数并不需要通过传入实参以指定函数名。就像函数字面量一样，Function() 构造函数创建一个匿名函数。 There are a few points that are important to understand about the Function() constructor: 关于 Function() 构造函数有几点需要特别注意： The Function() constructor allows JavaScript functions to be dynamically created and compiled at runtime. Function() 构造函数允许 JavaScript 在运行时动态地创建并编译函数。 The Function() constructor parses the function body and creates a new function object each time it is called. If the call to the constructor appears within a loop or within a frequently called function, this process can be inefficient. By contrast, nested functions and function expressions that appear within loops are not recompiled each time they are encountered. 每次调用 Function() 构造函数都会解析函数体，并创建新的函数对象。如果是在一个循环或者多次调用的函数中执行这个构造函数，执行效率会受影响。相比之下，循环中的嵌套函数和函数定义表达式则不会每次执行时都重新编译。 A last, very important point about the Function() constructor is that the functions it creates do not use lexical scoping; instead, they are always compiled as if they were top-level functions, as the following code demonstrates: 最后一点，也是关于 Function() 构造函数非常重要的一点，就是它所创建的函数并不是使用词法作用域，相反，函数体代码的编译类似顶层函数，如下面代码所示： let scope = \"global\"; function constructFunction() { let scope = \"local\"; return new Function(\"return scope\"); // Doesn't capture local scope! } // This line returns \"global\" because the function returned by the // Function() constructor does not use the local scope. constructFunction()() // =\u003e \"global\" The Function() constructor is best thought of as a globally scoped version of eval() (see §4.12.2) that defines new variables and functions in its own private scope. You will probably never need to use this constructor in your code. 我们可以将 Function() 构造函数认为是在全局作用域中执行的 eval()（见 §4.12.2），eval() 可以在自己的私有作用域内定义新变量和函数，Function() 构造函数在实际编程过程中很少会用到。 ","date":"2020-11-02","objectID":"/posts/ch8/:7:7","tags":null,"title":"第 8 章 函数","uri":"/posts/ch8/"},{"categories":null,"content":"8.8 Functional Programming JavaScript is not a functional programming language like Lisp or Haskell, but the fact that JavaScript can manipulate functions as objects means that we can use functional programming techniques in JavaScript. Array methods such as map() and reduce() lend themselves particularly well to a functional programming style. The sections that follow demonstrate techniques for functional programming in JavaScript. They are intended as a mind-expanding exploration of the power of JavaScript’s functions, not as a prescription for good programming style. 和 Lisp、Haskell 不同，JavaScript 并非函数式编程语言，但在 JavaScript 中可以像操控对象一样操控函数，也就是说可以在 JavaScript 中应用函数式编程技术。数组方法诸如 map() 和 reduce() 就可以非常适合用于函数式编程风格。接下来的几节将会着重介绍 JavaScript 中的函数式编程技术。函数式编程旨在扩展对 JavaScript 函数功能功能的探索，而不是为了良好的编程风格。 ","date":"2020-11-02","objectID":"/posts/ch8/:8:0","tags":null,"title":"第 8 章 函数","uri":"/posts/ch8/"},{"categories":null,"content":"8.8.1 Processing Arrays with Functions Suppose we have an array of numbers and we want to compute the mean and standard deviation of those values. We might do that in nonfunctional style like this: 假设有一个数组，数组元素都是数字，我们想要计算这些元素的平均值和标准差。若使用非函数式编程风格的话，代码会是这样： let data = [1,1,3,5,5]; // This is our array of numbers // The mean is the sum of the elements divided by the number of elements let total = 0; for(let i = 0; i \u003c data.length; i++) total += data[i]; let mean = total/data.length; // mean == 3; The mean of our data is 3 // To compute the standard deviation, we first sum the squares of // the deviation of each element from the mean. total = 0; for(let i = 0; i \u003c data.length; i++) { let deviation = data[i] - mean; total += deviation * deviation; } let stddev = Math.sqrt(total/(data.length-1)); // stddev == 2 We can perform these same computations in concise functional style using the array methods map() and reduce() like this (see §7.8.1 to review these methods): 可以使用数组方法 map() 和 reduce() 来实现同样的计算，这种实现极其简洁（参照 §7.8.1 来查看这些方法）： // First, define two simple functions const sum = (x,y) =\u003e x+y; const square = x =\u003e x*x; // Then use those functions with Array methods to compute mean and stddev let data = [1,1,3,5,5]; let mean = data.reduce(sum)/data.length; // mean == 3 let deviations = data.map(x =\u003e x-mean); let stddev = Math.sqrt(deviations.map(square).reduce(sum)/(data.length-1)); stddev // =\u003e 2 This new version of the code looks quite different than the first one, but it is still invoking methods on objects, so it has some object-oriented conventions remaining. Let’s write functional versions of the map() and reduce() methods: 这个新版本的代码看起来跟第一版有很大不同，但是它仍然调用对象的方法，所以它还是面向对象编程。接下来用函数版本的 map() 和 reduce() 方法： const map = function(a, ...args) { return a.map(...args); }; const reduce = function(a, ...args) { return a.reduce(...args); }; With these map() and reduce() functions defined, our code to compute the mean and standard deviation now looks like this: 用这两个函数定义了 map() 和 reduce()，我们计算平均值和标准差变成这样： const sum = (x,y) =\u003e x+y; const square = x =\u003e x*x; let data = [1,1,3,5,5]; let mean = reduce(data, sum)/data.length; let deviations = map(data, x =\u003e x-mean); let stddev = Math.sqrt(reduce(map(deviations, square), sum)/(data.length-1)); stddev // =\u003e 2 ","date":"2020-11-02","objectID":"/posts/ch8/:8:1","tags":null,"title":"第 8 章 函数","uri":"/posts/ch8/"},{"categories":null,"content":"8.8.2 Higher-Order Functions A higher-order function is a function that operates on functions, taking one or more functions as arguments and returning a new function. Here is an example: 所谓高阶函数就是操作函数的函数，它接收一个或多个函数作为参数，并返回一个新函数。来看这个例子： // This higher-order function returns a new function that passes its // arguments to f and returns the logical negation of f's return value; function not(f) { return function(...args) { // Return a new function let result = f.apply(this, args); // that calls f return !result; // and negates its result. }; } const even = x =\u003e x % 2 === 0; // A function to determine if a number is even const odd = not(even); // A new function that does the opposite [1,1,3,5,5].every(odd) // =\u003e true: every element of the array is odd This not() function is a higher-order function because it takes a function argument and returns a new function. As another example, consider the mapper() function that follows. It takes a function argument and returns a new function that maps one array to another using that function. This function uses the map() function defined earlier, and it is important that you understand how the two functions are different: 上面的 not() 函数就是一个高阶函数，因为它接收一个函数作为参数，并返回一个新函数。另外一个例子，来看下面的 mapper() 函数，它也是接收一个函数作为实参，并返回一个新函数，这个新函数将一个数组映射到另一个使用这个函数的数组上。这个函数使用了之前定义的 map() 函数，但要首先理解这两个函数有哪里不 同，理解这一点至关重要： // Return a function that expects an array argument and applies f to // each element, returning the array of return values. // Contrast this with the map() function from earlier. function mapper(f) { return a =\u003e map(a, f); } const increment = x =\u003e x+1; const incrementAll = mapper(increment); incrementAll([1,2,3]) // =\u003e [2,3,4] Here is another, more general, example that takes two functions, f and g, and returns a new function that computes f(g()): 这里是一个更常见的例子，它接收两个函数 f() 和 g()，并返回一个新的函数用以计算 f(g())： // Return a new function that computes f(g(...)). // The returned function h passes all of its arguments to g, then passes // the return value of g to f, then returns the return value of f. // Both f and g are invoked with the same this value as h was invoked with. function compose(f, g) { return function(...args) { // We use call for f because we're passing a single value and // apply for g because we're passing an array of values. return f.call(this, g.apply(this, args)); }; } const sum = (x,y) =\u003e x+y; const square = x =\u003e x*x; compose(square, sum)(2,3) // =\u003e 25; the square of the sum The partial() and memoize() functions defined in the sections that follow are two more important higher-order functions. 本章后续几节中定义了 partial() 和 memoize() 函数，这两个函数是非常重要的高阶函数。 ","date":"2020-11-02","objectID":"/posts/ch8/:8:2","tags":null,"title":"第 8 章 函数","uri":"/posts/ch8/"},{"categories":null,"content":"8.8.3 Partial Application of Functions The bind() method of a function f (see §8.7.5) returns a new function that invokes f in a specified context and with a specified set of arguments. We say that it binds the function to an object and partially applies the arguments. The bind() method partially applies arguments on the left—that is, the arguments you pass to bind() are placed at the start of the argument list that is passed to the original function. But it is also possible to partially apply arguments on the right: 函数 f()（见 §8.7.5）的 bind() 方法返回一个新函数，给新函数传入特定的上下文和一组指定的参数，然后调用函数 f()。我们说它把函数“绑定至”对象并传入一部分参数。bind() 方法只是将实参放在（完整实参列表的）左侧，也就是说传入 bind() 的实参都是放在传入原始函数的实参列表开始的位置，但有时我们期望将传入 bind() 的实参放在（完整实参列表的）右侧： // The arguments to this function are passed on the left function partialLeft(f, ...outerArgs) { return function(...innerArgs) { // Return this function let args = [...outerArgs, ...innerArgs]; // Build the argument list return f.apply(this, args); // Then invoke f with it }; } // The arguments to this function are passed on the right function partialRight(f, ...outerArgs) { return function(...innerArgs) { // Return this function let args = [...innerArgs, ...outerArgs]; // Build the argument list return f.apply(this, args); // Then invoke f with it }; } // The arguments to this function serve as a template. Undefined values // in the argument list are filled in with values from the inner set. function partial(f, ...outerArgs) { return function(...innerArgs) { let args = [...outerArgs]; // local copy of outer args template let innerIndex=0; // which inner arg is next // Loop through the args, filling in undefined values from inner args for(let i = 0; i \u003c args.length; i++) { if (args[i] === undefined) args[i] = innerArgs[innerIndex++]; } // Now append any remaining inner arguments args.push(...innerArgs.slice(innerIndex)); return f.apply(this, args); }; } // Here is a function with three arguments const f = function(x,y,z) { return x * (y - z); }; // Notice how these three partial applications differ partialLeft(f, 2)(3,4) // =\u003e -2: Bind first argument: 2 * (3 - 4) partialRight(f, 2)(3,4) // =\u003e 6: Bind last argument: 3 * (4 - 2) partial(f, undefined, 2)(3,4) // =\u003e -6: Bind middle argument: 3 * (2 - 4) These partial application functions allow us to easily define interesting functions out of functions we already have defined. Here are some examples: 利用这种不完全函数的编程技巧，可以编写一些有意思的代码，利用已有的函数来定义新的函数，参照下面这个例子： const increment = partialLeft(sum, 1); const cuberoot = partialRight(Math.pow, 1/3); cuberoot(increment(26)) // =\u003e 3 Partial application becomes even more interesting when we combine it with other higher-order functions. Here, for example, is a way to define the preceding not() function just shown using composition and partial application: 当将不完全调用和其他高阶函数整合在一起的时候，事情就变得格外有趣了。比如，这里的例子定义了 not() 函数，它用到了刚才提到的不完全调用： const not = partialLeft(compose, x =\u003e !x); const even = x =\u003e x % 2 === 0; const odd = not(even); const isNumber = not(isNaN); odd(3) \u0026\u0026 isNumber(2) // =\u003e true We can also use composition and partial application to redo our mean and standard deviation calculations in extreme functional style: 我们也可以使用不完全调用的组合来重新组织求平均数和标准差的代码，这种编码风格是非常纯粹的函数式编程： // sum() and square() functions are defined above. Here are some more: const product = (x,y) =\u003e x*y; const neg = partial(product, -1); const sqrt = partial(Math.pow, undefined, .5); const reciprocal = partial(Math.pow, undefined, neg(1)); // Now compute the mean and standard deviation. let data = [1,1,3,5,5]; // Our data let mean = product(reduce(data, sum), reciprocal(data.length)); let stddev = sqrt(product(reduce(map(data, compose(square, partial(sum, neg(mean)))), sum), reciprocal(sum(data.length,neg(1))))); [mean, stddev] // =\u003e [3, 2] Notice that this code to compute mean and standard deviation is entirely function invocations; there are no operators involved, and the number of parentheses has grown so large that this JavaScript is beginning to look like Lisp code. Again, this is not ","date":"2020-11-02","objectID":"/posts/ch8/:8:3","tags":null,"title":"第 8 章 函数","uri":"/posts/ch8/"},{"categories":null,"content":"8.8.4 Memoization In §8.4.1, we defined a factorial function that cached its previously computed results. In functional programming, this kind of caching is called memoization. The code that follows shows a higher-order function, memoize(), that accepts a function as its argument and returns a memoized version of the function: 在 §8.4.1 中定义了一个阶乘函数，它可以将上次的计算结果缓存起来。在函数式编程当中，这种缓存技巧叫做“记忆”（memorization）。下面的代码展示了一个高阶函数，memorize() 接收一个函数作为实参，并返回带有记忆能力的函数: // Return a memoized version of f. // It only works if arguments to f all have distinct string representations. function memoize(f) { const cache = new Map(); // Value cache stored in the closure. return function(...args) { // Create a string version of the arguments to use as a cache key. let key = args.length + args.join(\"+\"); if (cache.has(key)) { return cache.get(key); } else { let result = f.apply(this, args); cache.set(key, result); return result; } }; } The memoize() function creates a new object to use as the cache and assigns this object to a local variable so that it is private to (in the closure of) the returned function. The returned function converts its arguments array to a string and uses that string as a property name for the cache object. If a value exists in the cache, it returns it directly. Otherwise, it calls the specified function to compute the value for these arguments, caches that value, and returns it. Here is how we might use memoize(): memorize() 函数创建一个新的对象，这个对象被当做缓存（的宿主）并赋值给一个局部变量，因此对于返回的函数来说它是私有的（在闭包中）。所返回的函数将它的实参数组转换成字符串，并将字符串用做缓存对象的属性名。如果在缓存中存在这个值，则直接返回它。否则，就调用既定的函数对实参进行计算，将计算结果缓存起来并返回，下面的代码展示了如何使用 memorize()： // Return the Greatest Common Divisor of two integers using the Euclidian // algorithm: http://en.wikipedia.org/wiki/Euclidean_algorithm function gcd(a,b) { // Type checking for a and b has been omitted if (a \u003c b) { // Ensure that a \u003e= b when we start [a, b] = [b, a]; // Destructuring assignment to swap variables } while(b !== 0) { // This is Euclid's algorithm for GCD [a, b] = [b, a%b]; } return a; } const gcdmemo = memoize(gcd); gcdmemo(85, 187) // =\u003e 17 // Note that when we write a recursive function that we will be memoizing, // we typically want to recurse to the memoized version, not the original. const factorial = memoize(function(n) { return (n \u003c= 1) ? 1 : n * factorial(n-1); }); factorial(5) // =\u003e 120: also caches values for 4, 3, 2 and 1. ","date":"2020-11-02","objectID":"/posts/ch8/:8:4","tags":null,"title":"第 8 章 函数","uri":"/posts/ch8/"},{"categories":null,"content":"8.9 Summary Some key points to remember about this chapter are as follows: You can define functions with the function keyword and with the ES6 =\u003e arrow syntax. You can invoke functions, which can be used as methods and constructors. Some ES6 features allow you to define default values for optional function parameters, to gather multiple arguments into an array using a rest parameter, and to destructure object and array arguments into function parameters. You can use the … spread operator to pass the elements of an array or other iterable object as arguments in a function invocation. A function defined inside of and returned by an enclosing function retains access to its lexical scope and can therefore read and write the variables defined inside the outer function. Functions used in this way are called closures, and this is a technique that is worth understanding. Functions are objects that can be manipulated by JavaScript, and this enables a functional style of programming. 本章关键点总结如下： 可以用函数关键字和 ES6 =\u003e 箭头函数来定义函数。 可以以方法和构造函数的方式调用函数。 一些 ES6 特性，允许参数设定默认值，可以用剩余参数将多个参数搜集到一个数组中，可以解构对象和数组实参到函数参数中。 可以用 … 展开运算符传递数组元素或者其他可迭代对象到函数调用。 封闭函数内部定义并返回的函数保留对其词法作用域的访问，因此可以读取和写入外部函数内定义的变量。用这种方式使用的函数称为闭包，这是一种值得理解的技术。 函数是可由 JavaScript 操作的对象，这使 JavaScript 支持函数式编程。 The term was coined by Martin Fowler. See http://martinfowler.com/dslCatalog/methodChaining.html. If you are familiar with Python, note that this is different than Python, in which every invocation shares the same default value. This may not seem like a particularly interesting point unless you are familiar with more static languages, in which functions are part of a program but cannot be manipulated by the program. 这个术语最初是由 Martin Fowler 提出的，参见http://martinfowler.com/dslwip/MethodChaining.html。 这看起来不足为奇，但如果你对 Python 很熟悉，你会发现 Python 中的函数是程序的一 部分，但无法被程序操作。 这似乎并不是一个特别有趣的点，除非你熟悉更多的静态语言，其中函数是程序的一部分，但不能由程序操作。 ","date":"2020-11-02","objectID":"/posts/ch8/:9:0","tags":null,"title":"第 8 章 函数","uri":"/posts/ch8/"},{"categories":null,"content":"JavaScript objects were covered in Chapter 6. That chapter treated each object as a unique set of properties, different from every other object. It is often useful, however, to define a class of objects that share certain properties. Members, or instances, of the class have their own properties to hold or define their state, but they also have methods that define their behavior. These methods are defined by the class and shared by all instances. Imagine a class named Complex that represents and performs arithmetic on complex numbers, for example. A Complex instance would have properties to hold the real and imaginary parts (the state) of the complex number. And the Complex class would define methods to perform addition and multiplication (the behavior) of those numbers. 第 6 章详细介绍了 JavaScript 对象，每个 JavaScript 对象都是一个属性集合，相互之间没有任何联系。在 JavaScript 中也可以定义对象的类，让每个对象都共享某些属性，这种“共享”的特性是非常有用的。类的成员或实例都包含一些属性，用以存放或定义它们的状态，其中有些属性定义了它们的行为（通常称为方法）。这些行为通常是由类定义的，而且为所有实例所共享。例如，假设有一个名为 Complex 的类用来表示复数，同时还定义了一些复数运算。一个 Complex 实例应当包含复数的实部和虚部（状态），同样 Complex 类还会定义复数的加法和乘法操作（行为）。 In JavaScript, classes use prototype-based inheritance: if two objects inherit properties (generally function-valued properties, or methods) from the same prototype, then we say that those objects are instances of the same class. That, in a nutshell, is how JavaScript classes work. JavaScript prototypes and inheritance were covered in §6.2.3 and §6.3.2, and you will need to be familiar with the material in those sections to understand this chapter. This chapter covers prototypes in §9.1. 在 JavaScript 中，类的实现是基于其原型继承机制的。如果两个实例都从同一个原型对象上继承了属性，我们说它们是同一个类的实例。JavaScript 原型和继承在 §6.2.3 和 §6.3.2 节中有详细讨论，为了更好地理解本章的内容，请务必首先阅读这两个章节。本章将会在 §9.1 中对原型做进一步讨论。 If two objects inherit from the same prototype, this typically (but not necessarily) means that they were created and initialized by the same constructor function or factory function. Constructors have been covered in §4.6, §6.2.2, and §8.2.3, and this chapter has more in §9.2. 如果两个对象继承自同一个原型，往往意味着（但不是绝对）它们是由同一个构造函数创建并初始化的。我们已经在 §4.6、§6.2.2 和 §8.2.3 节中详细讲解了构造函数，§9.2 会有进一步讨论。 JavaScript has always allowed the definition of classes. ES6 introduced a brand-new syntax (including a class keyword) that makes it even easier to create classes. These new JavaScript classes work in the same way that old-style classes do, and this chapter starts by explaining the old way of creating classes because that demonstrates more clearly what is going on behind the scenes to make classes work. Once we’ve explained those fundamentals, we’ll shift and start using the new, simplified class definition syntax. JavaScript 一直允许定义类。ES6 引入了全新的语法（包括 class 关键字），使创建类更加容易。这些新的 JavaScript 类的工作方式与旧式类相同，本章首先解释创建类的旧方法，因为这更清楚地展示了类是如何工作的。一旦我们解释了这些基本原理，我们将改变并开始使用新的、简化的类定义语法。 If you’re familiar with strongly typed object-oriented programming languages like Java or C++, you’ll notice that JavaScript classes are quite different from classes in those languages. There are some syntactic similarities, and you can emulate many features of “classical” classes in JavaScript, but it is best to understand up front that JavaScript’s classes and prototype-based inheritance mechanism are substantially different from the classes and class-based inheritance mechanism of Java and similar languages. 如果你对诸如 Java 和 C++ 这种强类型的面向对象编程比较熟悉，你会发现 JavaScript 中的类和 Java 以及 C++ 中的类有很大不同。尽管在写法上类似，而且在 JavaScript 中也能“模拟”出很多经典的类的特性，但是最好要理解 JavaScript 的类和基于原型的继承机制，以及和传统的 Java（当然还有类似 Java 的语言）的类和基于类的继承机制的不同之处。 ","date":"2020-11-02","objectID":"/posts/ch9/:0:0","tags":null,"title":"第 9 章 类","uri":"/posts/ch9/"},{"categories":null,"content":"9.1 Classes and Prototypes In JavaScript, a class is a set of objects that inherit properties from the same prototype object. The prototype object, therefore, is the central feature of a class. Chapter 6 covered the Object.create() function that returns a newly created object that inherits from a specified prototype object. If we define a prototype object and then use Object.create() to create objects that inherit from it, we have defined a JavaScript class. Usually, the instances of a class require further initialization, and it is common to define a function that creates and initializes the new object. Example 9-1 demonstrates this: it defines a prototype object for a class that represents a range of values and also defines a factory function that creates and initializes a new instance of the class. 在 JavaScript 中，类的所有实例对象都从同一个原型对象上继承属性。因此，原型对象是类的核心。在示例 6-1 中定义了 inherit() 函数，这个函数返回一个新创建的对象，后者继承自某个原型对象。如果定义一个原型对象，然后通过 inherit() 函数创建一个继承自它的对象，这样就定义了一个 JavaScript 类。通常，类的实例还需要进一步的初始化，通常是通过定义一个函数来创建并初始化这个新对象，参照示例 9-1。示例 9-1 给一个表示“值的范围”的类定义了原型对象，还定义了一个“工厂”函数用以创建并初始化类的实例。 Example 9-1. A simple JavaScript class 示例 9-1：一个简单的 JavaScript 类 // This is a factory function that returns a new range object. function range(from, to) { // Use Object.create() to create an object that inherits from the // prototype object defined below. The prototype object is stored as // a property of this function, and defines the shared methods (behavior) // for all range objects. let r = Object.create(range.methods); // Store the start and end points (state) of this new range object. // These are noninherited properties that are unique to this object. r.from = from; r.to = to; // Finally return the new object return r; } // This prototype object defines methods inherited by all range objects. range.methods = { // Return true if x is in the range, false otherwise // This method works for textual and Date ranges as well as numeric. includes(x) { return this.from \u003c= x \u0026\u0026 x \u003c= this.to; }, // A generator function that makes instances of the class iterable. // Note that it only works for numeric ranges. *[Symbol.iterator]() { for(let x = Math.ceil(this.from); x \u003c= this.to; x++) yield x; }, // Return a string representation of the range toString() { return \"(\" + this.from + \"...\" + this.to + \")\"; } }; // Here are example uses of a range object. let r = range(1,3); // Create a range object r.includes(2) // =\u003e true: 2 is in the range r.toString() // =\u003e \"(1...3)\" [...r] // =\u003e [1, 2, 3]; convert to an array via iterator There are a few things worth noting in the code of Example 9-1: 在示例 9-1 的代码中有一下几点值得注意： This code defines a factory function range() for creating new Range objects. 这段代码定义了一个工厂函数 range() 用来创建一个新的 Range 对象。 It uses the methods property of this range() function as a convenient place to store the prototype object that defines the class. There is nothing special or idiomatic about putting the prototype object here. 用 range() 函数的 methods 属性来存放定义类的原型对象。只是将原型对象随意的放在一个地方，并不是一个规约或者习惯。 The range() function defines from and to properties on each Range object. These are the unshared, noninherited properties that define the unique state of each individual Range object. range() 函数在每个 Range 对象中都定义 from 和 to 属性。它们是非共享、非继承属性，是每个独立的 Range 对象的独特自有状态。 The range.methods object uses the ES6 shorthand syntax for defining methods, which is why you don’t see the function keyword anywhere. (See §6.10.5 to review object literal shorthand method syntax.) range.methods 对象应用了 ES6 的速记语法来定义方法，这是为什么没有看到 function 关键字的原因。（参照 §6.10.5 来复习对象字面量速记方法语法。） One of the methods in the prototype has the computed name (§6.10.2) Symbol.iterator, which means that it is defining an iterator for Range objects. The name of this method is prefixed with *, which indicates that it is a generator function instead of a regular function. Iterators and generators are covered in detail in Chapter 12. For now, the upshot is that instances of this Range class can be used with the for/of loop and with the … spread ","date":"2020-11-02","objectID":"/posts/ch9/:1:0","tags":null,"title":"第 9 章 类","uri":"/posts/ch9/"},{"categories":null,"content":"9.2 Classes and Constructors Example 9-1 demonstrates a simple way to define a JavaScript class. It is not the idiomatic way to do so, however, because it did not define a constructor. A constructor is a function designed for the initialization of newly created objects. Constructors are invoked using the new keyword as described in §8.2.3. Constructor invocations using new automatically create the new object, so the constructor itself only needs to initialize the state of that new object. The critical feature of constructor invocations is that the prototype property of the constructor is used as the prototype of the new object. §6.2.3 introduced prototypes and emphasized that while almost all objects have a prototype, only a few objects have a prototype property. Finally, we can clarify this: it is function objects that have a prototype property. This means that all objects created with the same constructor function inherit from the same object and are therefore members of the same class. Example 9-2 shows how we could alter the Range class of Example 9-1 to use a constructor function instead of a factory function. Example 9-2 demonstrates the idiomatic way to create a class in versions of JavaScript that do not support the ES6 class keyword. Even though class is well supported now, there is still lots of older JavaScript code around that defines classes like this, and you should be familiar with the idiom so that you can read old code and so that you understand what is going on “under the hood” when you use the class keyword. 示例 9-1 展示了一个简单方式来定义一个 JavaScript 类。但是这种方法并不常用，因为它没有定义一个构造函数。构造函数是用来初始化新建对象的。如 §8.2.3 中所述构造函数用 new 关键字来调用。使用 new 调用构造函数会自动创建一个新对象，因此构造函数本身只需初始化这个新对象的状态即可。§6.2.3 介绍并强调了虽然所有对象都有原型，但是只有一部分对象有一个 prototype 属性。最后，我们可以澄清这一点：是函数对象具有 prototype 属性。这意味着所有用同一构造函数创建的对象继承同一个对象，因此它们是同一类的成员。示例 9-2 说明了如何使用一个构造函数来替代示例 9-1 中的工厂函数来修改 Range 类。示例 9-2 演示了在不支持 ES6 class 关键字版本的 JavaScript 中创建一个类的通用方法。即使是 class 已经很好支持的今天，仍然有很多旧 JavaScript 代码用这种方式定义类，并且你必须熟悉这种习惯用法，以便于阅读旧代码，也能够在使用 class 关键字时明白在底层中发生了什么。 Example 9-2. A Range class using a constructor 示例 9-2：使用构造函数的 Range 类 // This is a constructor function that initializes new Range objects. // Note that it does not create or return the object. It just initializes this. function Range(from, to) { // Store the start and end points (state) of this new range object. // These are noninherited properties that are unique to this object. this.from = from; this.to = to; } // All Range objects inherit from this object. // Note that the property name must be \"prototype\" for this to work. Range.prototype = { // Return true if x is in the range, false otherwise // This method works for textual and Date ranges as well as numeric. includes: function(x) { return this.from \u003c= x \u0026\u0026 x \u003c= this.to; }, // A generator function that makes instances of the class iterable. // Note that it only works for numeric ranges. [Symbol.iterator]: function*() { for(let x = Math.ceil(this.from); x \u003c= this.to; x++) yield x; }, // Return a string representation of the range toString: function() { return \"(\" + this.from + \"...\" + this.to + \")\"; } }; // Here are example uses of this new Range class let r = new Range(1,3); // Create a Range object; note the use of new r.includes(2) // =\u003e true: 2 is in the range r.toString() // =\u003e \"(1...3)\" [...r] // =\u003e [1, 2, 3]; convert to an array via iterator It is worth comparing Examples 9-1 and 9-2 fairly carefully and noting the differences between these two techniques for defining classes. First, notice that we renamed the range() factory function to Range() when we converted it to a constructor. This is a very common coding convention: constructor functions define, in a sense, classes, and classes have names that (by convention) begin with capital letters. Regular functions and methods have names that begin with lowercase letters. 将示例 9-1 和示例 9-2 中的代码做一个仔细的对比，可以发现两种类定义技术的差别。首先，注意当工厂函数 range() 转化为构造函数时被重命名为 Range()。这里遵循了一个常见的编程约定：从某种意义上讲，定义构造函数即是定义类，并且类名首字母要大写。而普通的函数和方法都是首字母小写。 Next","date":"2020-11-02","objectID":"/posts/ch9/:2:0","tags":null,"title":"第 9 章 类","uri":"/posts/ch9/"},{"categories":null,"content":"9.2.1 Constructors, Class Identity, and instanceof As we’ve seen, the prototype object is fundamental to the identity of a class: two objects are instances of the same class if and only if they inherit from the same prototype object. The constructor function that initializes the state of a new object is not fundamental: two constructor functions may have prototype properties that point to the same prototype object. Then, both constructors can be used to create instances of the same class. 正如我们所看到的，原型对象是类的基本标识：只有两个对象继承同一原型对象时，这两个对象是同一类实例。构造函数的关键点不是初始化新创建对象的状态：两个构造函数可能具有指向同一原型对象的原型属性。那么，两个构造函数都可用于创建同一类的实例。 Even though constructors are not as fundamental as prototypes, the constructor serves as the public face of a class. Most obviously, the name of the constructor function is usually adopted as the name of the class. We say, for example, that the Range() constructor creates Range objects. More fundamentally, however, constructors are used as the righthand operand of the instanceof operator when testing objects for membership in a class. If we have an object r and want to know if it is a Range object, we can write: 尽管构造函数不像原型那样重要，但是构造函数充当 class 的大众脸。最明显的是，构造函数的名称通常用作类的名称。例如，我们说 Range() 构造函数创建 Range 对象。然而，更重要的是测试类中对象的成员关系，构造函数在右边被用作 instanceof 运算符的操作数。如果有一个对象 r，并且想知道它是不是一个 Range 对象，可以这样写： r instanceof Range // =\u003e true: r inherits from Range.prototype The instanceof operator was described in §4.9.4. The lefthand operand should be the object that is being tested, and the righthand operand should be a constructor function that names a class. The expression o instanceof C evaluates to true if o inherits from C.prototype. The inheritance need not be direct: if o inherits from an object that inherits from an object that inherits from C.prototype, the expression will still evaluate to true. instanceof 运算符在 §4.9.4 中有描述。左边的操作数是想要测试的对象，右边的操作数是命名类的构造函数。表达式 o instanceof C 计算结果为 true 时，o 继承自 C.prototype。不需要直接继承：如果 o 继承于一个继承了 C.prototype 的对象，表达式的计算结果也仍会是 true。 Technically speaking, in the previous code example, the instanceof operator is not checking whether r was actually initialized by the Range constructor. Instead, it is checking whether r inherits from Range.prototype. If we define a function Strange() and set its prototype to be the same as Range.prototype, then objects created with new Strange() will count as Range objects as far as instanceof is concerned (they won’t actually work as Range objects, however, because their from and to properties have not been initialized): 从技术上讲，在上一个代码示例中，instanceof 运算符的实例没有检查 r 是否实际由 Range 构造函数初始化。相反，它是检查 r 是否继承 Range.prototype。如果我们定义一个函数 Strange() 并将其原型设置与 Range.prototype 相同，则使用新 Strange() 创建的对象用 instanceof 运算符将算作 Range 对象（但是，它们实际上不会作为 Range 对象工作，因为它们的 from 和 to 属性尚未初始化）： function Strange() {} Strange.prototype = Range.prototype; new Strange() instanceof Range // =\u003e true Even though instanceof cannot actually verify the use of a constructor, it still uses a constructor function as its righthand side because constructors are the public identity of a class. 实际上即使 instanceof 不能验证使用了构造函数，它仍然使用构造函数作为其右侧，因为构造函数是类的公共标识。 If you want to test the prototype chain of an object for a specific prototype and do not want to use the constructor function as an intermediary, you can use the isPrototypeOf() method. In Example 9-1, for example, we defined a class without a constructor function, so there is no way to use instanceof with that class. Instead, however, we could test whether an object r was a member of that constructor-less class with this code: 如果要为特定原型测试对象的原型链，并且不想将构造函数用作媒介，可以使用 isPrototypeOf() 方法。例如，在示例 9-1 中，我们定义了一个没有构造函数的类，因此无法将 instanceof 与该类一起使用。但是，我们可以测试对象 r 是否是具有此代码的无构造函数类的成员： range.methods.isPrototypeOf(r); // range.methods is the prototype object. ","date":"2020-11-02","objectID":"/posts/ch9/:2:1","tags":null,"title":"第 9 章 类","uri":"/posts/ch9/"},{"categories":null,"content":"9.2.2 The constructor Property In Example 9-2, we set Range.prototype to a new object that contained the methods for our class. Although it was convenient to express those methods as properties of a single object literal, it was not actually necessary to create a new object. Any regular JavaScript function (excluding arrow functions, generator functions, and async functions) can be used as a constructor, and constructor invocations need a prototype property. Therefore, every regular JavaScript function1 automatically has a prototype property. The value of this property is an object that has a single, non-enumerable constructor property. The value of the constructor property is the function object: 在示例 9-2 中，将 Range.prototype 定义为一个新对象，这个对象包含类所需要的方法。其实没有必要新创建一个对象，用单个对象字面量的属性就可以方便地定义原型上的方法。任何普通 JavaScript 函数（除箭头函数、生成器函数和异步函数之外）都可以用做构造函数，并且调用构造函数是需要一个 prototype 属性的。因此，每个 JavaScript 函数都自动拥有一个 prototype 属性。这个属性的值是一个对象，这个对象包含唯一一个不可枚举属性 constructor。constructor 属性的值是一个函数对象： let F = function() {}; // This is a function object. let p = F.prototype; // This is the prototype object associated with F. let c = p.constructor; // This is the function associated with the prototype. c === F // =\u003e true: F.prototype.constructor === F for any F The existence of this predefined prototype object with its constructor property means that objects typically inherit a constructor property that refers to their constructor. Since constructors serve as the public identity of a class, this constructor property gives the class of an object: 可以看到构造函数的原型中存在预先定义好的 constructor 属性，这意味着对象通常继承的 constructor 是它们的构造函数的引用。由于构造函数是类的“公共标识”， 因此这个 constructor 属性为对象提供了类。 let o = new F(); // Create an object o of class F o.constructor === F // =\u003e true: the constructor property specifies the class Figure 9-1 illustrates this relationship between the constructor function, its prototype object, the back reference from the prototype to the constructor, and the instances created with the constructor. 如图 9-1 所示，图 9-1 展示了构造函数和原型对象之间的关系，包括原型到构造函数的反向引用以及构造函数创建的实例。 A constructor function, its prototype, and instancesNotice that Figure 9-1 uses our Range() constructor as an example. In fact, however, the Range class defined in Example 9-2 overwrites the predefined Range.prototype object with an object of its own. And the new prototype object it defines does not have a constructor property. So instances of the Range class, as defined, do not have a constructor property. We can remedy this problem by explicitly adding a constructor to the prototype: 需要注意的是，图 9-1 用 Range() 构造函数作为示例。但实际上，示例 9-2 中定义的 Range 类使用它自身的一个新对象重写了预定义的 Range.prototype 对象。这个新定义的原型对象不含有 constructor 属性。因此 Range 类的实例也不含有 constructor 属性。我们可以通过补救措施来修正这个问题，显式给原型添加一个构造函数： Range.prototype = { constructor: Range, // Explicitly set the constructor back-reference /* method definitions go here */ }; Another common technique that you are likely to see in older JavaScript code is to use the predefined prototype object with its constructor property and add methods to it one at a time with code like this: 另一种常见的解决办法是使用预定义的原型对象，预定义的原型对象包含 constructor 属性，然后依次给原型对象添加方法： // Extend the predefined Range.prototype object so we don't overwrite // the automatically created Range.prototype.constructor property. Range.prototype.includes = function(x) { return this.from \u003c= x \u0026\u0026 x \u003c= this.to; }; Range.prototype.toString = function() { return \"(\" + this.from + \"...\" + this.to + \")\"; }; ","date":"2020-11-02","objectID":"/posts/ch9/:2:2","tags":null,"title":"第 9 章 类","uri":"/posts/ch9/"},{"categories":null,"content":"9.3 Classes with the class Keyword Classes have been part of JavaScript since the very first version of the language, but in ES6, they finally got their own syntax with the introduction of the class keyword. Example 9-3 shows what our Range class looks like when written with this new syntax. 类自第一个版本以来一直是 JavaScript 的一部分，但在 ES6 中，它们最终引入 class 关键字得到了自己的语法。示例 9-3 显示了使用此新语法编写 Range 类的实现。 Example 9-3. The Range class rewritten using class 示例 9-3：使用 class 编写 Range 类 class Range { constructor(from, to) { // Store the start and end points (state) of this new range object. // These are noninherited properties that are unique to this object. this.from = from; this.to = to; } // Return true if x is in the range, false otherwise // This method works for textual and Date ranges as well as numeric. includes(x) { return this.from \u003c= x \u0026\u0026 x \u003c= this.to; } // A generator function that makes instances of the class iterable. // Note that it only works for numeric ranges. *[Symbol.iterator]() { for(let x = Math.ceil(this.from); x \u003c= this.to; x++) yield x; } // Return a string representation of the range toString() { return `(${this.from}...${this.to})`; } } // Here are example uses of this new Range class let r = new Range(1,3); // Create a Range object r.includes(2) // =\u003e true: 2 is in the range r.toString() // =\u003e \"(1...3)\" [...r] // =\u003e [1, 2, 3]; convert to an array via iterator It is important to understand that the classes defined in Examples 9-2 and 9-3 work in exactly the same way. The introduction of the class keyword to the language does not alter the fundamental nature of JavaScript’s prototype-based classes. And although Example 9-3 uses the class keyword, the resulting Range object is a constructor function, just like the version defined in Example 9-2. The new class syntax is clean and convenient but is best thought of as “syntactic sugar” for the more fundamental class definition mechanism shown in Example 9-2. 重要的是要了解，在示例 9-2 和 9-3 中定义的类的工作方式完全相同。将 class 关键字引入语言并不会改变 JavaScript 基于原型的类的基本性质。尽管示例 9-3 使用 class 关键字，但生成的 Range 对象是一个构造函数，就像示例 9-2 中定义的版本一样。新的 class 语法更清洁方便，但是最好将其看作示例 9-2 所示的基本类定义机制的语法糖。 Note the following things about the class syntax in Example 9-3: 注意在示例 9-3 中关于 class 语法的一下几点： The class is declared with the class keyword, which is followed by the name of class and a class body in curly braces. 用 class 关键字声明类，后面接一个类名，最后是花括号包含类的正文。 The class body includes method definitions that use object literal method shorthand (which we also used in Example 9-1), where the function keyword is omitted. Unlike object literals, however, no commas are used to separate the methods from each other. (Although class bodies are superficially similar to object literals, they are not the same thing. In particular, they do not support the definition of properties with name/value pairs.) 类正文包括使用对象字面量方法速记定义的方法（我们在示例 9-1 中也使用了），其中省略了函数关键字。但是，与对象字面量不同，没有用逗号将方法彼此分开。（虽然类正文表面上与对象字面量相似，但它们不是一回事。与对象不同，类不支持具有名/值对的属性的定义。 The keyword constructor is used to define the constructor function for the class. The function defined is not actually named “constructor”, however. The class declaration statement defines a new variable Range and assigns the value of this special constructor function to that variable. 关键字 constructor 用于定义类的构造函数。但是，定义的函数实际上并不命名为 constructor。类声明语句定义一个新的变量 Range，并将此特殊构造函数的值分配给该变量。 If your class does not need to do any initialization, you can omit the constructor keyword and its body, and an empty constructor function will be implicitly created for you. 如果类不需要执行任何初始化，可以省略构造函数关键字及其正文，并将隐式创建一个空构造函数。 If you want to define a class that subclasses—or inherits from—another class, you can use the extends keyword with the class keyword: 如果要定义子类（或继承来自另一个类的类），可以使用 extends 关键字与 class 关键字： // A Span is like a Range, but instead of initializing it with // a start and an end, we initialize it with a start and a length class Span extends Range { constructor(start, length) { if (length \u003e= 0) { super(start, start + length); } else { super(start + length, start);","date":"2020-11-02","objectID":"/posts/ch9/:3:0","tags":null,"title":"第 9 章 类","uri":"/posts/ch9/"},{"categories":null,"content":"9.3.1 Static Methods You can define a static method within a class body by prefixing the method declaration with the static keyword. Static methods are defined as properties of the constructor function rather than properties of the prototype object. 可以通过使用 static 关键字作为方法声明前缀来定义类正文中的静态方法。静态方法定义为构造函数的属性，而不是原型对象的属性。 For example, suppose we added the following code to Example 9-3: 例如，假设我们将以下代码添加到示例 9-3 中： static parse(s) { let matches = s.match(/^\\((\\d+)\\.\\.\\.(\\d+)\\)$/); if (!matches) { throw new TypeError(`Cannot parse Range from \"${s}\".`) } return new Range(parseInt(matches[1]), parseInt(matches[2])); } The method defined by this code is Range.parse(), not Range.prototype.parse(), and you must invoke it through the constructor, not through an instance: 此代码定义的方法是 Range.parse()， 而不是 Range.prototype.parse()， 必须通过构造函数而不是通过实例调用它： let r = Range.parse('(1...10)'); // Returns a new Range object r.parse('(1...10)'); // TypeError: r.parse is not a function You’ll sometimes see static methods called class methods because they are invoked using the name of the class/constructor. When this term is used, it is to contrast class methods with the regular instance methods that are invoked on instances of the class. Because static methods are invoked on the constructor rather than on any particular instance, it almost never makes sense to use the this keyword in a static method. 有时会看到静态方法称为类方法，因为它们是使用类/构造函数的名称调用的。使用此术语时，将类方法与在类实例上调用的常规实例方法进行对比，由于静态方法在构造函数上调用，而不是在任何特定实例上调用，因此在静态方法中使用 this 关键字几乎从来就没有意义。 We’ll see examples of static methods in Example 9-4. 我们将在示例 9-4 中看到静态方法的示例。 ","date":"2020-11-02","objectID":"/posts/ch9/:3:1","tags":null,"title":"第 9 章 类","uri":"/posts/ch9/"},{"categories":null,"content":"9.3.2 Getters, Setters, and other Method Forms Within a class body, you can define getter and setter methods (§6.10.6) just as you can in object literals. The only difference is that in class bodies, you don’t put a comma after the getter or setter. Example 9-4 includes a practical example of a getter method in a class. 在类正文中，可以定义 getter 和 setter 方法（§6.10.6），就像在对象字面量中一样。唯一的区别是，在类正文中，不会将逗号放在 getter 或 setter 之后。示例 9-4 包括类中 getter 方法的实际示例。 In general, all of the shorthand method definition syntaxes allowed in object literals are also allowed in class bodies. This includes generator methods (marked with *) and methods whose names are the value of an expression in square brackets. In fact, you’ve already seen (in Example 9-3) a generator method with a computed name that makes the Range class iterable: 通常，对象字面量中允许的所有速记方法定义语法也允许在类正文中使用。这包括生成器方法（用 * 标记）和名称为方括号中表达式值的方法。事实上，已经看到了（在示例 9-3 中）具有计算名称的生成器方法，该方法使 Range 类可重复： *[Symbol.iterator]() { for(let x = Math.ceil(this.from); x \u003c= this.to; x++) yield x; } ","date":"2020-11-02","objectID":"/posts/ch9/:3:2","tags":null,"title":"第 9 章 类","uri":"/posts/ch9/"},{"categories":null,"content":"9.3.3 Public, Private, and Static Fields In the discussion here of classes defined with the class keyword, we have only described the definition of methods within the class body. The ES6 standard only allows the creation of methods (including getters, setters, and generators) and static methods; it does not include syntax for defining fields. If you want to define a field (which is just an object-oriented synonym for “property”) on a class instance, you must do that in the constructor function or in one of the methods. And if you want to define a static field for a class, you must do that outside the class body, after the class has been defined. Example 9-4 includes examples of both kinds of fields. 在此处对使用 class 关键字定义的类的讨论中，我们只描述了类正文中方法的定义。ES6 标准只允许创建方法（包括 getter、setter 和生成器）和静态方法；它不包括用于定义字段的语法。如果要在类实例上定义字段（这只是面向对象中\"属性\"的同义词），则必须在构造函数函数或其中一个方法中这样做。必须在类正文之外类定义后，才能为类定义静态字段。示例 9-4 包括这各种字段的示例。 Standardization is underway, however, for extended class syntax that allows the definition of instance and static fields, in both public and private forms. The code shown in the rest of this section is not yet standard JavaScript as of early 2020 but is already supported in Chrome and partially supported (public instance fields only) in Firefox. The syntax for public instance fields is in common use by JavaScript programmers using the React framework and the Babel transpiler. 但是，对于允许以公有和私有形式定义实例和静态字段的扩展类语法正在进行标准化。本节其余部分中显示的代码在 2020 年初还不是标准 JavaScript，但在 Chrome 中已经支持，并且 Firefox 中已部分支持（仅使公有实例字段）。使用 React 框架和 Babel 编译器的 JavaScript 程序员常用公有实例字段的语法。 Suppose you’re writing a class like this one, with a constructor that initializes three fields: 假设你正在编写一个这样的类，其中一个构造函数初始化了三个字段： class Buffer { constructor() { this.size = 0; this.capacity = 4096; this.buffer = new Uint8Array(this.capacity); } } With the new instance field syntax that is likely to be standardized, you could instead write: 使用可能标准化的新实例字段语法，可以这样编写： class Buffer { size = 0; capacity = 4096; buffer = new Uint8Array(this.capacity); } The field initialization code has moved out of the constructor and now appears directly in the class body. (That code is still run as part of the constructor, of course. If you do not define a constructor, the fields are initialized as part of the implicitly created constructor.) The this. prefixes that appeared on the lefthand side of the assignments are gone, but note that you still must use this. to refer to these fields, even on the righthand side of the initializer assignments. The advantage of initializing your instance fields in this way is that this syntax allows (but does not require) you to put the initializers up at the top of the class definition, making it clear to readers exactly what fields will hold the state of each instance. You can declare fields without an initializer by just writing the name of the field followed by a semicolon. If you do that, the initial value of the field will be undefined. It is better style to always make the initial value explicit for all of your class fields. 字段初始化代码已移出构造函数，现在直接显示在类正文中。（当然，该代码仍作为构造函数的一部分运行。如果不定义构造函数，则字段初始化为隐式创建的构造函数的一部分。赋值左侧的 this. 前缀消失，但请注意即使是在初始化赋值的右侧，仍必须使用 this. 前缀引用这些字段。这种方式初始化实例字段的优点是，此语法允许（但不需要）将初始化放在类定义的顶部，使读者清楚地了解字段在每个实例将保存的状态。可以通过字段名后面跟一个分号来只声明不初始化一个字段。如果这样做，字段的初始值将是 undefined。显式设定初始化字段的值是比较好的风格。 Before the addition of this field syntax, class bodies looked a lot like object literals using shortcut method syntax, except that the commas had been removed. This field syntax—with equals signs and semicolons instead of colons and commas—makes it clear that class bodies are not at all the same as object literals. 在添加字段语法之前，类正文看起来很像使用快捷方法语法的对象字面量，只不过逗号被删除。字段语法（使用等号和分号代替冒号和逗号）清楚地表明类正文与对象字面量不完全相同。 The same proposal that seeks to standardize these instance fields also defines private instance fields. If you use the instance field initialization syntax shown in the previous example to define a field whose name begins with # (which is not normally a legal character in JavaScript identifiers), that field wi","date":"2020-11-02","objectID":"/posts/ch9/:3:3","tags":null,"title":"第 9 章 类","uri":"/posts/ch9/"},{"categories":null,"content":"9.3.4 Example: A Complex Number Class Example 9-4 defines a class to represent complex numbers. The class is a relatively simple one, but it includes instance methods (including getters), static methods, instance fields, and static fields. It includes some commented-out code demonstrating how we might use the not-yet-standard syntax for defining instance fields and static fields within the class body. 示例 9-4 定义了一个表示复数的类。该类相对简单，但它包括实例方法（包括 getters）、静态方法、实例字段和静态字段。它包括一些注释掉的代码，演示如何使用尚未加入标准的语法定义类正文中的实例字段和静态字段。 Example 9-4. Complex.js: a complex number class 示例 9-4：Complex.js：一个复数类 /** * Instances of this Complex class represent complex numbers. * Recall that a complex number is the sum of a real number and an * imaginary number and that the imaginary number i is the square root of -1. */ class Complex { // Once class field declarations are standardized, we could declare // private fields to hold the real and imaginary parts of a complex number // here, with code like this: // // #r = 0; // #i = 0; // This constructor function defines the instance fields r and i on every // instance it creates. These fields hold the real and imaginary parts of // the complex number: they are the state of the object. constructor(real, imaginary) { this.r = real; // This field holds the real part of the number. this.i = imaginary; // This field holds the imaginary part. } // Here are two instance methods for addition and multiplication // of complex numbers. If c and d are instances of this class, we // might write c.plus(d) or d.times(c) plus(that) { return new Complex(this.r + that.r, this.i + that.i); } times(that) { return new Complex(this.r * that.r - this.i * that.i, this.r * that.i + this.i * that.r); } // And here are static variants of the complex arithmetic methods. // We could write Complex.sum(c,d) and Complex.product(c,d) static sum(c, d) { return c.plus(d); } static product(c, d) { return c.times(d); } // These are some instance methods that are defined as getters // so they're used like fields. The real and imaginary getters would // be useful if we were using private fields this.#r and this.#i get real() { return this.r; } get imaginary() { return this.i; } get magnitude() { return Math.hypot(this.r, this.i); } // Classes should almost always have a toString() method toString() { return `{${this.r},${this.i}}`; } // It is often useful to define a method for testing whether // two instances of your class represent the same value equals(that) { return that instanceof Complex \u0026\u0026 this.r === that.r \u0026\u0026 this.i === that.i; } // Once static fields are supported inside class bodies, we could // define a useful Complex.ZERO constant like this: // static ZERO = new Complex(0,0); } // Here are some class fields that hold useful predefined complex numbers. Complex.ZERO = new Complex(0,0); Complex.ONE = new Complex(1,0); Complex.I = new Complex(0,1); With the Complex class of Example 9-4 defined, we can use the constructor, instance fields, instance methods, class fields, and class methods with code like this: 定义了示例 9-4 的 Complex 类后，我们可以将构造函数、实例字段、实例方法、类字段和类方法如下使用： let c = new Complex(2, 3); // Create a new object with the constructor let d = new Complex(c.i, c.r); // Use instance fields of c c.plus(d).toString() // =\u003e \"{5,5}\"; use instance methods c.magnitude // =\u003e Math.hypot(2,3); use a getter function Complex.product(c, d) // =\u003e new Complex(0, 13); a static method Complex.ZERO.toString() // =\u003e \"{0,0}\"; a static property ","date":"2020-11-02","objectID":"/posts/ch9/:3:4","tags":null,"title":"第 9 章 类","uri":"/posts/ch9/"},{"categories":null,"content":"9.4 Adding Methods to Existing Classes JavaScript’s prototype-based inheritance mechanism is dynamic: an object inherits properties from its prototype, even if the properties of the prototype change after the object is created. This means that we can augment JavaScript classes simply by adding new methods to their prototype objects. JavaScript 基于原型的继承机制是动态的：对象从其原型继承属性，即使原型的属性在创建对象后发生更改。这意味着我们只需向原型对象添加新方法，即可扩展 JavaScript 类。 Here, for example, is code that adds a method for computing the complex conjugate to the Complex class of Example 9-4: 例如，下面是将计算共轭复数的方法添加到示例 9-4 的 Complex 类的代码： // Return a complex number that is the complex conjugate of this one. Complex.prototype.conj = function() { return new Complex(this.r, -this.i); }; The prototype object of built-in JavaScript classes is also open like this, which means that we can add methods to numbers, strings, arrays, functions, and so on. This is useful for implementing new language features in older versions of the language: JavaScript 类内置的原型对象也是这样展现的，这意味着我们可以向数字、字符串、数组、函数等添加方法。这对于在旧版本的语言中实现新特性非常有用： // If the new String method startsWith() is not already defined... if (!String.prototype.startsWith) { // ...then define it like this using the older indexOf() method. String.prototype.startsWith = function(s) { return this.indexOf(s) === 0; }; } Here is another example: 这是另外一个例子： // Invoke the function f this many times, passing the iteration number // For example, to print \"hello\" 3 times: // let n = 3; // n.times(i =\u003e { console.log(`hello ${i}`); }); Number.prototype.times = function(f, context) { let n = this.valueOf(); for(let i = 0; i \u003c n; i++) f.call(context, i); }; Adding methods to the prototypes of built-in types like this is generally considered to be a bad idea because it will cause confusion and compatibility problems in the future if a new version of JavaScript defines a method with the same name. It is even possible to add methods to Object.prototype, making them available for all objects. But this is never a good thing to do because properties added to Object.prototype are visible to for/in loops (though you can avoid this by using Object.defineProperty() [§14.1] to make the new property non-enumerable). 向这样在内置类型的原型添加方法通常被认为是一个坏主意，因为如果新版本的 JavaScript 定义具有相同名称的方法，将来就会造成混淆和兼容性问题。甚至可以向 Object.prototype 添加方法，使它们可作用于所有对象。但这从来就不是一件好事，因为添加到 Object.prototype 的属性对 for/in 循环可见（尽管可以使用 Object.defineProperty()（§14.1）来使新属性不可枚举来避免这种情况）。 ","date":"2020-11-02","objectID":"/posts/ch9/:4:0","tags":null,"title":"第 9 章 类","uri":"/posts/ch9/"},{"categories":null,"content":"9.5 Subclasses In object-oriented programming, a class B can extend or subclass another class A. We say that A is the superclass and B is the subclass. Instances of B inherit the methods of A. The class B can define its own methods, some of which may override methods of the same name defined by class A. If a method of B overrides a method of A, the overriding method in B often needs to invoke the overridden method in A. Similarly, the subclass constructor B() must typically invoke the superclass constructor A() in order to ensure that instances are completely initialized. 在面向对象的编程中，B 类可以扩展 A 类或成为 A 类子类。我们称 A 是父类，B 是子类。B 的实例继承 A 的方法。B 类可以定义自有方法，使用相同名称可以重写类 A 中的方法。如果 B 的方法重写 A 方法，则 B 中的重写方法通常需要调用 A 中的重写方法。同样，子类构造函数 B() 通常必须调用父类构造函数 A()，以确保实例完全初始化。 This section starts by showing how to define subclasses the old, pre-ES6 way, and then quickly moves on to demonstrate subclassing using the class and extends keywords and superclass constructor method invocation with the super keyword. Next is a subsection about avoiding subclasses and relying on object composition instead of inheritance. The section ends with an extended example that defines a hierarchy of Set classes and demonstrates how abstract classes can be used to separate interface from implementation. 本节首先演示 ES6 之前如何定义子类，然后演示使用 class 和 extends 关键字的子类和使用 super 关键字调用父类构造函数。再接下来一节是关于避免使用子类而依靠对象组合代替继承。本章最后结束于一个扩展的示例，定义 Set 类的层次结构和演示如何使用抽象类将接口与实现分离。 ","date":"2020-11-02","objectID":"/posts/ch9/:5:0","tags":null,"title":"第 9 章 类","uri":"/posts/ch9/"},{"categories":null,"content":"9.5.1 Subclasses and Prototypes Suppose we wanted to define a Span subclass of the Range class from Example 9-2. This subclass will work just like a Range, but instead of initializing it with a start and an end, we’ll instead specify a start and a distance, or span. An instance of this Span class is also an instance of the Range superclass. A span instance inherits a customized toString() method from Span.prototype, but in order to be a subclass of Range, it must also inherit methods (such as includes()) from Range.prototype. 假设我们想要给示例 9-2 中 Range 类定义 Span 子类。此子类的工作方式与 Range 一样，但我们初始化改为指定开始和范围，而不是制定开始和结束。Span 类的实例也是父类 Range 的实例。Span 实例从 Span.prototype 继承自定义的 toString() 方法，但为了成为 Range 的子类，它还必须从 Range.prototype 继承方法（如 includes()）。 Example 9-5. Span.js: a simple subclass of Range 实例 9-5：Span.js：Range 一个简单的子类 // This is the constructor function for our subclass function Span(start, span) { if (span \u003e= 0) { this.from = start; this.to = start + span; } else { this.to = start; this.from = start + span; } } // Ensure that the Span prototype inherits from the Range prototype Span.prototype = Object.create(Range.prototype); // We don't want to inherit Range.prototype.constructor, so we // define our own constructor property. Span.prototype.constructor = Span; // By defining its own toString() method, Span overrides the // toString() method that it would otherwise inherit from Range. Span.prototype.toString = function() { return `(${this.from}... +${this.to - this.from})`; }; In order to make Span a subclass of Range, we need to arrange for Span.prototype to inherit from Range.prototype. The key line of code in the preceding example is this one, and if it makes sense to you, you understand how subclasses work in JavaScript: 为了使 Span 成为 Range 的子类，我们需要使 Span.prototype 从 Range.prototype 继承。前面示例中的关键代码行是此代码行，如果能理解子类使如何工作的，它是非常有意义的： Span.prototype = Object.create(Range.prototype); Objects created with the Span() constructor will inherit from the Span.prototype object. But we created that object to inherit from Range.prototype, so Span objects will inherit from both Span.prototype and Range.prototype. 使用 Span() 构造函数创建的对象将从 Span.prototype 对象继承。但是，我们创建了该对象并继承 Range.prototype，因此 Span 对象将同时从 Span.prototype 和 Range.prototype 继承。 You may notice that our Span() constructor sets the same from and to properties that the Range() constructor does and so does not need to invoke the Range() constructor to initialize the new object. Similarly, Span’s toString() method completely re-implements the string conversion without needing to call Range’s version of toString(). This makes Span a special case, and we can only really get away with this kind of subclassing because we know the implementation details of the superclass. A robust subclassing mechanism needs to allow classes to invoke the methods and constructor of their superclass, but prior to ES6, JavaScript did not have a simple way to do these things. 可能会注意到，我们的 Span() 构造函数设置与 Range() 构造函数相同的 from 和 to 属性，因此不需要调用 Range() 构造函数来初始化新对象。同样，Span 的 toString() 方法完全重新实现字符串转换，而无需调用 Range 版本的 toString()。这使得 Span 成为特例，我们必须摆脱这种子类，因为这种情况是我们知道父类的实现细节。一个健壮的子类机制需要允许类调用其父类的方法和构造函数，但在 ES6 之前，JavaScript 没有一个简单的方法来执行这些操作。 Fortunately, ES6 solves these problems with the super keyword as part of the class syntax. The next section demonstrates how it works. 幸运的是，ES6 用 super 关键字作为类语法一部分解决了这些问题。下一节演示它是如何工作的。 ","date":"2020-11-02","objectID":"/posts/ch9/:5:1","tags":null,"title":"第 9 章 类","uri":"/posts/ch9/"},{"categories":null,"content":"9.5.2 Subclasses with extends and super In ES6 and later, you can create a superclass simply by adding an extends clause to a class declaration, and you can do this even for built-in classes: 在 ES6 之后，可以简单的在类声明时接一个 extends 从句添加一个父类，即使对于内置类也可以这样做： // A trivial Array subclass that adds getters for the first and last elements. class EZArray extends Array { get first() { return this[0]; } get last() { return this[this.length-1]; } } let a = new EZArray(); a instanceof EZArray // =\u003e true: a is subclass instance a instanceof Array // =\u003e true: a is also a superclass instance. a.push(1,2,3,4); // a.length == 4; we can use inherited methods a.pop() // =\u003e 4: another inherited method a.first // =\u003e 1: first getter defined by subclass a.last // =\u003e 3: last getter defined by subclass a[1] // =\u003e 2: regular array access syntax still works. Array.isArray(a) // =\u003e true: subclass instance really is an array EZArray.isArray(a) // =\u003e true: subclass inherits static methods, too! This EZArray subclass defines two simple getter methods. Instances of EZArray behave like ordinary arrays, and we can use inherited methods and properties like push(), pop(), and length. But we can also use the first and last getters defined in the subclass. Not only are instance methods like pop() inherited, but static methods like Array.isArray are also inherited. This is a new feature enabled by ES6 class syntax: EZArray() is a function, but it inherits from Array(): EZArray 子类定义了两个简单的 getter 方法。EZArray 实例的行为类似于普通数组，我们可以使用继承的方法和属性，如 push()、pop() 和 length。但是，我们也可以使用子类中定义的 first 和 last getter 方法。不仅继承实例方法如 pop() ，也继承 Array.isArray 等静态方法。这是 ES6 类语法启用的新特性：EZArray() 是一个函数，但它从 Array() 继承： // EZArray inherits instance methods because EZArray.prototype // inherits from Array.prototype Array.prototype.isPrototypeOf(EZArray.prototype) // =\u003e true // And EZArray inherits static methods and properties because // EZArray inherits from Array. This is a special feature of the // extends keyword and is not possible before ES6. Array.isPrototypeOf(EZArray) // =\u003e true Our EZArray subclass is too simple to be very instructive. Example 9-6 is a more fully fleshed-out example. It defines a TypedMap subclass of the built-in Map class that adds type checking to ensure that the keys and values of the map are of the specified types (according to typeof). Importantly, this example demonstrates the use of the super keyword to invoke the constructor and methods of the superclass. EZArray 子类太简单了，没有教育意义。示例 9-6 是一个更充实的示例。它定义了内置 Map 类的 TypedMap 子类，该子类添加类型检查以确保映射的键和值是指定的类型（根据 typeof）。重要的是，此示例演示了使用 super 关键字来调用父类的构造函数和方法。 Example 9-6. TypedMap.js: a subclass of Map that checks key and value types 示例 9-6：TypedMap.js：一个检测 key 和 value 类型的 Map 子类 class TypedMap extends Map { constructor(keyType, valueType, entries) { // If entries are specified, check their types if (entries) { for(let [k, v] of entries) { if (typeof k !== keyType || typeof v !== valueType) { throw new TypeError(`Wrong type for entry [${k}, ${v}]`); } } } // Initialize the superclass with the (type-checked) initial entries super(entries); // And then initialize this subclass by storing the types this.keyType = keyType; this.valueType = valueType; } // Now redefine the set() method to add type checking for any // new entries added to the map. set(key, value) { // Throw an error if the key or value are of the wrong type if (this.keyType \u0026\u0026 typeof key !== this.keyType) { throw new TypeError(`${key}is not of type ${this.keyType}`); } if (this.valueType \u0026\u0026 typeof value !== this.valueType) { throw new TypeError(`${value}is not of type ${this.valueType}`); } // If the types are correct, we invoke the superclass's version of // the set() method, to actually add the entry to the map. And we // return whatever the superclass method returns. return super.set(key, value); } } The first two arguments to the TypedMap() constructor are the desired key and value types. These should be strings, such as “number” and “boolean”, that the typeof operator returns. Y","date":"2020-11-02","objectID":"/posts/ch9/:5:2","tags":null,"title":"第 9 章 类","uri":"/posts/ch9/"},{"categories":null,"content":"9.5.3 Delegation Instead of Inheritance The extends keyword makes it easy to create subclasses. But that does not mean that you should create lots of subclasses. If you want to write a class that shares the behavior of some other class, you can try to inherit that behavior by creating a subclass. But it is often easier and more flexible to get that desired behavior into your class by having your class create an instance of the other class and simply delegating to that instance as needed. You create a new class not by subclassing, but instead by wrapping or “composing” other classes. This delegation approach is often called “composition”, and it is an oft-quoted maxim of object-oriented programming that one should “favor composition over inheritance.”2 extends 关键字便于创建子类。但这并不意味着应该创建大量的子类。如果要编写某些其他类共享的行为的类，可以尝试通过创建子类来继承该行为。但是，通常将期望的行为编写在类中比用类创建其他类的实例并根据需要委托给该实例更简单也更灵活。创建新类不将其作为子类，而是通过包装或\"组合\"其他类。这种委托方法通常称为\"组合\"，它是一种面向对象编程经常被引用的座右铭\"倾向于组合而不是继承\"。^2 Suppose, for example, we wanted a Histogram class that behaves something like JavaScript’s Set class, except that instead of just keeping track of whether a value has been added to set or not, it instead maintains a count of the number of times the value has been added. Because the API for this Histogram class is similar to Set, we might consider subclassing Set and adding a count() method. On the other hand, once we start thinking about how we might implement this count() method, we might realize that the Histogram class is more like a Map than a Set because it needs to maintain a mapping between values and the number of times they have been added. So instead of subclassing Set, we can create a class that defines a Set-like API but implements those methods by delegating to an internal Map object. Example 9-7 shows how we could do this. 例如，假设我们想要一个行为类似于 JavaScript 的 Set 类的 Histogram 类，只不过，它不只是跟踪是否给集合添加了值，还维护该值添加次数的计数。由于 Histogram 类的 API 与 Set 类似，因此我们可以考虑 Set 子类并添加 count() 方法。另一方面，一旦我们开始考虑如何实现 count() 方法，我们可能会意识到 Histogram 类更像是一个 Map 而不是一个 Set，因为它需要维护值与添加它们次数之间的映射。因此，我们可以创建一个类，该类定义一个类似 Set 的 API，但委托内部 Map 对象来实现这些方法，而不是创建 Set 的子类。示例 9-7 显示了我们如何做到这一点。 Example 9-7. Histogram.js: a Set-like class implemented with delegation 示例 9-7：Histogram.js：使用委托实现一个类似 Set 的类 /** * A Set-like class that keeps track of how many times a value has * been added. Call add() and remove() like you would for a Set, and * call count() to find out how many times a given value has been added. * The default iterator yields the values that have been added at least * once. Use entries() if you want to iterate [value, count] pairs. */ class Histogram { // To initialize, we just create a Map object to delegate to constructor() { this.map = new Map(); } // For any given key, the count is the value in the Map, or zero // if the key does not appear in the Map. count(key) { return this.map.get(key) || 0; } // The Set-like method has() returns true if the count is non-zero has(key) { return this.count(key) \u003e 0; } // The size of the histogram is just the number of entries in the Map. get size() { return this.map.size; } // To add a key, just increment its count in the Map. add(key) { this.map.set(key, this.count(key) + 1); } // Deleting a key is a little trickier because we have to delete // the key from the Map if the count goes back down to zero. delete(key) { let count = this.count(key); if (count === 1) { this.map.delete(key); } else if (count \u003e 1) { this.map.set(key, count - 1); } } // Iterating a Histogram just returns the keys stored in it [Symbol.iterator]() { return this.map.keys(); } // These other iterator methods just delegate to the Map object keys() { return this.map.keys(); } values() { return this.map.values(); } entries() { return this.map.entries(); } } All the Histogram() constructor does in Example 9-7 is create a Map object. And most of the methods are one-liners that just delegate to a method of the map, making the implementation quite simple. Because we used delegation rather than inheritance, a Histogram obj","date":"2020-11-02","objectID":"/posts/ch9/:5:3","tags":null,"title":"第 9 章 类","uri":"/posts/ch9/"},{"categories":null,"content":"9.5.4 Class Hierarchies and Abstract Classes Example 9-6 demonstrated how we can subclass Map. Example 9-7 demonstrated how we can instead delegate to a Map object without actually subclassing anything. Using JavaScript classes to encapsulate data and modularize your code is often a great technique, and you may find yourself using the class keyword frequently. But you may find that you prefer composition to inheritance and that you rarely need to use extends (except when you’re using a library or framework that requires you to extend its base classes). 示例 9-6 演示了如创建 Map 的子类。示例 9-7 演示了如何在不创建子类的情况下将委托给 Map 对象。使用 JavaScript 类封装数据和模块化代码通常是一种很好的技术，你可能会发现自己经常使用类关键字。但是，你可能会发现，你更喜欢组合而不是继承，而且很少需要使用 extends（除非使用需要扩展的库或框架）。 There are some circumstances when multiple levels of subclassing are appropriate, however, and we’ll end this chapter with an extended example that demonstrates a hierarchy of classes representing different kinds of sets. (The set classes defined in Example 9-8 are similar to, but not completely compatible with, JavaScript’s built-in Set class.) 但是，在某些情况下，多个级别的子类是合适的，我们将举一个扩展示例来结束本章，通过描述不同种类的集合来演示类的层次结构。（示例 9-8 中定义的类跟 JavaScript 中的内置 Set 类很相似，但不完全兼容。） Example 9-8 defines lots of subclasses, but it also demonstrates how you can define abstract classes—classes that do not include a complete implementation—to serve as a common superclass for a group of related subclasses. An abstract superclass can define a partial implementation that all subclasses inherit and share. The subclasses, then, only need to define their own unique behavior by implementing the abstract methods defined—but not implemented—by the superclass. Note that JavaScript does not have any formal definition of abstract methods or abstract classes; I’m simply using that name here for unimplemented methods and incompletely implemented classes. 示例 9-8 定义了大量子类，但它也演示了如何定义抽象类（不包括完整实现的类）作为一组相关子类的通用父类。抽象父类可以定义所有子类继承和共享的部分实现。因此，子类只需要通过实现父类定义的抽象方法（没有实现）来定义它们自己的独特行为。请注意，JavaScript 对抽象方法或抽象类没有任何正式定义；我只是将这个名字用于未实现的方法和不完全实现的类。 Example 9-8 is well commented and stands on its own. I encourage you to read it as a capstone example for this chapter on classes. The final class in Example 9-8 does a lot of bit manipulation with the \u0026, |, and ~ operators, which you can review in §4.8.3. 示例 9-8 评论良好，并且独立。我鼓励你把它作为本章关于类的顶级示例。示例 9-8 用 \u0026、| 和 ~ 运算符执行大量位操作，可以在 §4.8.3 中查看这些运算符。 Example 9-8. Sets.js: a hierarchy of abstract and concrete set classes 示例 9-8：Sets.js：抽象类和实体类的层次 /** * The AbstractSet class defines a single abstract method, has(). */ class AbstractSet { // Throw an error here so that subclasses are forced // to define their own working version of this method. has(x) { throw new Error(\"Abstract method\"); } } /** * NotSet is a concrete subclass of AbstractSet. * The members of this set are all values that are not members of some * other set. Because it is defined in terms of another set it is not * writable, and because it has infinite members, it is not enumerable. * All we can do with it is test for membership and convert it to a * string using mathematical notation. */ class NotSet extends AbstractSet { constructor(set) { super(); this.set = set; } // Our implementation of the abstract method we inherited has(x) { return !this.set.has(x); } // And we also override this Object method toString() { return `{ x| x ∉ ${this.set.toString()}}`; } } /** * Range set is a concrete subclass of AbstractSet. Its members are * all values that are between the from and to bounds, inclusive. * Since its members can be floating point numbers, it is not * enumerable and does not have a meaningful size. */ class RangeSet extends AbstractSet { constructor(from, to) { super(); this.from = from; this.to = to; } has(x) { return x \u003e= this.from \u0026\u0026 x \u003c= this.to; } toString() { return `{ x| ${this.from}≤ x ≤ ${this.to}}`; } } /* * AbstractEnumerableSet is an abstract subclass of AbstractSet. It defines * an abstract getter that returns the size of the set and also defines an * abstract iterator. And i","date":"2020-11-02","objectID":"/posts/ch9/:5:4","tags":null,"title":"第 9 章 类","uri":"/posts/ch9/"},{"categories":null,"content":"9.6 Summary This chapter has explained the key features of JavaScript classes: 本章说明了 JavaScript 类的主要功能： Objects that are members of the same class inherit properties from the same prototype object. The prototype object is the key feature of JavaScript classes, and it is possible to define classes with nothing more than the Object.create() method. 同一类的成员对象从同一原型对象继承属性。原型对象是 JavaScript 类的关键特性，只有 Object.create() 方法可以定义类。 Prior to ES6, classes were more typically defined by first defining a constructor function. Functions created with the function keyword have a prototype property, and the value of this property is an object that is used as the prototype of all objects created when the function is invoked with new as a constructor. By initializing this prototype object, you can define the shared methods of your class. Although the prototype object is the key feature of the class, the constructor function is the public identity of the class. 在 ES6 之前，典型的类定义先定义构造函数。使用 function 关键字创建的函数具有原型属性，this 属性的值是使用 new 将函数用作构造函数调用时创建的对象的原型对象。通过初始化此原型对象，可以定义类的共享方法。虽然原型对象是类的关键特性，但构造函数是类的公共标识。 ES6 introduces a class keyword that makes it easier to define classes, but under the hood, constructor and prototype mechanism remains the same. ES6 引入了一个 class 关键字，它使定义类更加容易，但它只是个语法糖，构造函数和原型机制保持不变。 Subclasses are defined using the extends keyword in a class declaration. 子类使用类声明中的 extends 关键字定义。 Subclasses can invoke the constructor of their superclass or overridden methods of their superclass with the super keyword. 子类可以使用 super 关键字调用其父类的构造函数或父类的重写方法。 Except functions returned by the ES5 Function.bind() method. Bound functions have no prototype property of their own, but they use the prototype of the underlying function if they are invoked as constructors. See Design Patterns (Addison-Wesley Professional) by Erich Gamma et al. or Effective Java (Addison-Wesley Professional) by Joshua Bloch, for example. 除了 ES5 Function.bind() 方法返回的函数。绑定函数没有自己的原型属性，但如果它们作为构造函数调用，则它们使用基础函数的原型。 例如，见《Design Patterns (Addison-Wesley Professional)》作者 Erich Gamma 等，或者《Effective Java (Addison-Wesley Professional)》作者 Joshua Bloch。 ","date":"2020-11-02","objectID":"/posts/ch9/:6:0","tags":null,"title":"第 9 章 类","uri":"/posts/ch9/"},{"categories":null,"content":"The goal of modular programming is to allow large programs to be assembled using modules of code from disparate authors and sources and for all of that code to run correctly even in the presence of code that the various module authors did not anticipate. As a practical matter, modularity is mostly about encapsulating or hiding private implementation details and keeping the global namespace tidy so that modules cannot accidentally modify the variables, functions, and classes defined by other modules. 模块化编程的目标是允许使用来自不同作者和源的代码模块来组装大型程序，并且即使出现了不同模块作者没有预料到的代码，所有这些代码也能正确运行。作为一个实际问题，模块化主要是关于封装或隐藏私有实现细节和保持全局名称空间整洁，以便模块不会意外地修改其他模块定义的变量、函数和类。 Until recently, JavaScript had no built-in support for modules, and programmers working on large code bases did their best to use the weak modularity available through classes, objects, and closures. Closure-based modularity, with support from code-bundling tools, led to a practical form of modularity based on a require() function, which was adopted by Node. require()-based modules are a fundamental part of the Node programming environment but were never adopted as an official part of the JavaScript language. Instead, ES6 defines modules using import and export keywords. Although import and export have been part of the language for years, they were only implemented by web browsers and Node relatively recently. And, as a practical matter, JavaScript modularity still depends on code-bundling tools. 直到最近，JavaScript 还没有对模块的内置支持，在大型代码库上工作的程序员尽力使用类、对象和闭包的弱模块性。基于闭包的模块化在代码捆绑工具的支持下，实际使用中形成了一种基于 require() 函数的模块化形式，Node 采用了这种形式。基于 require() 的模块是 Node 编程环境的基本部分，但从未被作为 JavaScript 语言的正式部分采用。相反，ES6 使用 import 和 import 关键字定义模块。虽然 import 和 export 已经成为语言的一部分很多年了，但是它们只是最近才被 web 浏览器和 Node 实现。而且，作为一个实际问题，JavaScript 模块化仍然依赖于代码捆绑工具。 The sections that follow cover: 以下各节包括: Do-it-yourself modules with classes, objects, and closures Node modules using require() ES6 modules using export, import, and import() 使用类、对象和闭包自己做模块 使用 require() 的 Node 模块 使用 export、import 和 import() 的ES6模块 ","date":"2020-11-02","objectID":"/posts/ch10/:0:0","tags":null,"title":"第 10 章 模块","uri":"/posts/ch10/"},{"categories":null,"content":"10.1 Modules with Classes, Objects, and Closures Though it may be obvious, it is worth pointing out that one of the important features of classes is that they act as modules for their methods. Think back to Example 9-8. That example defined a number of different classes, all of which had a method named has(). But you would have no problem writing a program that used multiple set classes from that example: there is no danger that the implementation of has() from SingletonSet will overwrite the has() method of BitSet, for example. 尽管这可能很明显，但值得指出的是，类的重要特性之一是它们充当其方法的模块。回想一下示例 9-8。该示例定义了许多不同的类，所有这些类都有一个名为 has() 的方法。但是，在编写使用该示例中的多个 set 类的程序时没有问题：例如，SingletonSet 的 has() 实现不会覆盖 BitSet 的 has() 方法。 The reason that the methods of one class are independent of the methods of other, unrelated classes is that the methods of each class are defined as properties of independent prototype objects. The reason that classes are modular is that objects are modular: defining a property in a JavaScript object is a lot like declaring a variable, but adding properties to objects does not affect the global namespace of a program, nor does it affect the properties of other objects. JavaScript defines quite a few mathematical functions and constants, but instead of defining them all globally, they are grouped as properties of a single global Math object. This same technique could have been used in Example 9-8. Instead of defining global classes with names like SingletonSet and BitSet, that example could have been written to define only a single global Sets object, with properties referencing the various classes. Users of this Sets library could then refer to the classes with names like Sets.Singleton and Sets.Bit. 一个类的方法独立于其他不相关类的方法的原因是，每个类的方法都被定义为独立原型对象的属性。类是模块化的原因是对象是模块化的：在 JavaScript 对象中定义属性非常类似于声明变量，但是向对象添加属性不会影响程序的全局命名空间，也不会影响其他对象的属性。JavaScript 定义了很多数学函数和常量，但它们不是全局定义的，而是分组为 Math 全局对象的单个属性。同样的技术也可以用在示例 9-8 中。不使用 SingletonSet 和 BitSet 这样的名称定义全局类，这个示例可以编写为只有一个 Sets 全局对象，Sets 的属性引用各种类。然后，用户可以使用这个 Sets 库通过 Sets.Singleton 和 Sets.Bit 的名称来获取类的引用。 Using classes and objects for modularity is a common and useful technique in JavaScript programming, but it doesn’t go far enough. In particular, it doesn’t offer us any way to hide internal implementation details inside the module. Consider Example 9-8 again. If we were writing that example as a module, maybe we would have wanted to keep the various abstract classes internal to the module, only making the concrete subclasses available to users of the module. Similarly, in the BitSet class, the _valid() and _has() methods are internal utilities that should not really be exposed to users of the class. And BitSet.bits and BitSet.masks are implementation details that would be better off hidden. 使用类和对象实现模块化是 JavaScript 编程中常见而有用的技术，但这还不够。特别是，它没有提供任何方法来隐藏模块内部的实现细节。再次考虑示例 9-8。如果我们将该示例作为一个模块来编写，也许我们会希望将各种抽象类保留在模块内部，只让具体的子类对模块的用户可用。同样，在 BitSet 类中，_valid() 和 _has() 方法是内部实用程序，不应该向类的用户公开它们。BitSet.bits 和 BitSet.masks 是实现细节，最好隐藏起来。 As we saw in §8.6, local variables and nested functions declared within a function are private to that function. This means that we can use immediately invoked function expressions to achieve a kind of modularity by leaving the implementation details and utility functions hidden within the enclosing function but making the public API of the module the return value of the function. In the case of the BitSet class, we might structure the module like this: 正如我们在 §8.6 中看到的，在函数中声明的局部变量和嵌套函数是该函数私有的。这意味着我们可以使用立即调用函数表达式来实现一种模块化，方法是将实现细节和实用函数隐藏在封装的函数中，而将模块的公共 API 作为函数的返回值。在 BitSet 类的情况下，我们可以像这样构造模块: const BitSet = (function() { // Set BitSet to the return value of this function // Private implementation details here function isValid(set, n) { ... } function has(set, byte, bit) { ... } const BITS = new Uint8Array([1, 2, 4, 8, 16, 32, 64, 128]); const MASKS = new Uint8Array([~1, ~2, ~4, ~8, ~16, ~32, ~64, ~128]); // The public API of the module is just the BitSet class, which we define // and return here. The clas","date":"2020-11-02","objectID":"/posts/ch10/:1:0","tags":null,"title":"第 10 章 模块","uri":"/posts/ch10/"},{"categories":null,"content":"10.1.1 Automating Closure-Based Modularity Note that it is a fairly mechanical process to transform a file of JavaScript code into this kind of module by inserting some text at the beginning and end of the file. All that is needed is some convention for the file of JavaScript code to indicate which values are to be exported and which are not. 请注意，通过在文件的开头和结尾插入一些文本来将 JavaScript 代码文件转换为这种模块是相当机械的过程。所需要做的只是为 JavaScript 代码文件提供一些约定，以指示要导出的值和不导出的值。 Imagine a tool that takes a set of files, wraps the content of each of those files within an immediately invoked function expression, keeps track of the return value of each function, and concatenates everything into one big file. The result might look something like this: 想象一下一个工具，它需要一组文件，将每个文件的内容包装在立即调用的函数表达式中，跟踪每个函数的返回值，并将所有内容连接到一个大文件中。结果可能看起来像这样： const modules = {}; function require(moduleName) { return modules[moduleName]; } modules[\"sets.js\"] = (function() { const exports = {}; // The contents of the sets.js file go here: exports.BitSet = class BitSet { ... }; return exports; }()); modules[\"stats.js\"] = (function() { const exports = {}; // The contents of the stats.js file go here: const sum = (x, y) =\u003e x + y; const square = x = \u003e x * x; exports.mean = function(data) { ... }; exports.stddev = function(data) { ... }; return exports; }()); With modules bundled up into a single file like the one shown in the preceding example, you can imagine writing code like the following to make use of those modules: 如上一个示例所示，将模块捆绑到单个文件中，可以想象编写如下代码来利用这些模块： // Get references to the modules (or the module content) that we need const stats = require(\"stats.js\"); const BitSet = require(\"sets.js\").BitSet; // Now write code using those modules let s = new BitSet(100); s.insert(10); s.insert(20); s.insert(30); let average = stats.mean([...s]); // average is 20 This code is a rough sketch of how code-bundling tools (such as webpack and Parcel) for web browsers work, and it’s also a simple introduction to the require() function like the one used in Node programs. 这段代码概述了用于网络浏览器的代码捆绑工具（例如 webpack 和 Parcel）的工作方式，并且是对 require() 函数（如 Node 程序中使用的函数）的简单介绍。 ","date":"2020-11-02","objectID":"/posts/ch10/:1:1","tags":null,"title":"第 10 章 模块","uri":"/posts/ch10/"},{"categories":null,"content":"10.2 Modules in Node In Node programming, it is normal to split programs into as many files as seems natural. These files of JavaScript code are assumed to all live on a fast filesystem. Unlike web browsers, which have to read files of JavaScript over a relatively slow network connection, there is no need or benefit to bundling a Node program into a single JavaScript file. In Node, each file is an independent module with a private namespace. Constants, variables, functions, and classes defined in one file are private to that file unless the file exports them. And values exported by one module are only visible in another module if that module explicitly imports them. Node modules import other modules with the require() function and export their public API by setting properties of the Exports object or by replacing the module.exportsobject entirely. ","date":"2020-11-02","objectID":"/posts/ch10/:2:0","tags":null,"title":"第 10 章 模块","uri":"/posts/ch10/"},{"categories":null,"content":"10.2.1 Node Exports Node defines a global exports object that is always defined. If you are writing a Node module that exports multiple values, you can simply assign them to the properties of this object: const sum = (x, y) =\u003e x + y; const square = x =\u003e x * x; exports.mean = data =\u003e data.reduce(sum)/data.length; exports.stddev = function(d) { let m = exports.mean(d); return Math.sqrt(d.map(x =\u003e x - m).map(square).reduce(sum)/(d.length-1)); }; Often, however, you want to define a module that exports only a single function or class rather than an object full of functions or classes. To do this, you simply assign the single value you want to export to module.exports: module.exports = class BitSet extends AbstractWritableSet { // implementation omitted }; The default value of module.exports is the same object that exports refers to. In the previous stats module, we could have assigned the mean function to module.exports.mean instead of exports.mean. Another approach with modules like the stats module is to export a single object at the end of the module rather than exporting functions one by one as you go: // Define all the functions, public and private const sum = (x, y) =\u003e x + y; const square = x =\u003e x * x; const mean = data =\u003e data.reduce(sum)/data.length; const stddev = d =\u003e { let m = mean(d); return Math.sqrt(d.map(x =\u003e x - m).map(square).reduce(sum)/(d.length-1)); }; // Now export only the public ones module.exports = { mean, stddev }; ","date":"2020-11-02","objectID":"/posts/ch10/:2:1","tags":null,"title":"第 10 章 模块","uri":"/posts/ch10/"},{"categories":null,"content":"10.2.2 Node Imports A Node module imports another module by calling the require() function. The argument to this function is the name of the module to be imported, and the return value is whatever value (typically a function, class, or object) that module exports. If you want to import a system module built in to Node or a module that you have installed on your system via a package manager, then you simply use the unqualified name of the module, without any “/” characters that would turn it into a filesystem path: // These modules are built in to Node const fs = require(\"fs\"); // The built-in filesystem module const http = require(\"http\"); // The built-in HTTP module // The Express HTTP server framework is a third-party module. // It is not part of Node but has been installed locally const express = require(\"express\"); When you want to import a module of your own code, the module name should be the path to the file that contains that code, relative to the current module’s file. It is legal to use absolute paths that begin with a / character, but typically, when importing modules that are part of your own program, the module names will begin with ./ or sometimes ../ to indicate that they are relative to the current directory or the parent directory. For example: const stats = require('./stats.js'); const BitSet = require('./utils/bitset.js'); (You can also omit the .js suffix on the files you’re importing and Node will still find the files, but it is common to see these file extensions explicitly included.) When a module exports just a single function or class, all you have to do is require it. When a module exports an object with multiple properties, you have a choice: you can import the entire object, or just import the specific properties (using destructuring assignment) of the object that you plan to use. Compare these two approaches: // Import the entire stats object, with all of its functions const stats = require('./stats.js'); // We've got more functions than we need, but they're neatly // organized into a convenient \"stats\" namespace. let average = stats.mean(data); // Alternatively, we can use idiomatic destructuring assignment to import // exactly the functions we want directly into the local namespace: const { stddev } = require('./stats.js'); // This is nice and succinct, though we lose a bit of context // without the 'stats' prefix as a namspace for the stddev() function. let sd = stddev(data); ","date":"2020-11-02","objectID":"/posts/ch10/:2:2","tags":null,"title":"第 10 章 模块","uri":"/posts/ch10/"},{"categories":null,"content":"10.2.3 Node-Style Modules on the Web Modules with an Exports object and a require() function are built in to Node. But if you’re willing to process your code with a bundling tool like webpack, then it is also possible to use this style of modules for code that is intended to run in web browsers. Until recently, this was a very common thing to do, and you may see lots of web-based code that still does it. Node 中内置了带有 Exports 对象和 require() 函数的模块。 但是，如果要使用诸如 webpack 之类的捆绑工具来处理代码，则也可以将这种样式的模块用于要在网络浏览器中运行的代码。直到最近，这还是一种非常常用的做法，可能会看到很多基于 Web 的代码仍然这样做。 Now that JavaScript has its own standard module syntax, however, developers who use bundlers are more likely to use the official JavaScript modules with import and export statements. 现在，JavaScript 具有自己的标准模块语法，但是使用捆绑程序的开发人员更喜欢将正式的 JavaScript 模块与 import 和 export 语句一起使用。 ","date":"2020-11-02","objectID":"/posts/ch10/:2:3","tags":null,"title":"第 10 章 模块","uri":"/posts/ch10/"},{"categories":null,"content":"10.3 Modules in ES6 ES6 adds import and export keywords to JavaScript and finally supports real modularity as a core language feature. ES6 modularity is conceptually the same as Node modularity: each file is its own module, and constants, variables, functions, and classes defined within a file are private to that module unless they are explicitly exported. Values that are exported from one module are available for use in modules that explicitly import them. ES6 modules differ from Node modules in the syntax used for exporting and importing and also in the way that modules are defined in web browsers. The sections that follow explain these things in detail. ES6 给 JavaScript 添加了 import 和 export 关键字，并且最终支持真正的模块化，将其作为核心语言特性。ES6 模块化概念上和 Node 的模块化相同：每个文件是它们自己的模块，定义在文件中的常量、变量、函数和类是模块私有成员，除非它们是被显示导出。 First, though, note that ES6 modules are also different from regular JavaScript “scripts” in some important ways. The most obvious difference is the modularity itself: in regular scripts, top-level declarations of variables, functions, and classes go into a single global context shared by all scripts. With modules, each file has its own private context and can use the import and export statements, which is the whole point, after all. But there are other differences between modules and scripts as well. Code inside an ES6 module (like code inside any ES6 class definition) is automatically in strict mode (see §5.6.3). This means that, when you start using ES6 modules, you’ll never have to write “use strict” again. And it means that code in modules cannot use the with statement or the arguments object or undeclared variables. ES6 modules are even slightly stricter than strict mode: in strict mode, in functions invoked as functions, this is undefined. In modules, this is undefined even in top-level code. (By contrast, scripts in web browsers and Node set this to the global object.) 首先，请注意，ES6 模块在某些重要方面也与常规 JavaScript “脚本”不同。最明显的区别是模块化本身：在常规脚本中，变量，函数和类的顶级声明在所有脚本共享的一个全局上下文中。模块每个文件都有其自己的专用上下文，并且可以使用 import 和 export 语句。但是模块和脚本之间也存在其他差异。ES6 模块内的代码（类似 ES6 类内定义的代码）将自动进入严格模式（请参见 §5.6.3）。这意味着，当使用 ES6 模块时，无需再写“use strict”。这意味着模块中的代码不能使用 with 语句或 arguments 对象或未声明的变量。ES6 模块甚至比严格模式稍微严格：在严格模式下，在作为函数调用的函数中，this 是 undefined。在模块中，this 在顶层代码中也是 undefined。（相比之下，Web 浏览器和 Node 中的脚本将 this 设置为全局对象。） ES6 MODULES ON THE WEB AND IN NODE ES6 modules have been in use on the web for years with the help of code bundlers like webpack, which combine independent modules of JavaScript code into large, non-modular bundles suitable for inclusion into web pages. At the time of this writing, however, ES6 modules are finally supported natively by all web browsers other than Internet Explorer. When used natively, ES6 modules are added into HTML pages with a special \u003cscript type=\"module\"\u003e tag, described later in this chapter. ES6模块在诸如 webpack 之类的代码打包器的帮助下已在 Web 上使用多年，该打包器将 JavaScript 代码的独立模块组合成适合于包含在网页中的大型非模块化捆绑包。但是，在撰写本文时，除 Internet Explorer 之外，所有 Web 浏览器都支持 ES6 模块。本地使用时，ES6 模块通过特殊的 \u003cscript type=\"module\"\u003e 标签添加到HTML页面中，本章稍后将进行介绍。 And meanwhile, having pioneered JavaScript modularity, Node finds itself in the awkward position of having to support two not entirely compatible module systems. Node 13 supports ES6 modules, but for now, the vast majority of Node programs still use Node modules. 同时，由于拥有 JavaScript 模块化的先驱，Node 处于必须支持两个不完全兼容的模块系统的尴尬境地。Node 13 支持 ES6 模块，但是到目前为止，绝大多数 Node 程序仍在使用 Node 模块。 ","date":"2020-11-02","objectID":"/posts/ch10/:3:0","tags":null,"title":"第 10 章 模块","uri":"/posts/ch10/"},{"categories":null,"content":"10.3.1 ES6 Exports To export a constant, variable, function, or class from an ES6 module, simply add the keyword export before the declaration: 要从 ES6 模块导出常量，变量，函数或类，只需在声明之前添加关键字 export： export const PI = Math.PI; export function degreesToRadians(d) { return d * PI / 180; } export class Circle { constructor(r) { this.r = r; } area() { return PI * this.r * this.r; } } As an alternative to scattering export keywords throughout your module, you can define your constants, variables, functions, and classes as you normally would, with no export statement, and then (typically at the end of your module) write a single export statement that declares exactly what is exported in a single place. So instead of writing three individual exports in the preceding code, we could have equivalently written a single line at the end: 作为在整个模块中散播 export 关键字的替代方法，可以像平常一样定义常量、变量、函数和类，无需导出语句，然后（通常在模块末尾）编写一个导出语句，在一个位置精确的声明要导出的所有内容。因此，我们可以在末尾写入一行代码，而不是在上述代码中编写三个单独的导出： export { Circle, degreesToRadians, PI }; This syntax looks like the export keyword followed by an object literal (using shorthand notation). But in this case, the curly braces do not actually define an object literal. This export syntax simply requires a comma-separated list of identifiers within curly braces. 这种语法看起来像导出关键字，后跟对象字面量（使用速记符号）。但在这种情况下，花括号实际上并不是定义对象字面量。此导出语法只需要在大括号中的标识符列表用逗号分隔。 It is common to write modules that export only one value (typically a function or class), and in this case, we usually use export default instead of export: 编写只导出一个值（通常是一个函数或类）的模块是很常见的，在这种情况下，我们通常使用 export default 而不是 export： export default class BitSet { // implementation omitted } Default exports are slightly easier to import than non-default exports, so when there is only one exported value, using export default makes things easier for the modules that use your exported value. 默认导出比非默认导出更容易导入，因此，当只有一个导出值时，使用默认导出可以使模块的使用更容易。 Regular exports with export can only be done on declarations that have a name. Default exports with export default can export any expression including anonymous function expressions and anonymous class expressions. This means that if you use export default, you can export object literals. So unlike the export syntax, if you see curly braces after export default, it really is an object literal that is being exported. 带 export 的常规导出只能在具有名称的声明上进行。export default 默认导出可以导出任何表达式，包括匿名函数表达式和匿名类表达式。这意味着，如果使用默认导出，则可以导出对象字面量。因此，与导出语法不同，如果在默认导出后看到花括号，则它实际上是要导出的对象字面量。 It is legal, but somewhat uncommon, for modules to have a set of regular exports and also a default export. If a module has a default export, it can only have one. 同时有 export 和 export default 的模块是合法的，但是不常用。如果模块的默认导出最多仅有一个。 Finally, note that the export keyword can only appear at the top level of your JavaScript code. You may not export a value from within a class, function, loop, or conditional. (This is an important feature of the ES6 module system and enables static analysis: a modules export will be the same on every run, and the symbols exported can be determined before the module is actually run.) 最后，请注意 export 关键字只能出现在 JavaScript 代码的顶层。 不能从类，函数，循环或条件内导出值。（这是 ES6 模块系统的重要特性，并且可以进行静态分析：每次运行时模块导出都是相同的，并且可以在模块实际运行之前确定导出的符号。） ","date":"2020-11-02","objectID":"/posts/ch10/:3:1","tags":null,"title":"第 10 章 模块","uri":"/posts/ch10/"},{"categories":null,"content":"10.3.2 ES6 Imports You import values that have been exported by other modules with the import keyword. The simplest form of import is used for modules that define a default export: 使用 import 关键字导入其他模块导出的值。最简单的导入形式是导入默认导出定义的模块： import BitSet from './bitset.js'; This is the import keyword, followed by an identifier, followed by the from keyword, followed by a string literal that names the module whose default export we are importing. The default export value of the specified module becomes the value of the specified identifier in the current module. import 关键字后面跟一个标识符，然后是 from 关键字，后接要导入的默认导出字符串字面量模块名称。模块指定的默认导出值将编程当前模块内指定的标识符的值。 The identifier to which the imported value is assigned is a constant, as if it had been declared with the const keyword. Like exports, imports can only appear at the top level of a module and are not allowed within classes, functions, loops, or conditionals. By near-universal convention, the imports needed by a module are placed at the start of the module. Interestingly, however, this is not required: like function declarations, imports are “hoisted” to the top, and all imported values are available for any of the module’s code runs. 赋导入值的标识符是一个常量，就像它使用了 const 关键字声明一样。和导出一样，只能在模块的顶层导入，不能在类、函数、循环或条件中导入。根据近似通用规约，需要在模块的开头进行模块导入。但有趣的是，这不是必须的：就像函数声明，导入“提前”到顶部，所有的导入值在整个模块代码中运行时可以使用。 The module from which a value is imported is specified as a constant string literal in single quotes or double quotes. (You may not use a variable or other expression whose value is a string, and you may not use a string within backticks because template literals can interpolate variables and do not always have constant values.) In web browsers, this string is interpreted as a URL relative to the location of the module that is doing the importing. (In Node, or when using a bundling tool, the string is interpreted as a filename relative to the current module, but this makes little difference in practice.) A module specifier string must be an absolute path starting with “/”, or a relative path starting with “./” or “../”, or a complete URL a with protocol and hostname. The ES6 specification does not allow unqualified module specifier strings like “util.js” because it is ambiguous whether this is intended to name a module in the same directory as the current one or some kind of system module that is installed in some special location. (This restriction against “bare module specifiers” is not honored by code-bundling tools like webpack, which can easily be configured to find bare modules in a library directory that you specify.) A future version of the language may allow “bare module specifiers,” but for now, they are not allowed. If you want to import a module from the same directory as the current one, simply place “./” before the module name and import from “./util.js” instead of “util.js”. 被导入的模块用单引号或双引号括上的字符串字面量常量指定。（不可以使用变量或其他值为字符串的表达式，也不可以使用带反引号的字符串，因为模板字面量可以插入变量，它不总是一个常量值。）在 Web 浏览器中，字符串像 URL 一样描述导入模块的相对位置。（在 Node中，或者使用代码捆绑工具时，字符串描述一个对于当前模块的相对文件名，这在事件中略有不同。）以“/”开始的模块指定字符串时绝对路径，“./”和“../”开头的是相对路径，或者是带有协议和主机名的完整 URL。ES6 明确规定不允许使用诸如“util.js”这样的不合规范的字符串，因为它是否是相对路径还是绝对路径上有歧义。（诸如 webpack 之类的代码捆绑工具不能满足对“裸模块说明符”的这种限制，可以将其轻松配置为在指定的库中查找裸模块。）未来版本 JavaScript 可能允许使用“裸模块说明符”，但目前不允许这样做。 如果要从与当前目录相同的目录中导入模块，只需在模块名称前放置“./”，然后从“./util.js”而不是“ util.js”导入。 So far, we’ve only considered the case of importing a single value from a module that uses export default. To import values from a module that exports multiple values, we use a slightly different syntax: 到目前为止，我们仅考虑了从使用默认导出的模块中导入单个值的情况。要从导出多个值的模块导入值，我们使用略有不同的语法： import { mean, stddev } from \"./stats.js\"; Recall that default exports do not need to have a name in the module that defines them. Instead, we provide a local name when we import those values. But non-default exports of a module do have names in the exporting module, and when we import those values, we refer to them by those names. The exporting module can export any number of named value. An import statement that references that module ","date":"2020-11-02","objectID":"/posts/ch10/:3:2","tags":null,"title":"第 10 章 模块","uri":"/posts/ch10/"},{"categories":null,"content":"10.3.3 Imports and Exports with Renaming If two modules export two different values using the same name and you want to import both of those values, you will have to rename one or both of the values when you import it. Similarly, if you want to import a value whose name is already in use in your module, you will need to rename the imported value. You can use the as keyword with named imports to rename them as you import them: 如果两个模块使用相同的名称导出两个不同的值，并且要导入这两个值，则在导入时必须重命名一个或两个值。同样，如果模块要导入值的名称已在模块中使用，则需要重命名导入的值。可以在命名导入中使用 as 关键字，以在导入它们时重命名它们： import { render as renderImage } from \"./imageutils.js\"; import { render as renderUI } from \"./ui.js\"; These lines import two functions into the current module. The functions are both named render() in the modules that define them but are imported with the more descriptive and disambiguating names renderImage() and renderUI(). 这些行将两个功能导入当前模块。这些函数在定义它们的模块中都被命名为 render()，但使用更具描述性和消除歧义性的 renderImage() 和 renderUI() 名称导入。 Recall that default exports do not have a name. The importing module always chooses the name when importing a default export. So there is no need for a special syntax for renaming in that case. 回想一下，默认导出没有名称。导入默认导出时，导入模块始终选择名称。因此，在这种情况下，不需要特殊的语法来重命名。 Having said that, however, the possibility of renaming on import provides another way of importing from modules that define both a default export and named exports. Recall the “./histogram-stats.js” module from the previous section. Here is another way to import both the default and named exports of that module: 话虽如此，导入重命名的可能性提供另外一种导入，从模块导入同时定义默认导出和命名导出。回顾上一节中的“ ./histogram-stats.js”模块。这是同时导入该模块的默认导出和命名导出的另一种方法： import { default as Histogram, mean, stddev } from \"./histogram-stats.js\"; In this case, the JavaScript keyword default serves as a placeholder and allows us to indicate that we want to import and provide a name for the default export of the module. 在这种情况下，JavaScript 关键字 default 用作占位符，并允许我们指示我们要导入并为模块的默认导出提供名称。 It is also possible to rename values as you export them, but only when using the curly brace variant of the export statement. It is not common to need to do this, but if you chose short, succinct names for use inside your module, you might prefer to export your values with more descriptive names that are less likely to conflict with other modules. As with imports, you use the as keyword to do this: 也可以在导出时重命名值，但仅在使用 export 语句的花括号时才可以。这样做通常并不常见，但是如果选择在模块内部使用简短的简短名称，则可能更喜欢使用描述性较强的名称导出值，这些名称不太可能与其他模块发生冲突。与导入一样，可以使用 as 关键字执行此操作： export { layout as calculateLayout, render as renderLayout }; Keep in mind that, although the curly braces look something like object literals, they are not, and the export keyword expects a single identifier before the as, not an expression. This means, unfortunately, that you cannot use export renaming like this: 请记住，尽管花括号看起来像对象字面量，但实际上并非如此，并且 export 关键字期望在 as 之前有一个标识符，而不是表达式。不幸的是，这意味着不能像这样使用导出重命名： export { Math.sin as sin, Math.cos as cos }; // SyntaxError ","date":"2020-11-02","objectID":"/posts/ch10/:3:3","tags":null,"title":"第 10 章 模块","uri":"/posts/ch10/"},{"categories":null,"content":"10.3.4 Re-Exports Throughout this chapter, we’ve discussed a hypothetical “./stats.js” module that exports mean() and stddev() functions. If we were writing such a module and we thought that many users of the module would want only one function or the other, then we might want to define mean() in a “./stats/mean.js” module and define stddev() in “./stats/stddev.js”. That way, programs only need to import exactly the functions they need and are not bloated by importing code they do not need. 在本章中，我们讨论了一个假定的“./stats.js”模块，该模块导出了 mean() 和 stddev() 函数。如果我们正在编写这样一个模块，并且该模块的用户只想要一个函数或另一个函数，那么我们可能想在“./stats/mean.js”模块中定义 mean()，并定义在“./stats/stddev.js”模块中的 stddev()。这样，程序仅需要完全导入所需的功能，而不会因导入不需要的代码而肿。 Even if we had defined these statistical functions in individual modules, however, we might expect that there would be plenty of programs that want both functions and would appreciate a convenient “./stats.js” module from which they could import both on one line. 但是，即使我们在单个模块中定义了这些统计函数，我们也可能有很多程序需要这两个功能，并且希望使用一行代码方便的导入“./stats.js”模块。 Given that the implementations are now in separate files, defining this “./stat.js” module is simple: 鉴于实现现在位于单独的文件中，因此定义这样的“./stat.js”模块会非常简单： import { mean } from \"./stats/mean.js\"; import { stddev } from \"./stats/stddev.js\"; export { mean, stdev }; ES6 modules anticipate this use case and provide a special syntax for it. Instead of importing a symbol simply to export it again, you can combine the import and the export steps into a single “re-export” statement that uses the export keyword and the from keyword: ES6 模块预见了这种使用场景，并为此提供了一种特殊的语法。可以使用 export 和 from 关键字合并导入和导出到一个单独的“再导出”语句中，而不是简单地再次导入即可导入符号： export { mean } from \"./stats/mean.js\"; export { stddev } from \"./stats/stddev.js\"; Note that the names mean and stddev are not actually used in this code. If we are not being selective with a re-export and simply want to export all of the named values from another module, we can use a wildcard: 请注意，此代码中并未实际使用名称 mean 和 stddev。如果我们不选择再导出，而只是想从另一个模块中导出所有命名值，则可以使用通配符： export * from \"./stats/mean.js\"; export * from \"./stats/stddev.js\"; Re-export syntax allows renaming with as just as regular import and export statements do. Suppose we wanted to re-export the mean() function but also define average() as another name for the function. We could do that like this: 再导出语法允许重命名，就像常规的导入和导出语句一样。 假设我们要再导出 mean() 函数，但还要将该函数定义为 average()。 我们可以这样做： export { mean, mean as average } from \"./stats/mean.js\"; export { stddev } from \"./stats/stddev.js\"; All of the re-exports in this example assume that the “./stats/mean.js” and “./stats/stddev.js” modules export their functions using export instead of export default. In fact, however, since these are modules with only a single export, it would have made sense to define them with export default. If we had done so, then the re-export syntax is a little more complicated because it needs to define a name for the unnamed default exports. We can do that like this: 所有的再导出示例中，“./stats/mean.js”和“./stats/stddev.js”模块都使用导出而不是默认导出来导出它们的函数。但是，实际上，由于这些模块仅具有单个导出，因此使用导出默认定义它们是更明智的。如果我们这样做，那么再导出语法会稍微复杂一点，因为它需要为未命名的默认导出定义一个名称。 我们可以这样做： export { default as mean } from \"./stats/mean.js\"; export { default as stddev } from \"./stats/stddev.js\"; If you want to re-export a named symbol from another module as the default export of your module, you could do an import followed by an export default, or you could combine the two statements like this: 如果要从另一个模块中再导出命名符号作为模块的默认导出，则可以先进行导入，然后再默认导出，或者可以将以下两个语句组合在一起： // Import the mean() function from ./stats.js and make it the // default export of this module export { mean as default } from \"./stats.js\" And finally, to re-export the default export of another module as the default export of your module (though it is unclear why you would want to do this, since users could simply import the other module directly), you can write: 最后，要将另一个模块的默认导出再导出为模块的默认导出（尽管不清楚为什么要这样做，因为用户可以直接导入另一个模块），可以这样编写： // The average.js module simply re-exports the stats/mean.js default export expo","date":"2020-11-02","objectID":"/posts/ch10/:3:4","tags":null,"title":"第 10 章 模块","uri":"/posts/ch10/"},{"categories":null,"content":"10.3.5 JavaScript Modules on the Web The preceding sections have described ES6 modules and their import and export declarations in a somewhat abstract manner. In this section and the next, we’ll be discussing how they actually work in web browsers, and if you are not already an experienced web developer, you may find the rest of this chapter easier to understand after you have read Chapter 15. 前面的章节以某种抽象的方式描述了 ES6 模块及其导入和导出声明。在本节和下一部分中，我们将讨论它们在 Web 浏览器中的实际工作方式，如果您还不是经验丰富的 Web 开发人员，则在阅读第 15 章之后，可能会发现本章的其余部分更容易理解。 As of early 2020, production code using ES6 modules is still generally bundled with a tool like webpack. There are trade-offs to doing this, [^1] but on the whole, code bundling tends to give better performance. That may well change in the future as network speeds grow and browser vendors continue to optimize their ES6 module implementations. 截至 2020 年初，使用 ES6 模块的生产代码通常仍与 webpack 之类的工具捆绑在一起。 这样做是有折衷的 [^1]，但是总的来说，代码捆绑往往会提供更好的性能。随着网络速度的增长以及浏览器供应商继续优化其 ES6 模块的实现，将来这种情况可能会发生很大的变化。 Even though bundling tools may still be desirable in production, they are no longer required in development since all current browsers provide native support for JavaScript modules. Recall that modules use strict mode by default, this does not refer to a global object, and top-level declarations are not shared globally by default. Since modules must be executed differently than legacy non-module code, their introduction requires changes to HTML as well as JavaScript. If you want to natively use import directives in a web browser, you must tell the web browser that your code is a module by using a \u003cscript type=\"module\"\u003e tag. 即使在生产中仍可能需要捆绑工具，但由于当前所有的浏览器都为 JavaScript 模块提供了本机支持，因此在开发中不再需要捆绑工具。回想一下，默认情况下模块使用严格模式，this 不引用全局对象，并且顶级声明默认不全局共享。由于模块的执行方式必须不同于传统的非模块代码，因此其引入 requires 对 HTML 和 JavaScript 进行更改。如果要在 Web 浏览器本地使用 import 指令，则必须通过使用 \u003cscript type =“ module”\u003e 标记来告知 Web 浏览器您的代码是模块。 One of the nice features of ES6 modules is that each module has a static set of imports. So given a single starting module, a web browser can load all of its imported modules and then load all of the modules imported by that first batch of modules, and so on, until a complete program has been loaded. We’ve seen that the module specifier in an import statement can be treated as a relative URL. A \u003cscript type=\"module\"\u003e tag marks the starting point of a modular program. None of the modules it imports are expected to be in \u003cscript\u003e tags, however: instead, they are loaded on demand as regular JavaScript files and are executed in strict mode as regular ES6 modules. Using a \u003cscript type=\"module\"\u003e tag to define the main entry point for a modular JavaScript program can be as simple as this: \u003cscript type=\"module\"\u003eimport \"./main.js\";\u003c/script\u003e Code inside an inline \u003cscript type=\"module\"\u003e tag is an ES6 module, and as such can use the export statement. There is not any point in doing so, however, because the HTML \u003cscript\u003e tag syntax does not provide any way to define a name for inline modules, so even if such a module does export a value, there is no way for another module to import it. Scripts with the type=“module” attribute are loaded and executed like scripts with the defer attribute. Loading of the code begins as soon as the HTML parser encounters the \u003cscript\u003e tag (in the case of modules, this code-loading step may be a recursive process that loads multiple JavaScript files). But code execution does not begin until HTML parsing is complete. And once HTML parsing is complete, scripts (both modular and non) are executed in the order in which they appear in the HTML document. You can modify the execution time of modules with the async attribute, which works the same way for modules that it does for regular scripts. An async module will execute as soon as the code is loaded, even if HTML parsing is not complete and even if this changes the relative ordering of the scripts. Web browsers that support \u003cscript type=\"module\"\u003e must also support \u003cscript nomodule\u003e. Browsers that are module-aware","date":"2020-11-02","objectID":"/posts/ch10/:3:5","tags":null,"title":"第 10 章 模块","uri":"/posts/ch10/"},{"categories":null,"content":"10.3.6 Dynamic Imports with import() We’ve seen that the ES6 import and export directives are completely static and enable JavaScript interpreters and other JavaScript tools to determine the relationships between modules with simple text analysis while the modules are being loaded without having to actually execute any of the code in the modules. With statically imported modules, you are guaranteed that the values you import into a module will be ready for use before any of the code in your module begins to run. On the web, code has to be transferred over a network instead of being read from the filesystem. And once transfered, that code is often executed on mobile devices with relatively slow CPUs. This is not the kind of environment where static module imports—which require an entire program to be loaded before any of it runs—make a lot of sense. It is common for web applications to initially load only enough of their code to render the first page displayed to the user. Then, once the user has some preliminary content to interact with, they can begin to load the often much larger amount of code needed for the rest of the web app. Web browsers make it easy to dynamically load code by using the DOM API to inject a new \u003cscript\u003e tag into the current HTML document, and web apps have been doing this for many years. Although dynamic loading has been possible for a long time, it has not been part of the language itself. That changes with the introduction of import() in ES2020 (as of early 2020, dynamic import is supported by all browsers that support ES6 modules). You pass a module specifier to import() and it returns a Promise object that represents the asynchronous process of loading and running the specified module. When the dynamic import is complete, the Promise is “fulfilled” (see Chapter 13 for complete details on asynchronous programming and Promises) and produces an object like the one you would get with the import * as form of the static import statement. So instead of importing the “./stats.js” module statically, like this: import * as stats from \"./stats.js\"; we might import it and use it dynamically, like this: import(\"./stats.js\").then(stats =\u003e { let average = stats.mean(data); }) Or, in an async function (again, you may need to read Chapter 13 before you’ll understand this code), we can simplify the code with await: async analyzeData(data) { let stats = await import(\"./stats.js\"); return { average: stats.mean(data), stddev: stats.stddev(data) }; } The argument to import() should be a module specifier, exactly like one you’d use with a static import directive. But with import(), you are not constrained to use a constant string literal: any expression that evaluates to a string in the proper form will do. Dynamic import() looks like a function invocation, but it actually is not. Instead, import() is an operator and the parentheses are a required part of the operator syntax. The reason for this unusual bit of syntax is that import() needs to be able to resolve module specifiers as URLs relative to the currently running module, and this requires a bit of implementation magic that would not be legal to put in a JavaScript function. The function versus operator distinction rarely makes a difference in practice, but you’ll notice it if you try writing code like console.log(import); or let require = import;. Finally, note that dynamic import() is not just for web browsers. Code-packaging tools like webpack can also make good use of it. The most straightforward way to use a code bundler is to tell it the main entry point for your program and let it find all the static import directives and assemble everything into one large file. By strategically using dynamic import() calls, however, you can break that one monolithic bundle up into a set of smaller bundles that can be loaded on demand. ","date":"2020-11-02","objectID":"/posts/ch10/:3:6","tags":null,"title":"第 10 章 模块","uri":"/posts/ch10/"},{"categories":null,"content":"10.3.7 import.meta.url There is one final feature of the ES6 module system to discuss. Within an ES6 module (but not within a regular \u003cscript\u003e or a Node module loaded with require()), the special syntax import.meta refers to an object that contains metadata about the currently executing module. The url property of this object is the URL from which the module was loaded. (In Node, this will be a file:// URL.) The primary use case of import.meta.url is to be able to refer to images, data files, or other resources that are stored in the same directory as (or relative to) the module. The URL() constructor makes it easy to resolve a relative URL against an absolute URL like import.meta.url. Suppose, for example, that you have written a module that includes strings that need to be localized and that the localization files are stored in an l10n/ directory, which is in the same directory as the module itself. Your module could load its strings using a URL created with a function, like this: function localStringsURL(locale) { return new URL(`l10n/${locale}.json`, import.meta.url); } ","date":"2020-11-02","objectID":"/posts/ch10/:3:7","tags":null,"title":"第 10 章 模块","uri":"/posts/ch10/"},{"categories":null,"content":"10.4 Summary The goal of modularity is to allow programmers to hide the implementation details of their code so that chunks of code from various sources can be assembled into large programs without worrying that one chunk will overwrite functions or variables of another. This chapter has explained three different JavaScript module systems: In the early days of JavaScript, modularity could only be achieved through the clever use of immediately invoked function expressions. Node added its own module system on top of the JavaScript language. Node modules are imported with require() and define their exports by setting properties of the Exports object, or by setting the module.exports property. In ES6, JavaScript finally got its own module system with import and export keywords, and ES2020 is adding support for dynamic imports with import(). For example: web apps that have frequent incremental updates and users who make frequent return visits may find that using small modules instead of large bundles can result in better average load times because of better utilization of the user’s browser cache. ","date":"2020-11-02","objectID":"/posts/ch10/:4:0","tags":null,"title":"第 10 章 模块","uri":"/posts/ch10/"},{"categories":null,"content":"Some datatypes, such as numbers and strings (Chapter 3), objects (Chapter 6), and arrays (Chapter 7) are so fundamental to JavaScript that we can consider them to be part of the language itself. This chapter covers other important but less fundamental APIs that can be thought of as defining the “standard library” for JavaScript: these are useful classes and functions that are built in to JavaScript and available to all JavaScript programs in both web browsers and in Node.1 一些数据类型，如数字和字符串（第 3 章）、对象（第 6 章）和数组（第 7 章）是 JavaScript 的基础，我们可以将它们视为语言本身的一部分。这一章涵盖了其他重要但不那么基础的 api，这些 api 可以被认为是定义 JavaScript 的“标准库”：这些是 JavaScript 内建的有用的类和函数，在 web 浏览器和 Node 中的所有 JavaScript 程序中都可以使用。 1 The sections of this chapter are independent of one another, and you can read them in any order. They cover: 本章的各个章节是相互独立的，你可以以任何顺序阅读它们。他们包括: The Set and Map classes for representing sets of values and mappings from one set of values to another set of values. Array-like objects known as TypedArrays that represent arrays of binary data, along with a related class for extracting values from non-array binary data. Regular expressions and the RegExp class, which define textual patterns and are useful for text processing. This section also covers regular expression syntax in detail. The Date class for representing and manipulating dates and times. The Error class and its various subclasses, instances of which are thrown when errors occur in JavaScript programs. The JSON object, whose methods support serialization and deserialization of JavaScript data structures composed of objects, arrays, strings, numbers, and booleans. The Intl object and the classes it defines that can help you localize your JavaScript programs. The Console object, whose methods output strings in ways that are particularly useful for debugging programs and logging the behavior of those programs. The URL class, which simplifies the task of parsing and manipulating URLs. This section also covers global functions for encoding and decoding URLs and their component parts. setTimeout() and related functions for specifying code to be executed after a specified interval of time has elapsed. Set 和 Map 类，用于表示一组值以及从一组值到另一组值的映射。 类数组对象，称为 TypedArrays，表示二进制数据的数组，以及从非数组二进制数据中提取值的相关类。 正则表达式和 RegExp 类，它们定义文本模式，对文本处理很有用。本节还详细介绍了正则表达式语法。 用于表示和操作日期和时间的 Date 类。 Error 类及其各种子类，在 JavaScript 程序中发生错误时抛出它们的实例。 JSON 对象，其方法支持由对象、数组、字符串、数字和布尔值组成的 JavaScript 数据结构的序列化和反序列化。 Intl 对象和它定义的类可以帮助你本地化你的 JavaScript 程序。 Console 对象，其方法输出字符串的方式对调试程序和记录这些程序的行为特别有用。 URL 类，它简化了解析和操纵 URL 的任务。本节还介绍了用于编码和解码 url 及其组件的全局函数。 setTimeout() 和相关函数，用于指定在指定的时间间隔后执行的代码。 Some of the sections in this chapter—notably, the sections on typed arrays and regular expressions—are quite long because there is significant background information you need to understand before you can use those types effectively. Many of the other sections, however, are short: they simply introduce a new API and show some examples of its use. 本章中的一些部分（特别是关于类型化数组和正则表达式的部分）相当长，因为在有效使用这些类型之前，需要了解它们重要的背景信息。但是，其他部分都很简短：它们只是介绍了一个新的 API 并展示了一些使用它的示例。 ","date":"2020-11-02","objectID":"/posts/ch11/:0:0","tags":null,"title":"第 11 章 JavaScript 标准库","uri":"/posts/ch11/"},{"categories":null,"content":"11.1 Sets and Maps JavaScript’s Object type is a versatile data structure that can be used to map strings (the object’s property names) to arbitrary values. And when the value being mapped to is something fixed like true, then the object is effectively a set of strings. JavaScript 的对象类型是一种通用的数据结构，可用于将字符串（对象的属性名称）映射到任意值。当被映射到的值是固定的，比如 true，那么对象实际上是一组字符串。 Objects are actually used as maps and sets fairly routinely in JavaScript programming, but this is limited by the restriction to strings and complicated by the fact that objects normally inherit properties with names like “toString”, which are not typically intended to be part of the map or set. 在 JavaScript 编程中，对象通常被用作映射和集合，但这受到字符串的限制，而且由于对象通常继承诸如“toString”之类的属性而变得复杂，这些属性通常不准备成为映射或集合的一部分。 For this reason, ES6 introduces true Set and Map classes, which we’ll cover in the sub-sections that follow. 因此，ES6引入了 true Set 和 Map 类，我们将在后面的子节中介绍它们。 ","date":"2020-11-02","objectID":"/posts/ch11/:1:0","tags":null,"title":"第 11 章 JavaScript 标准库","uri":"/posts/ch11/"},{"categories":null,"content":"11.1.1 The Set Class A set is a collection of values, like an array is. Unlike arrays, however, sets are not ordered or indexed, and they do not allow duplicates: a value is either a member of a set or it is not a member; it is not possible to ask how many times a value appears in a set. set 是值的集合，就像数组。但不同于数组，set 没有被排序或被索引，并且它们不允许重复：值要么是集合的成员要么不是集合的成员；不能知道一个值在集合中出现多少次。 Create a Set object with the Set() constructor: 使用 Set() 创建 Set 对象： let s = new Set(); // A new, empty set let t = new Set([1, s]); // A new set with two members The argument to the Set() constructor need not be an array: any iterable object (including other Set objects) is allowed: Set() 构造函数的实参不必是数组：允许任何可迭代的对象（包括其他 Set 对象）： let t = new Set(s); // A new set that copies the elements of s. let unique = new Set(\"Mississippi\"); // 4 elements: \"M\", \"i\", \"s\", and \"p\" The size property of a set is like the length property of an array: it tells you how many values the set contains: set 的 size 属性类似于数组的 length 属性：它告诉你该集合包含多少个值： unique.size // =\u003e 4 Sets don’t need to be initialized when you create them. You can add and remove elements at any time with add(), delete(), and clear(). Remember that sets cannot contain duplicates, so adding a value to a set when it already contains that value has no effect: 创建 set 时无需初始化。可以随时使用add()、delete() 和 clear() 添加和删除元素。请记住，集合不能包含重复项，因此添加已经包含在该 set 中的值是一个无效操作： let s = new Set(); // Start empty s.size // =\u003e 0 s.add(1); // Add a number s.size // =\u003e 1; now the set has one member s.add(1); // Add the same number again s.size // =\u003e 1; the size does not change s.add(true); // Add another value; note that it is fine to mix types s.size // =\u003e 2 s.add([1,2,3]); // Add an array value s.size // =\u003e 3; the array was added, not its elements s.delete(1) // =\u003e true: successfully deleted element 1 s.size // =\u003e 2: the size is back down to 2 s.delete(\"test\") // =\u003e false: \"test\" was not a member, deletion failed s.delete(true) // =\u003e true: delete succeeded s.delete([1,2,3]) // =\u003e false: the array in the set is different s.size // =\u003e 1: there is still that one array in the set s.clear(); // Remove everything from the set s.size // =\u003e 0 There are a few important points to note about this code: 关于此代码，有几点要注意： The add() method takes a single argument; if you pass an array, it adds the array itself to the set, not the individual array elements. add() always returns the set it is invoked on, however, so if you want to add multiple values to a set, you can used chained method calls like s.add(‘a’).add(‘b’).add(‘c’);. add() 方法有一个实参。如果传递数组，它将数组本身而不是单个数组元素添加到 set 中。 add() 始终返回调用它的 set，因此，如果要向 set 添加多个值，则可以使用方法链调用，如s.add(‘a’).add(‘b’).add(‘C’);。 The delete() method also only deletes a single set element at a time. Unlike add(), however, delete() returns a boolean value. If the value you specify was actually a member of the set, then delete() removes it and returns true. Otherwise, it does nothing and returns false. delete() 方法一次也只删除一个 set 元素。与 add() 不同，delete() 返回一个布尔值。如果指定的值是 set 的成员，则 delete() 会将其删除并返回 true。否则，它不执行任何操作并返回 false。 Finally, it is very important to understand that set membership is based on strict equality checks, like the === operator performs. A set can contain both the number 1 and the string “1”, because it considers them to be distinct values. When the values are objects (or arrays or functions), they are also compared as if with ===. This is why we were unable to delete the array element from the set in this code. We added an array to the set and then tried to remove that array by passing a different array (albeit with the same elements) to the delete() method. In order for this to work, we would have had to pass a reference to exactly the same array. 最后，set 成员关系是基于严格的相等性检查（如 === 运算符执行），这是非常重要的。一个 set 可以同时包含数字 1 和字符串 “1”，因为它认为它们是不同的值。当值是对象（或数组或函数）时，它们也将用 === 进行比较。这就是此代码集中为什么我们无法从删除数组元素的原因。我们向 set 中添加了一个数组，然后尝试通过将另一个数组（尽管具有相同的元素）传递给 delete() 方法来删除该数组。为了使它起作用，我们必须传递完全相同的数组引用。 NOTE Python programmers take note: this is a significant difference between ","date":"2020-11-02","objectID":"/posts/ch11/:1:1","tags":null,"title":"第 11 章 JavaScript 标准库","uri":"/posts/ch11/"},{"categories":null,"content":"11.1.2 The Map Class A Map object represents a set of values known as keys, where each key has another value associated with (or “mapped to”) it. In a sense, a map is like an array, but instead of using a set of sequential integers as the keys, maps allow us to use arbitrary values as “indexes.” Like arrays, maps are fast: looking up the value associated with a key will be fast (though not as fast as indexing an array) no matter how large the map is. Map 对象代表一组称为键的值，其中每个键具有与其关联（或“映射到”）的另一个值。从某种意义上讲，映射就像一个数组，但是映射不是使用一组连续的整数作为键，而是允许我们使用任意值作为“索引”。像数组一样，映射是快速的：无论映射有多大查找与键关联的值都很快（尽管不如索引数组快）。 Create a new map with the Map() constructor: 用 Map() 构造函数闯将一个 map： let m = new Map(); // Create a new, empty map let n = new Map([ // A new map initialized with string keys mapped to numbers [\"one\", 1], [\"two\", 2] ]); The optional argument to the Map() constructor should be an iterable object that yields two element [key, value] arrays. In practice, this means that if you want to initialize a map when you create it, you’ll typically write out the desired keys and associated values as an array of arrays. But you can also use the Map() constructor to copy other maps or to copy the property names and values from an existing object: Map() 构造函数的可选实参应该是一个可迭代的对象，该对象可产生两个元素 [key，value] 数组。 实际上，这意味着如果要在创建 map 时初始化，通常会将所需的键和映射的值写为数组的数组。 但是，也可以使用 Map() 构造函数复制其他 map，或者从现有对象复制属性名称和值： let copy = new Map(n); // A new map with the same keys and values as map n let o = { x: 1, y: 2}; // An object with two properties let p = new Map(Object.entries(o)); // Same as new map([[\"x\", 1], [\"y\", 2]]) Once you have created a Map object, you can query the value associated with a given key with get() and can add a new key/value pair with set(). Remember, though, that a map is a set of keys, each of which has an associated value. This is not quite the same as a set of key/value pairs. If you call set() with a key that already exists in the map, you will change the value associated with that key, not add a new key/value mapping. In addition to get() and set(), the Map class also defines methods that are like Set methods: use has() to check whether a map includes the specified key; use delete() to remove a key (and its associated value) from the map; use clear() to remove all key/value pairs from the map; and use the size property to find out how many keys a map contains. 创建 Map 对象后，可以用 get() 查询给定键的值，并可以用 set() 添加新的键值对。但是请记住，map 是一组键，每个键映射一个值。这与一组键值对不太相同。如果调用 set() 添加一个 map 中已存在的键的键值对，会改变这个键映射的值，而不是添加一个新的键值对映射。除了 get() 和 set()，Map 类也定义了类似于 Set 的方法：使用 has() 判断 map 是否包含指定键；使用 delete() 删除 map 中的一个键（和它映射的值）；使用 clear() 来移除 map 中所有的键值对；使用 size 属性知道 map 中包含多少个键。 let m = new Map(); // Start with an empty map m.size // =\u003e 0: empty maps have no keys m.set(\"one\", 1); // Map the key \"one\" to the value 1 m.set(\"two\", 2); // And the key \"two\" to the value 2. m.size // =\u003e 2: the map now has two keys m.get(\"two\") // =\u003e 2: return the value associated with key \"two\" m.get(\"three\") // =\u003e undefined: this key is not in the set m.set(\"one\", true); // Change the value associated with an existing key m.size // =\u003e 2: the size doesn't change m.has(\"one\") // =\u003e true: the map has a key \"one\" m.has(true) // =\u003e false: the map does not have a key true m.delete(\"one\") // =\u003e true: the key existed and deletion succeeded m.size // =\u003e 1 m.delete(\"three\") // =\u003e false: failed to delete a nonexistent key m.clear(); // Remove all keys and values from the map Like the add() method of Set, the set() method of Map can be chained, which allows maps to be initialized without using arrays of arrays: 像 Set 的 add() 方法一样，Map 的 set() 方法也可以链式使用，这允许在不使用数组的情况下初始化 map： let m = new Map().set(\"one\", 1).set(\"two\", 2).set(\"three\", 3); m.size // =\u003e 3 m.get(\"two\") // =\u003e 2 As with Set, any JavaScript value can be used as a key or a value in a Map. This includes null, undefined, and NaN, as well as reference types like objects and arrays. And as with the Set class, Map compares keys by identity, not by equality, so if you use an object ","date":"2020-11-02","objectID":"/posts/ch11/:1:2","tags":null,"title":"第 11 章 JavaScript 标准库","uri":"/posts/ch11/"},{"categories":null,"content":"11.1.3 WeakMap and WeakSet The WeakMap class is a variant (but not an actual subclass) of the Map class that does not prevent its key values from being garbage collected. Garbage collection is the process by which the JavaScript interpreter reclaims the memory of objects that are no longer “reachable” and cannot be used by the program. A regular map holds “strong” references to its key values, and they remain reachable through the map, even if all other references to them are gone. The WeakMap, by contrast, keeps “weak” references to its key values so that they are not reachable through the WeakMap, and their presence in the map does not prevent their memory from being reclaimed. WeakMap 类是 Map 类的变体（但不是真正的子类），它不会阻止其键值被垃圾回收。垃圾回收是 JavaScript 解释器回收不再“可访问”并且无法由程序使用的对象的内存的过程。常规 map 保留对其键值的“强”引用，即使对它们的所有其他引用都已消失，它们仍然可以通过映射访问。相比之下，WeakMap 保留对其键值的“弱”引用，以使它们无法通过 WeakMap 获得，并且它们在 map 中的存在也不会阻止对其内存的回收。 The WeakMap() constructor is just like the Map() constructor, but there are some significant differences between WeakMap and Map: WeakMap() 构造函数类似 Map() 构造函数，但是有一些重要的不同： WeakMap keys must be objects or arrays; primitive values are not subject to garbage collection and cannot be used as keys. WeakMap 键必须是对象或数组；原始值不受垃圾回收的限制，不能用作键。 WeakMap implements only the get(), set(), has(), and delete() methods. In particular, WeakMap is not iterable and does not define keys(), values(), or forEach(). If WeakMap was iterable, then its keys would be reachable and it wouldn’t be weak. WeakMap 仅实现 get()、set()、has() 和 delete() 方法。 特别是，WeakMap 是不可迭代的，并且未定义 keys()、values() 或 forEach()。如果 WeakMap 是可迭代的，则其键将是可访问的，这让它不会“弱”。 Similarly, WeakMap does not implement the size property because the size of a WeakMap could change at any time as objects are garbage collected. 同样，WeakMap 也不实现 size 属性，因为随着对象被垃圾回收，WeakMap 的大小可能随时更改。 The intended use of WeakMap is to allow you to associate values with objects without causing memory leaks. Suppose, for example, that you are writing a function that takes an object argument and needs to perform some time-consuming computation on that object. For efficiency, you’d like to cache the computed value for later reuse. If you use a Map object to implement the cache, you will prevent any of the objects from ever being reclaimed, but by using a WeakMap, you avoid this problem. (You can often achieve a similar result using a private Symbol property to cache the computed value directly on the object. See §6.10.3.) WeakMap 的预期用途是允许将值与对象相关联而不会引起内存泄漏。例如，假设正在编写一个带有对象实参的函数，并且需要对该对象执行一些耗时的计算。为了提高效率，希望将计算出的值进行缓存以备后用。如果使用 Map 对象实现缓存，则将防止回收任何对象，但是通过使用 WeakMap，可以避免此问题。（通常可以使用私有的 Symbol 属性将计算的值直接缓存在对象上，从而获得相似的结果。请参见 §6.10.3。） WeakSet implements a set of objects that does not prevent those objects from being garbage collected. The WeakSet() constructor works like the Set() constructor, but WeakSet objects differ from Set objects in the same ways that WeakMap objects differ from Map objects: WeakSet 实现了一组对象，这些对象不会阻止垃圾回收这些对象。 WeakSet() 构造函数的工作方式类似于 Set() 构造函数，但 WeakSet 对象与 Set 对象的区别与 WeakMap 对象与 Map 对象的区别相同： WeakSet does not allow primitive values as members. WeakSet 不允许原始值作为成员。 WeakSet implements only the add(), has(), and delete() methods and is not iterable. WeakSet 仅实现 add()、has() 和 delete() 方法，并且不可迭代。 WeakSet does not have a size property. WeakSet 没有 size 属性。 WeakSet is not frequently used: its use cases are like those for WeakMap. If you want to mark (or “brand”) an object as having some special property or type, for example, you could add it to a WeakSet. Then, elsewhere, when you want to check for that property or type, you can test for membership in that WeakSet. Doing this with a regular set would prevent all marked objects from being garbage collected, but this is not a concern when using WeakSet. WeakSet 并不经常使用：其用例类似于 WeakMap 的用例。例如，如果要标记（或“烙印”）对象具有某些特殊属性或类型，则可以将其添加到 WeakSet 中。然后，在其他位置，当要检查该属性或类型时，可以测试该 WeakSet 中的成员身份。使用常规 Set 执行此操作将防止所有标记的对象被垃圾回收，但这在使用 WeakSet 时不必担心。 ","date":"2020-11-02","objectID":"/posts/ch11/:1:3","tags":null,"title":"第 11 章 JavaScript 标准库","uri":"/posts/ch11/"},{"categories":null,"content":"11.2 Typed Arrays and Binary Data Regular JavaScript arrays can have elements of any type and can grow or shrink dynamically. JavaScript implementations perform lots of optimizations so that typical uses of JavaScript arrays are very fast. Nevertheless, they are still quite different from the array types of lower-level languages like C and Java. Typed arrays, which are new in ES6 [^3] are much closer to the low-level arrays of those languages. Typed arrays are not technically arrays (Array.isArray() returns false for them), but they implement all of the array methods described in §7.8 plus a few more of their own. They differ from regular arrays in some very important ways, however: 常规 JavaScript 数组可以具有任何类型的元素，并且可以动态增长或收缩。JavaScript 实现执行了大量优化，因此 JavaScript 数组的典型用法非常快。但是，它们仍然与诸如 C 和 Java 的低级语言的数组类型有很大不同。 ES6 [^3] 中新增的类型化数组更接近那些语言的低级数组。从类型上讲，类型化数组不是数组（Array.isArray() 为其返回false），但是它们实现了 §7.8 中描述的所有数组方法以及它们自己的其他一些方法。但是，它们在某些非常重要的方面与常规数组有所不同： The elements of a typed array are all numbers. Unlike regular JavaScript numbers, however, typed arrays allow you to specify the type (signed and unsigned integers and IEEE-754 floating point) and size (8 bits to 64 bits) of the numbers to be stored in the array. 类型化数组的元素都是数字。 但是，与常规 JavaScript 数字不同，类型化数组允许指定要存储在数组中的数字的类型（有符号和无符号整数以及 IEEE-754 浮点数）和大小（8 位至 64 位）。 You must specify the length of a typed array when you create it, and that length can never change. 创建类型化数组时，必须指定其长度，并且该长度永远不会改变。 The elements of a typed array are always initialized to 0 when the array is created. 创建数组时，类型化数组的元素始终会初始化为 0。 ","date":"2020-11-02","objectID":"/posts/ch11/:2:0","tags":null,"title":"第 11 章 JavaScript 标准库","uri":"/posts/ch11/"},{"categories":null,"content":"11.2.1 Typed Array Types JavaScript does not define a TypedArray class. Instead, there are 11 kinds of typed arrays, each with a different element type and constructor: JavaScript 没有定义 TypedArray 类。相反，有11种类型化数组，每种类型具有不同的元素类型和构造函数： Constructor Numeric type Int8Array() signed bytes Uint8Array() unsigned bytes Uint8ClampedArray() unsigned bytes without rollover Int16Array() signed 16-bit short integers Uint16Array() unsigned 16-bit short integers Int32Array() signed 32-bit integers Uint32Array() unsigned 32-bit integers BigInt64Array() signed 64-bit BigInt values (ES2020) BigUint64Array() unsigned 64-bit BigInt values (ES2020) Float32Array() 32-bit floating-point value Float64Array() 64-bit floating-point value: a regular JavaScript number The types whose names begin with Int hold signed integers, of 1, 2, or 4 bytes (8, 16, or 32 bits). The types whose names begin with Uint hold unsigned integers of those same lengths. The “BigInt” and “BigUint” types hold 64-bit integers, represented in JavaScript as BigInt values (see §3.2.5). The types that begin with Float hold floating-point numbers. The elements of a Float64Array are of the same type as regular JavaScript numbers. The elements of a Float32Array have lower precision and a smaller range but require only half the memory. (This type is called float in C and Java.) Uint8ClampedArray is a special-case variant on Uint8Array. Both of these types hold unsigned bytes and can represent numbers between 0 and 255. With Uint8Array, if you store a value larger than 255 or less than zero into an array element, it “wraps around,” and you get some other value. This is how computer memory works at a low level, so this is very fast. Uint8ClampedArray does some extra type checking so that, if you store a value greater than 255 or less than 0, it “clamps” to 255 or 0 and does not wrap around. (This clamping behavior is required by the HTML \u003ccanvas\u003e element’s low-level API for manipulating pixel colors.) Each of the typed array constructors has a BYTES_PER_ELEMENT property with the value 1, 2, 4, or 8, depending on the type. ","date":"2020-11-02","objectID":"/posts/ch11/:2:1","tags":null,"title":"第 11 章 JavaScript 标准库","uri":"/posts/ch11/"},{"categories":null,"content":"11.2.2 Creating Typed Arrays The simplest way to create a typed array is to call the appropriate constructor with one numeric argument that specifies the number of elements you want in the array: let bytes = new Uint8Array(1024); // 1024 bytes let matrix = new Float64Array(9); // A 3x3 matrix let point = new Int16Array(3); // A point in 3D space let rgba = new Uint8ClampedArray(4); // A 4-byte RGBA pixel value let sudoku = new Int8Array(81); // A 9x9 sudoku board When you create typed arrays in this way, the array elements are all guaranteed to be initialized to 0, 0n, or 0.0. But if you know the values you want in your typed array, you can also specify those values when you create the array. Each of the typed array constructors has static from() and of() factory methods that work like Array.from() and Array.of(): let white = Uint8ClampedArray.of(255, 255, 255, 0); // RGBA opaque white Recall that the Array.from() factory method expects an array-like or iterable object as its first argument. The same is true for the typed array variants, except that the iterable or array-like object must also have numeric elements. Strings are iterable, for example, but it would make no sense to pass them to the from() factory method of a typed array. If you are just using the one-argument version of from(), you can drop the .from and pass your iterable or array-like object directly to the constructor function, which behaves exactly the same. Note that both the constructor and the from() factory method allow you to copy existing typed arrays, while possibly changing the type: let ints = Uint32Array.from(white); // The same 4 numbers, but as ints When you create a new typed array from an existing array, iterable, or array-like object, the values may be truncated in order to fit the type constraints of your array. There are no warnings or errors when this happens: // Floats truncated to ints, longer ints truncated to 8 bits Uint8Array.of(1.23, 2.99, 45000) // =\u003e new Uint8Array([1, 2, 200]) Finally, there is one more way to create typed arrays that involves the ArrayBuffer type. An ArrayBuffer is an opaque reference to a chunk of memory. You can create one with the constructor; just pass in the number of bytes of memory you’d like to allocate: let buffer = new ArrayBuffer(1024*1024); buffer.byteLength // =\u003e 1024*1024; one megabyte of memory The ArrayBuffer class does not allow you to read or write any of the bytes that you have allocated. But you can create typed arrays that use the buffer’s memory and that do allow you to read and write that memory. To do this, call the typed array constructor with an ArrayBuffer as the first argument, a byte offset within the array buffer as the second argument, and the array length (in elements, not in bytes) as the third argument. The second and third arguments are optional. If you omit both, then the array will use all of the memory in the array buffer. If you omit only the length argument, then your array will use all of the available memory between the start position and the end of the array. One more thing to bear in mind about this form of the typed array constructor: arrays must be memory aligned, so if you specify a byte offset, the value should be a multiple of the size of your type. The Int32Array() constructor requires a multiple of four, for example, and the Float64Array() requires a multiple of eight. Given the ArrayBuffer created earlier, you could create typed arrays like these: let asbytes = new Uint8Array(buffer); // Viewed as bytes let asints = new Int32Array(buffer); // Viewed as 32-bit signed ints let lastK = new Uint8Array(buffer, 1023*1024); // Last kilobyte as bytes let ints2 = new Int32Array(buffer, 1024, 256); // 2nd kilobyte as 256 integers These four typed arrays offer four different views into the memory represented by the ArrayBuffer. It is important to understand that all typed arrays have an underlying ArrayBuffer, even if you do not explicitly specify one. If you call a typed ar","date":"2020-11-02","objectID":"/posts/ch11/:2:2","tags":null,"title":"第 11 章 JavaScript 标准库","uri":"/posts/ch11/"},{"categories":null,"content":"11.2.3 Using Typed Arrays Once you have created a typed array, you can read and write its elements with regular square-bracket notation, just as you would with any other array-like object: // Return the largest prime smaller than n, using the sieve of Eratosthenes function sieve(n) { let a = new Uint8Array(n+1); // a[x] will be 1 if x is composite let max = Math.floor(Math.sqrt(n)); // Don't do factors higher than this let p = 2; // 2 is the first prime while(p \u003c= max) { // For primes less than max for(let i = 2*p; i \u003c= n; i += p) // Mark multiples of p as composite a[i] = 1; while(a[++p]) /* empty */; // The next unmarked index is prime } while(a[n]) n--; // Loop backward to find the last prime return n; // And return it } The function here computes the largest prime number smaller than the number you specify. The code is exactly the same as it would be with a regular JavaScript array, but using Uint8Array() instead of Array() makes the code run more than four times faster and use eight times less memory in my testing. Typed arrays are not true arrays, but they re-implement most array methods, so you can use them pretty much just like you’d use regular arrays: let ints = new Int16Array(10); // 10 short integers ints.fill(3).map(x=\u003ex*x).join(\"\") // =\u003e \"9999999999\" Remember that typed arrays have fixed lengths, so the length property is read-only, and methods that change the length of the array (such as push(), pop(), unshift(), shift(), and splice()) are not implemented for typed arrays. Methods that alter the contents of an array without changing the length (such as sort(), reverse(), and fill()) are implemented. Methods like map() and slice() that return new arrays return a typed array of the same type as the one they are called on. ","date":"2020-11-02","objectID":"/posts/ch11/:2:3","tags":null,"title":"第 11 章 JavaScript 标准库","uri":"/posts/ch11/"},{"categories":null,"content":"11.2.4 Typed Array Methods and Properties In addition to standard array methods, typed arrays also implement a few methods of their own. The set() method sets multiple elements of a typed array at once by copying the elements of a regular or typed array into a typed array: let bytes = new Uint8Array(1024); // A 1K buffer let pattern = new Uint8Array([0,1,2,3]); // An array of 4 bytes bytes.set(pattern); // Copy them to the start of another byte array bytes.set(pattern, 4); // Copy them again at a different offset bytes.set([0,1,2,3], 8); // Or just copy values direct from a regular array bytes.slice(0, 12) // =\u003e new Uint8Array([0,1,2,3,0,1,2,3,0,1,2,3]) The set() method takes an array or typed array as its first argument and an element offset as its optional second argument, which defaults to 0 if left unspecified. If you are copying values from one typed array to another, the operation will likely be extremely fast. Typed arrays also have a subarray method that returns a portion of the array on which it is called: let ints = new Int16Array([0,1,2,3,4,5,6,7,8,9]); // 10 short integers let last3 = ints.subarray(ints.length-3, ints.length); // Last 3 of them last3[0] // =\u003e 7: this is the same as ints[7] subarray() takes the same arguments as the slice() method and seems to work the same way. But there is an important difference. slice() returns the specified elements in a new, independent typed array that does not share memory with the original array. subarray() does not copy any memory; it just returns a new view of the same underlying values: ints[9] = -1; // Change a value in the original array and... last3[2] // =\u003e -1: it also changes in the subarray The fact that the subarray() method returns a new view of an existing array brings us back to the topic of ArrayBuffers. Every typed array has three properties that relate to the underlying buffer: last3.buffer // The ArrayBuffer object for a typed array last3.buffer === ints.buffer // =\u003e true: both are views of the same buffer last3.byteOffset // =\u003e 14: this view starts at byte 14 of the buffer last3.byteLength // =\u003e 6: this view is 6 bytes (3 16-bit ints) long last3.buffer.byteLength // =\u003e 20: but the underlying buffer has 20 bytes The buffer property is the ArrayBuffer of the array. byteOffset is the starting position of the array’s data within the underlying buffer. And byteLength is the length of the array’s data in bytes. For any typed array, a, this invariant should always be true: a.length * a.BYTES_PER_ELEMENT === a.byteLength // =\u003e true ArrayBuffers are just opaque chunks of bytes. You can access those bytes with typed arrays, but an ArrayBuffer is not itself a typed array. Be careful, however: you can use numeric array indexing with ArrayBuffers just as you can with any JavaScript object. Doing so does not give you access to the bytes in the buffer, but it can cause confusing bugs: let bytes = new Uint8Array(8); bytes[0] = 1; // Set the first byte to 1 bytes.buffer[0] // =\u003e undefined: buffer doesn't have index 0 bytes.buffer[1] = 255; // Try incorrectly to set a byte in the buffer bytes.buffer[1] // =\u003e 255: this just sets a regular JS property bytes[1] // =\u003e 0: the line above did not set the byte We saw previously that you can create an ArrayBuffer with the ArrayBuffer() constructor and then create typed arrays that use that buffer. Another approach is to create an initial typed array, then use the buffer of that array to create other views: let bytes = new Uint8Array(1024); // 1024 bytes let ints = new Uint32Array(bytes.buffer); // or 256 integers let floats = new Float64Array(bytes.buffer); // or 128 doubles ","date":"2020-11-02","objectID":"/posts/ch11/:2:4","tags":null,"title":"第 11 章 JavaScript 标准库","uri":"/posts/ch11/"},{"categories":null,"content":"11.2.5 DataView and Endianness Typed arrays allow you to view the same sequence of bytes in chunks of 8, 16, 32, or 64 bits. This exposes the “endianness”: the order in which bytes are arranged into longer words. For efficiency, typed arrays use the native endianness of the underlying hardware. On little-endian systems, the bytes of a number are arranged in an ArrayBuffer from least significant to most significant. On big-endian platforms, the bytes are arranged from most significant to least significant. You can determine the endianness of the underlying platform with code like this: // If the integer 0x00000001 is arranged in memory as 01 00 00 00, then // we're on a little-endian platform. On a big-endian platform, we'd get // bytes 00 00 00 01 instead. let littleEndian = new Int8Array(new Int32Array([1]).buffer)[0] === 1; Today, the most common CPU architectures are little-endian. Many network protocols, and some binary file formats, require big-endian byte ordering, however. If you’re using typed arrays with data that came from the network or from a file, you can’t just assume that the platform endianness matches the byte order of the data. In general, when working with external data, you can use Int8Array and Uint8Array to view the data as an array of individual bytes, but you should not use the other typed arrays with multibyte word sizes. Instead, you can use the DataView class, which defines methods for reading and writing values from an ArrayBuffer with explicitly specified byte ordering: // Assume we have a typed array of bytes of binary data to process. First, // we create a DataView object so we can flexibly read and write // values from those bytes let view = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength); let int = view.getInt32(0); // Read big-endian signed int from byte 0 int = view.getInt32(4, false); // Next int is also big-endian int = view.getUint32(8, true); // Next int is little-endian and unsigned view.setUint32(8, int, false); // Write it back in big-endian format DataView defines 10 get methods for each of the 10 typed array classes (excluding Uint8ClampedArray). They have names like getInt16(), getUint32(), getBigInt64(), and getFloat64(). The first argument is the byte offset within the ArrayBuffer at which the value begins. All of these getter methods, other than getInt8() and getUint8(), accept an optional boolean value as their second argument. If the second argument is omitted or is false, big-endian byte ordering is used. If the second argument is true, little-endian ordering is used. DataView also defines 10 corresponding Set methods that write values into the underlying ArrayBuffer. The first argument is the offset at which the value begins. The second argument is the value to write. Each of the methods, except setInt8() and setUint8(), accepts an optional third argument. If the argument is omitted or is false, the value is written in big-endian format with the most significant byte first. If the argument is true, the value is written in little-endian format with the least significant byte first. Typed arrays and the DataView class give you all the tools you need to process binary data and enable you to write JavaScript programs that do things like decompressing ZIP files or extracting metadata from JPEG files. ","date":"2020-11-02","objectID":"/posts/ch11/:2:5","tags":null,"title":"第 11 章 JavaScript 标准库","uri":"/posts/ch11/"},{"categories":null,"content":"11.3 Pattern Matching with Regular Expressions A regular expression is an object that describes a textual pattern. The JavaScript RegExp class represents regular expressions, and both String and RegExp define methods that use regular expressions to perform powerful pattern-matching and search-and-replace functions on text. In order to use the RegExp API effectively, however, you must also learn how to describe patterns of text using the regular expression grammar, which is essentially a mini programming language of its own. Fortunately, the JavaScript regular expression grammar is quite similar to the grammar used by many other programming languages, so you may already be familiar with it. (And if you are not, the effort you invest in learning JavaScript regular expressions will probably be useful to you in other programming contexts as well.) 正则表达式是描述文本模式的对象。JavaScript RegExp 类表示正则表达式，而 String 和 RegExp 都定义了使用正则表达式对文本执行强大的模式匹配和搜索替换功能的方法。但是，为了有效地使用 RegExp API，还必须学习如何使用正则表达式语法描述文本模式，该语法本质上是其自身的一种小型编程语言。幸运的是，JavaScript 正则表达式语法与许多其他编程语言所使用的语法非常相似，因此您可能已经很熟悉它。（如果不是这样，则在学习 JavaScript 正则表达式上投入的精力也可能在其他编程环境中对您很有用。） The subsections that follow describe the regular expression grammar first, and then, after explaining how to write regular expressions, they explain how you can use them with methods of the String and RegExp classes. 接下来的小节首先描述正则表达式语法，然后在解释了如何编写正则表达式之后，它们解释了如何将其与 String 和 RegExp 类的方法一起使用。 ","date":"2020-11-02","objectID":"/posts/ch11/:3:0","tags":null,"title":"第 11 章 JavaScript 标准库","uri":"/posts/ch11/"},{"categories":null,"content":"11.3.1 Defining Regular Expressions In JavaScript, regular expressions are represented by RegExp objects. RegExp objects may be created with the RegExp() constructor, of course, but they are more often created using a special literal syntax. Just as string literals are specified as characters within quotation marks, regular expression literals are specified as characters within a pair of slash (/) characters. Thus, your JavaScript code may contain lines like this: let pattern = /s$/; This line creates a new RegExp object and assigns it to the variable pattern. This particular RegExp object matches any string that ends with the letter “s.” This regular expression could have equivalently been defined with the RegExp() constructor, like this: let pattern = new RegExp(“s$\"); Regular-expression pattern specifications consist of a series of characters. Most characters, including all alphanumeric characters, simply describe characters to be matched literally. Thus, the regular expression /java/ matches any string that contains the substring “java”. Other characters in regular expressions are not matched literally but have special significance. For example, the regular expression /s$/ contains two characters. The first, “s”, matches itself literally. The second, “$”, is a special meta-character that matches the end of a string. Thus, this regular expression matches any string that contains the letter “s” as its last character. As we’ll see, regular expressions can also have one or more flag characters that affect how they work. Flags are specified following the second slash character in RegExp literals, or as a second string argument to the RegExp() constructor. If we wanted to match strings that end with “s” or “S”, for example, we could use the i flag with our regular expression to indicate that we want case-insensitive matching: let pattern = /s$/i; The following sections describe the various characters and meta-characters used in JavaScript regular expressions. LITERAL CHARACTERS All alphabetic characters and digits match themselves literally in regular expressions. JavaScript regular expression syntax also supports certain nonalphabetic characters through escape sequences that begin with a backslash (\\). For example, the sequence \\n matches a literal newline character in a string. Table 11-1 lists these characters. Table 11-1. Regular-expression literal characters Character Matches Alphanumeric character Itself \\0 The NUL character (\\u0000) \\t Tab (\\u0009) \\n Newline (\\u000A) \\v Vertical tab (\\u000B) \\f Form feed (\\u000C) \\r Carriage return (\\u000D) \\xnn The Latin character specified by the hexadecimal number nn; for example, \\x0A is the same as \\n. \\uxxxx The Unicode character specified by the hexadecimal number xxxx; for example, \\u0009 is the same as \\t. \\u{n} The Unicode character specified by the codepoint n, where n is one to six hexadecimal digits between 0 and 10FFFF. Note that this syntax is only supported in regular expressions that use the u flag. \\cX The control character ^X; for example, \\cJ is equivalent to the newline character \\n. A number of punctuation characters have special meanings in regular expressions. They are: ^ $ . * + ? = ! : | \\ / ( ) [ ] { } The meanings of these characters are discussed in the sections that follow. Some of these characters have special meaning only within certain contexts of a regular expression and are treated literally in other contexts. As a general rule, however, if you want to include any of these punctuation characters literally in a regular expression, you must precede them with a \\. Other punctuation characters, such as quotation marks and @, do not have special meaning and simply match themselves literally in a regular expression. If you can’t remember exactly which punctuation characters need to be escaped with a backslash, you may safely place a backslash before any punctuation character. On the other hand, note that many letters and numbers have special meaning when prec","date":"2020-11-02","objectID":"/posts/ch11/:3:1","tags":null,"title":"第 11 章 JavaScript 标准库","uri":"/posts/ch11/"},{"categories":null,"content":"11.3.2 String Methods for Pattern Matching Until now, we have been describing the grammar used to define regular expressions, but not explaining how those regular expressions can actually be used in JavaScript code. We are now switching to cover the API for using RegExp objects. This section begins by explaining the string methods that use regular expressions to perform pattern matching and search-and-replace operations. The sections that follow this one continue the discussion of pattern matching with JavaScript regular expressions by discussing the RegExp object and its methods and properties. SEARCH() Strings support four methods that use regular expressions. The simplest is search(). This method takes a regular expression argument and returns either the character position of the start of the first matching substring or −1 if there is no match: \"JavaScript\".search(/script/ui) // =\u003e 4 \"Python\".search(/script/ui) // =\u003e -1 If the argument to search() is not a regular expression, it is first converted to one by passing it to the RegExp constructor. search() does not support global searches; it ignores the g flag of its regular expression argument. REPLACE() The replace() method performs a search-and-replace operation. It takes a regular expression as its first argument and a replacement string as its second argument. It searches the string on which it is called for matches with the specified pattern. If the regular expression has the g flag set, the replace() method replaces all matches in the string with the replacement string; otherwise, it replaces only the first match it finds. If the first argument to replace() is a string rather than a regular expression, the method searches for that string literally rather than converting it to a regular expression with the RegExp() constructor, as search() does. As an example, you can use replace() as follows to provide uniform capitalization of the word “JavaScript” throughout a string of text: // No matter how it is capitalized, replace it with the correct capitalization text.replace(/javascript/gi, \"JavaScript\"); replace() is more powerful than this, however. Recall that parenthesized subexpressions of a regular expression are numbered from left to right and that the regular expression remembers the text that each subexpression matches. If a $ followed by a digit appears in the replacement string, replace() replaces those two characters with the text that matches the specified subexpression. This is a very useful feature. You can use it, for example, to replace quotation marks in a string with other characters: // A quote is a quotation mark, followed by any number of // nonquotation mark characters (which we capture), followed // by another quotation mark. let quote = /\"([^\"]*)\"/g; // Replace the straight quotation marks with guillemets // leaving the quoted text (stored in $1) unchanged. 'He said \"stop\"'.replace(quote, '«$1»') // =\u003e 'He said «stop»' If your RegExp uses named capture groups, then you can refer to the matching text by name rather than by number: let quote = /\"(?\u003cquotedText\u003e[^\"]*)\"/g; 'He said \"stop\"'.replace(quote, '«$\u003cquotedText\u003e»') // =\u003e 'He said «stop»' Instead of passing a replacement string as the second argument to replace(), you can also pass a function that will be invoked to compute the replacement value. The replacement function is invoked with a number of arguments. First is the entire matched text. Next, if the RegExp has capturing groups, then the substrings that were captured by those groups are passed as arguments. The next argument is the position within the string at which the match was found. After that, the entire string that replace() was called on is passed. And finally, if the RegExp contained any named capture groups, the last argument to the replacement function is an object whose property names match the capture group names and whose values are the matching text. As an example, here is code that uses a replacement function to convert decimal ","date":"2020-11-02","objectID":"/posts/ch11/:3:2","tags":null,"title":"第 11 章 JavaScript 标准库","uri":"/posts/ch11/"},{"categories":null,"content":"11.3.3 The RegExp Class This section documents the RegExp() constructor, the properties of RegExp instances, and two important pattern-matching methods defined by the RegExp class. The RegExp() constructor takes one or two string arguments and creates a new RegExp object. The first argument to this constructor is a string that contains the body of the regular expression—the text that would appear within slashes in a regular-expression literal. Note that both string literals and regular expressions use the \\ character for escape sequences, so when you pass a regular expression to RegExp() as a string literal, you must replace each \\ character with \\. The second argument to RegExp() is optional. If supplied, it indicates the regular expression flags. It should be g, i, m, s, u, y, or any combination of those letters. For example: // Find all five-digit numbers in a string. Note the double \\\\ in this case. let zipcode = new RegExp(\"\\\\d{5}\", \"g\"); The RegExp() constructor is useful when a regular expression is being dynamically created and thus cannot be represented with the regular expression literal syntax. For example, to search for a string entered by the user, a regular expression must be created at runtime with RegExp(). Instead of passing a string as the first argument to RegExp(), you can also pass a RegExp object. This allows you to copy a regular expression and change its flags: let exactMatch = /JavaScript/; let caseInsensitive = new RegExp(exactMatch, \"i\"); REGEXP PROPERTIES RegExp objects have the following properties: source This read-only property is the source text of the regular expression: the characters that appear between the slashes in a RegExp literal. flags This read-only property is a string that specifies the set of letters that represent the flags for the RegExp. global A read-only boolean property that is true if the g flag is set. ignoreCase A read-only boolean property that is true if the i flag is set. multiline A read-only boolean property that is true if the m flag is set. dotAll A read-only boolean property that is true if the s flag is set. unicode A read-only boolean property that is true if the u flag is set. sticky A read-only boolean property that is true if the y flag is set. lastIndex This property is a read/write integer. For patterns with the g or y flags, it specifies the character position at which the next search is to begin. It is used by the exec() and test() methods, described in the next two subsections. TEST() The test() method of the RegExp class is the simplest way to use a regular expression. It takes a single string argument and returns true if the string matches the pattern or false if it does not match. test() works by simply calling the (much more complicated) exec() method described in the next section and returning true if exec() returns a non-null value. Because of this, if you use test() with a RegExp that uses the g or y flags, then its behavior depends on the value of the lastIndex property of the RegExp object, which can change unexpectedly. See “The lastIndex Property and RegExp Reuse” for more details. EXEC() The RegExp exec() method is the most general and powerful way to use regular expressions. It takes a single string argument and looks for a match in that string. If no match is found, it returns null. If a match is found, however, it returns an array just like the array returned by the match() method for non-global searches. Element 0 of the array contains the string that matched the regular expression, and any subsequent array elements contain the substrings that matched any capturing groups. The returned array also has named properties: the index property contains the character position at which the match occurred, and the input property specifies the string that was searched, and the groups property, if defined, refers to an object that holds the substrings matching the any named capturing groups. Unlike the String match() method, exec() returns the same kin","date":"2020-11-02","objectID":"/posts/ch11/:3:3","tags":null,"title":"第 11 章 JavaScript 标准库","uri":"/posts/ch11/"},{"categories":null,"content":"11.4 Dates and Times The Date class is JavaScript’s API for working with dates and times. Create a Date object with the Date() constructor. With no arguments, it returns a Date object that represents the current date and time: Date 类是用于处理日期和时间的 JavaScript API。 使用 Date() 构造函数创建一个 Date 对象。没有实参，它将返回一个 Date 对象，该对象代表当前日期和时间： let now = new Date(); // The current time If you pass one numeric argument, the Date() constructor interprets that argument as the number of milliseconds since the 1970 epoch: 如果传递一个数字实参，则 Date() 构造函数将该实参解释为自 1970 年以来的毫秒数： let epoch = new Date(0); // Midnight, January 1st, 1970, GMT If you specify two or more integer arguments, they are interpreted as the year, month, day-of-month, hour, minute, second, and millisecond in your local time zone, as in the following: 如果指定两个或多个整数实参，则它们将被解释为本地时区中的年、月、日、小时、分钟、秒和毫秒，如下所示： let century = new Date(2100, // Year 2100 0, // January 1, // 1st 2, 3, 4, 5); // 02:03:04.005, local time One quirk of the Date API is that the first month of a year is number 0, but the first day of a month is number 1. If you omit the time fields, the Date() constructor defaults them all to 0, setting the time to midnight. Date API 的一个怪癖是一年的第一个月是数字 0，而一个月的第一天是数字 1。如果省略了时间字段，则 Date() 构造函数会将它们全部默认为 0，并将时间设置为到午夜。 Note that when invoked with multiple numbers, the Date() constructor interprets them using whatever time zone the local computer is set to. If you want to specify a date and time in UTC (Universal Coordinated Time, aka GMT), then you can use the Date.UTC(). This static method takes the same arguments as the Date() constructor, interprets them in UTC, and returns a millisecond timestamp that you can pass to the Date() constructor: 请注意，当使用多个数字调用时，Date() 构造函数使用本地计算机设置为的时区解释它们。如果要以UTC（协调世界时，又称为GMT）指定日期和时间，则可以使用 Date.UTC()。 此静态方法采用与 Date() 构造函数相同的实参，以 UTC 解释它们，并返回可以传递给 Date() 构造函数的毫秒级时间戳： // Midnight in England, January 1, 2100 let century = new Date(Date.UTC(2100, 0, 1)); If you print a date (with console.log(century), for example), it will, by default, be printed in your local time zone. If you want to display a date in UTC, you should explicitly convert it to a string with toUTCString() or toISOString(). 如果您打印日期（例如，使用 console.log(century)），则默认情况下将在本地时区打印日期。 如果要以 UTC 显示日期，则应使用 toUTCString() 或 toISOString() 将其显式转换为字符串。 Finally, if you pass a string to the Date() constructor, it will attempt to parse that string as a date and time specification. The constructor can parse dates specified in the formats produced by the toString(), toUTCString(), and toISOString() methods: 最后，如果将字符串传递给 Date() 构造函数，它将尝试解析该字符串作为日期和时间规范。构造函数可以解析以 toString()、toUTCString() 和 toISOString() 方法产生的格式指定的日期： let century = new Date(\"2100-01-01T00:00:00Z\"); // An ISO format date Once you have a Date object, various get and set methods allow you to query and modify the year, month, day-of-month, hour, minute, second, and millisecond fields of the Date. Each of these methods has two forms: one that gets or sets using local time and one that gets or sets using UTC time. To get or set the year of a Date object, for example, you would use getFullYear(), getUTCFullYear(), setFullYear(), or setUTCFullYear(): 有了 Date 对象后，可以使用各种 get 和 set 方法查询和修改日期的年、月、日、小时、分钟、秒和毫秒字段。这些方法中的每一种都有两种形式：一种使用本地时间获取或设置，另一种使用 UTC 时间获取或设置。例如，要获取或设置 Date 对象的年份，可以使用 getFullYear()、getUTCFullYear()、setFullYear() 或 setUTCFullYear()： let d = new Date(); // Start with the current date d.setFullYear(d.getFullYear() + 1); // Increment the year To get or set the other fields of a Date, replace “FullYear” in the method name with “Month”, “Date”, “Hours”, “Minutes”, “Seconds”, or “Milliseconds”. Some of the date set methods allow you to set more than one field at a time. setFullYear() and setUTCFullYear() also optionally allow you to set the month and day-of-month as well. And setHours() and setUTCHours() allow you to specify the minutes, seconds, and milliseconds fields in addition to the hours field. 要获取或设置日期的其他字段，请将方法名称中的“FullYear”替换为“Month”、“Date”、“Hours”、“Minutes”、“Seco","date":"2020-11-02","objectID":"/posts/ch11/:4:0","tags":null,"title":"第 11 章 JavaScript 标准库","uri":"/posts/ch11/"},{"categories":null,"content":"11.4.1 Timestamps JavaScript represents dates internally as integers that specify the number of milliseconds since (or before) midnight on January 1, 1970, UTC time. Integers as large as 8,640,000,000,000,000 are supported, so JavaScript won’t be running out of milliseconds for more than 270,000 years. JavaScript 在内部将日期表示为整数，该整数指定自 UTC 时间 1970 年 1 月 1 日午夜以来（或之前）的毫秒数。 支持的最大整数为 8,640,000,000,000,000，因此 JavaScript 在超过 270,000 年的时间内不会用完毫秒。 For any Date object, the getTime() method returns this internal value, and the setTime() method sets it. So you can add 30 seconds to a Date with code like this, for example: 对于任何 Date 对象，getTime() 方法将返回此内部值，而 setTime() 方法将对其进行设置。 因此，可以使用以下代码向日期添加 30 秒，例如： d.setTime(d.getTime() + 30000); These millisecond values are sometimes called timestamps, and it is sometimes useful to work with them directly rather than with Date objects. The static Date.now() method returns the current time as a timestamp and is helpful when you want to measure how long your code takes to run: 这些毫秒值有时被称为时间戳，有时直接使用它们而不是使用日期对象有时很有用。静态的 Date.now() 方法返回当前时间作为时间戳，当要测量代码运行多长时间时，该方法很有用： let startTime = Date.now(); reticulateSplines(); // Do some time-consuming operation let endTime = Date.now(); console.log(`Spline reticulation took ${endTime - startTime}ms.`); HIGH-RESOLUTION TIMESTAMPS The timestamps returned by Date.now() are measured in milliseconds. A millisecond is actually a relatively long time for a computer, and sometimes you may want to measure elapsed time with higher precision. The performance.now() function allows this: it also returns a millisecond-based timestamp, but the return value is not an integer, so it includes fractions of a millisecond. The value returned by performance.now() is not an absolute timestamp like the Date.now() value is. Instead, it simply indicates how much time has elapsed since a web page was loaded or since the Node process started. Date.now() 返回的时间戳以毫秒为单位。对于计算机而言，毫秒实际上是一个相对较长的时间，有时您可能希望以更高的精度测量经过的时间。performance.now() 函数允许这样做：它也返回毫秒级的时间戳，但是返回值不是整数，因此它包含毫秒的分数。 performance.now() 返回的值不是像 Date.now() 那样的绝对时间戳。取而代之的是，它仅指示网页加载成功或 Node 进程开始以来已花费了多少时间。 The performance object is part of a larger Performance API that is not defined by the ECMAScript standard but is implemented by web browsers and by Node. In order to use the performance object in Node, you must import it with: performance 对象是较大的 Performance API 的一部分，该 API 不是由 ECMAScript 标准定义的，而是由 Web 浏览器和 Node 实现的。为了在 Node 中使用 performance 对象，必须使用以下命令导入它： const { performance } = require(\"perf_hooks\"); Allowing high-precision timing on the web may allow unscrupulous websites to fingerprint visitors, so browsers (notably Firefox) may reduce the precision of performance.now() by default. As a web developer, you should be able to re-enable high-precision timing somehow (such as by setting privacy.reduceTimerPrecision to false in Firefox). 允许在 Web 上进行高精度计时可能会导致不道德的网站对访问者进行指纹识别，因此默认情况下，浏览器（尤其是Firefox）可能会降低 performance.now() 的精度。作为 Web 开发人员，您应该能够以某种方式重新启用高精度计时（例如，通过在 Firefox 中将 privacy.reduceTimerPrecision 设置为 false）。 ","date":"2020-11-02","objectID":"/posts/ch11/:4:1","tags":null,"title":"第 11 章 JavaScript 标准库","uri":"/posts/ch11/"},{"categories":null,"content":"11.4.2 Date Arithmetic Date objects can be compared with JavaScript’s standard \u003c, \u003c=, \u003e, and \u003e= comparison operators. And you can subtract one Date object from another to determine the number of milliseconds between the two dates. (This works because the Date class defines a valueOf() method that returns a timestamp.) 日期对象可以用 JavaScript 的标准 \u003c、\u003c=、\u003e 和 \u003e= 比较运算符进行比较。可以从另一个日期对象中减去一个日期对象，以确定两个日期之间的毫秒数。（这是有效的，因为 Date 类定义了一个返回时间戳的 valueOf() 方法。） If you want to add or subtract a specified number of seconds, minutes, or hours from a Date, it is often easiest to simply modify the timestamp as demonstrated in the previous example, when we added 30 seconds to a date. This technique becomes more cumbersome if you want to add days, and it does not work at all for months and years since they have varying numbers of days. To do date arithmetic involving days, months, and years, you can use setDate(), setMonth(), and setYear(). Here, for example, is code that adds three months and two weeks to the current date: 如果您想从日期中添加或减去指定的秒、分钟数或小时数，通常最简单的方法就是修改时间戳，如上一个示例所示，即为日期添加 30 秒。如果要添加天数，此技术将变得更加繁琐，并且由于它们的天数不同，因此几个月甚至几年都无法使用。要进行涉及天，月和年的日期算术，可以使用 setDate()、setMonth() 和 setYear()。例如，下面的代码向当前日期添加了三个月零两个星期： let d = new Date(); d.setMonth(d.getMonth() + 3, d.getDate() + 14); Date setting methods work correctly even when they overflow. When we add three months to the current month, we can end up with a value greater than 11 (which represents December). The setMonth() handles this by incrementing the year as needed. Similarly, when we set the day of the month to a value larger than the number of days in the month, the month gets incremented appropriately. 日期设置方法即使在溢出时也可以正常工作。当我们在当月增加三个月时，最终可以得到大于 11 的值（代表 12 月）。setMonth() 通过根据需要增加年份来处理此问题。同样，当我们将月份中的日期设置为大于月份中天数的值时，月份会适当增加。 ","date":"2020-11-02","objectID":"/posts/ch11/:4:2","tags":null,"title":"第 11 章 JavaScript 标准库","uri":"/posts/ch11/"},{"categories":null,"content":"11.4.3 Formatting and Parsing Date Strings If you are using the Date class to actually keep track of dates and times (as opposed to just measuring time intervals), then you are likely to need to display dates and times to the users of your code. The Date class defines a number of different methods for converting Date objects to strings. Here are some examples: 如果使用 Date 类实际跟踪日期和时间（而不是仅测量时间间隔），则可能需要向代码用户显示日期和时间。 Date 类定义了许多用于将 Date 对象转换为字符串的不同方法。这里有些例子： let d = new Date(2020, 0, 1, 17, 10, 30); // 5:10:30pm on New Year's Day 2020 d.toString() // =\u003e \"Wed Jan 01 2020 17:10:30 GMT-0800 (Pacific Standard Time)\" d.toUTCString() // =\u003e \"Thu, 02 Jan 2020 01:10:30 GMT\" d.toLocaleDateString() // =\u003e \"1/1/2020\": 'en-US' locale d.toLocaleTimeString() // =\u003e \"5:10:30 PM\": 'en-US' locale d.toISOString() // =\u003e \"2020-01-02T01:10:30.000Z\" This is a full list of the string formatting methods of the Date class: 这是 Date 类的字符串格式化方法的完整列表： toString() This method uses the local time zone but does not format the date and time in a locale-aware way. 此方法使用本地时区，但不以语言环境的方式格式化日期和时间。 toUTCString() This method uses the UTC time zone but does not format the date in a locale-aware way. 此方法使用 UTC 时区，但不以语言环境的方式格式化日期和时间。 toISOString() This method prints the date and time in the standard year-month-day hours:minutes:seconds.ms format of the ISO-8601 standard. The letter “T” separates the date portion of the output from the time portion of the output. The time is expressed in UTC, and this is indicated with the letter “Z” as the last letter of the output. 此方法以 ISO-8601 标准的标准 year-month-day hours:minutes:seconds.ms 格式打印日期和时间。 字母“T”将输出的日期部分与输出的时间部分分开。时间以 UTC 表示，并以字母“Z”表示为输出的最后一个字母。 toLocaleString() This method uses the local time zone and a format that is appropriate for the user’s locale. 此方法使用本地时区和适合用户所在区域的格式。 toDateString() This method formats only the date portion of the Date and omits the time. It uses the local time zone and does not do locale-appropriate formatting. 此方法仅格式化日期的日期部分，并省略时间。它使用本地时区，并且不进行适合区域设置的格式。 toLocaleDateString() This method formats only the date. It uses the local time zone and a locale-appropriate date format. 此方法仅格式化日期。它使用本地时区和适合本地的日期格式。 toTimeString() This method formats only the time and omits the date. It uses the local time zone but does not format the time in a locale-aware way. 此方法仅格式化时间，而省略日期。它使用本地时区，但不以语言环境的方式格式化时间。 toLocaleTimeString() This method formats the time in a locale-aware way and uses the local time zone. 此方法以语言环境的方式格式化时间，并使用本地时区。 None of these date-to-string methods is ideal when formatting dates and times to be displayed to end users. See §11.7.2 for a more general-purpose and locale-aware date- and time-formatting technique. 在格式化要显示给最终用户的日期和时间时，这些日期到字符串方法都不是理想的选择。有关更通用的和可识别区域设置的日期和时间格式技术，请参见 §11.7.2。 Finally, in addition to these methods that convert a Date object to a string, there is also a static Date.parse() method that takes a string as its argument, attempts to parse it as a date and time, and returns a timestamp representing that date. Date.parse() is able to parse the same strings that the Date() constructor can and is guaranteed to be able to parse the output of toISOString(), toUTCString(), and toString(). 最后，除了将 Date 对象转换为字符串的这些方法之外，还有一个静态 Date.parse() 方法，该方法将字符串作为实参，尝试将其解析为日期和时间，并返回时间戳描述日期。Date.parse() 能够解析与 Date() 构造函数相同的字符串，并保证能够解析 toISOString()、toUTCString() 和 toString() 的输出。 ","date":"2020-11-02","objectID":"/posts/ch11/:4:3","tags":null,"title":"第 11 章 JavaScript 标准库","uri":"/posts/ch11/"},{"categories":null,"content":"11.5 Error Classes The JavaScript throw and catch statements can throw and catch any JavaScript value, including primitive values. There is no exception type that must be used to signal errors. JavaScript does define an Error class, however, and it is traditional to use instances of Error or a subclass when signaling an error with throw. One good reason to use an Error object is that, when you create an Error, it captures the state of the JavaScript stack, and if the exception is uncaught, the stack trace will be displayed with the error message, which will help you debug the issue. (Note that the stack trace shows where the Error object was created, not where the throw statement throws it. If you always create the object right before throwing it with throw new Error(), this will not cause any confusion.) JavaScript 的 throw 和 catch 语句可以抛出并捕获任何 JavaScript 值，包括原始值。没有必须用于发出错误的异常类型。JavaScript 确实定义了一个 Error 类，但是传统上是使用 throw 发出错误信号时使用 Error 的实例或子类。使用 Error 对象的一个​​很好的理由是，当创建一个 Error 时，它会捕获 JavaScript 堆栈的状态，并且如果未捕获到异常，则堆栈跟踪将与错误消息一起显示，这将有助于调试问题。（请注意，堆栈跟踪显示的是 Error 对象的创建位置，而不是 throw 语句将其抛出的位置。如果总是在使用 throw new Error() 对其进行抛出之前立即创建该对象，则不会造成任何混乱。） Error objects have two properties: message and name, and a toString() method. The value of the message property is the value you passed to the Error() constructor, converted to a string if necessary. For error objects created with Error(), the name property is always “Error”. The toString() method simply returns the value of the name property followed by a colon and space and the value of the message property. 错误对象具有两个属性：message 和 name，以及一个 toString() 方法。 message 属性的值是传递给 Error() 构造函数的值，并在必要时转换为字符串。对于使用 Error() 创建的错误对象，name 属性始终为“Error”。toString() 方法仅返回 name 属性的值后跟冒号和空格以及 message 属性的值。 Although it is not part of the ECMAScript standard, Node and all modern browsers also define a stack property on Error objects. The value of this property is a multi-line string that contains a stack trace of the JavaScript call stack at the moment that the Error object was created. This can be useful information to log when an unexpected error is caught. 尽管它不是 ECMAScript 标准的一部分，但 Node 和所有现代浏览器还在 Error 对象上定义了 stack 属性。此属性的值是多行字符串，其中包含创建 Error 对象时的 JavaScript 调用堆栈的堆栈跟踪。当捕获到意外错误时，这对于记录日志很有用。 In addition to the Error class, JavaScript defines a number of subclasses that it uses to signal particular types of errors defined by ECMAScript. These subclasses are EvalError, RangeError, ReferenceError, SyntaxError, TypeError, and URIError. You can use these error classes in your own code if they seem appropriate. Like the base Error class, each of these subclasses has a constructor that takes a single message argument. And instances of each of these subclasses have a name property whose value is the same as the constructor name. 除了 Error 类之外，JavaScript 还定义了许多子类，这些子类用于表示 ECMAScript 定义的特定类型的错误。这些子类是 EvalError、RangeError、ReferenceError、SyntaxError、TypeError 和 URIError。如果合适可以在自己的代码中使用这些错误类。像基本错误类一样，这些子类每一个都有一个采用单个 message 实参的构造函数。每个这些子类的实例都有一个 name 属性，其值与构造函数名称相同。 You should feel free to define your own Error subclasses that best encapsulate the error conditions of your own program. Note that you are not limited to the name and message properties. If you create a subclass, you can define new properties to provide error details. If you are writing a parser, for example, you might find it useful to define a ParseError class with line and column properties that specify the exact location of the parsing failure. Or if you are working with HTTP requests, you might want to define an HTTPError class that has a status property that holds the HTTP status code (such as 404 or 500) of the failed request. 应该随意定义自己的错误子类，以最好地封装自己程序的错误条件。请注意，可以不受限于名称和消息两个属性。如果创建子类，则可以定义新属性以提供错误详细信息。例如，如果正在编写一个转换，可能会发现定义一个 ParseError 类非常有用，该类具有指定解析失败确切位置的行和列属性。或者，如果正在处理 HTTP 请求，则可能需要定义一个 HTTPError 类，该类具有一个 status 属性，该属性保存失败请求的 HTTP 状态代码（例如 404 或 500）。 For example: class HTTPError extends Error { constructor(status, statusText, url) { super(`${status}${statusTe","date":"2020-11-02","objectID":"/posts/ch11/:5:0","tags":null,"title":"第 11 章 JavaScript 标准库","uri":"/posts/ch11/"},{"categories":null,"content":"11.6 JSON Serialization and Parsing When a program needs to save data or needs to transmit data across a network connection to another program, it must to convert its in-memory data structures into a string of bytes or characters than can be saved or transmitted and then later be parsed to restore the original in-memory data structures. This process of converting data structures into streams of bytes or characters is known as serialization (or marshaling or even pickling). The easiest way to serialize data in JavaScript uses a serialization format known as JSON. This acronym stands for “JavaScript Object Notation” and, as the name implies, the format uses JavaScript object and array literal syntax to convert data structures consisting of objects and arrays into strings. JSON supports primitive numbers and strings and also the values true, false, and null, as well as arrays and objects built up from those primitive values. JSON does not support other JavaScript types like Map, Set, RegExp, Date, or typed arrays. Nevertheless, it has proved to be a remarkably versatile data format and is in common use even with non-JavaScript-based programs. JavaScript supports JSON serialization and deserialization with the two functions JSON.stringify() and JSON.parse(), which were covered briefly in §6.8. Given an object or array (nested arbitrarily deeply) that does not contain any nonserializable values like RegExp objects or typed arrays, you can serialize the object simply by passing it to JSON.stringify(). As the name implies, the return value of this function is a string. And given a string returned by JSON.stringify(), you can re-create the original data structure by passing the string to JSON.parse(): let o = {s: \"\", n: 0, a: [true, false, null]}; let s = JSON.stringify(o); // s == '{\"s\":\"\",\"n\":0,\"a\":[true,false,null]}' let copy = JSON.parse(s); // copy == {s: \"\", n: 0, a: [true, false, null]} If we leave out the part where serialized data is saved to a file or sent over the network, we can use this pair of functions as a somewhat inefficient way of creating a deep copy of an object: // Make a deep copy of any serializable object or array function deepcopy(o) { return JSON.parse(JSON.stringify(o)); } JSON IS A SUBSET OF JAVASCRIPT When data is serialized to JSON format, the result is valid JavaScript source code for an expression that evaluates to a copy of the original data structure. If you prefix a JSON string with var data = and pass the result to eval(), you’ll get a copy of the original data structure assigned to the variable data. You should never do this, however, because it is a huge security hole—if an attacker could inject arbitrary JavaScript code into a JSON file, they could make your program run their code. It is faster and safer to just use JSON.parse() to decode JSON-formatted data. JSON is sometimes used as a human-readable configuration file format. If you find yourself hand-editing a JSON file, note that the JSON format is a very strict subset of JavaScript. Comments are not allowed and property names must be enclosed in double quotes even when JavaScript would not require this. Typically, you pass only a single argument to JSON.stringify() and JSON.parse(). Both functions accept an optional second argument that allows us to extend the JSON format, and these are described next. JSON.stringify() also takes an optional third argument that we’ll discuss first. If you would like your JSON-formatted string to be human-readable (if it is being used as a configuration file, for example), then you should pass null as the second argument and pass a number or string as the third argument. This third argument tells JSON.stringify() that it should format the data on multiple indented lines. If the third argument is a number, then it will use that number of spaces for each indentation level. If the third argument is a string of whitespace (such as ‘\\t’), it will use that string for each level of indent. let o = {s: \"test\", n: 0}","date":"2020-11-02","objectID":"/posts/ch11/:6:0","tags":null,"title":"第 11 章 JavaScript 标准库","uri":"/posts/ch11/"},{"categories":null,"content":"11.6.1 JSON Customizations If JSON.stringify() is asked to serialize a value that is not natively supported by the JSON format, it looks to see if that value has a toJSON() method, and if so, it calls that method and then stringifies the return value in place of the original value. Date objects implement toJSON(): it returns the same string that toISOString() method does. This means that if you serialize an object that includes a Date, the date will automatically be converted to a string for you. When you parse the serialized string, the re-created data structure will not be exactly the same as the one you started with because it will have a string where the original object had a Date. If you need to re-create Date objects (or modify the parsed object in any other way), you can pass a “reviver” function as the second argument to JSON.parse(). If specified, this “reviver” function is invoked once for each primitive value (but not the objects or arrays that contain those primitive values) parsed from the input string. The function is invoked with two arguments. The first is a property name—either an object property name or an array index converted to a string. The second argument is the primitive value of that object property or array element. Furthermore, the function is invoked as a method of the object or array that contains the primitive value, so you can refer to that containing object with the this keyword. The return value of the reviver function becomes the new value of the named property. If it returns its second argument, the property will remain unchanged. If it returns undefined, then the named property will be deleted from the object or array before JSON.parse() returns to the user. As an example, here is a call to JSON.parse() that uses a reviver function to filter some properties and to re-create Date objects: let data = JSON.parse(text, function(key, value) { // Remove any values whose property name begins with an underscore if (key[0] === \"_\") return undefined; // If the value is a string in ISO 8601 date format convert it to a Date. if (typeof value === \"string\" \u0026\u0026 /^\\d\\d\\d\\d-\\d\\d-\\d\\dT\\d\\d:\\d\\d:\\d\\d.\\d\\d\\dZ$/.test(value)) { return new Date(value); } // Otherwise, return the value unchanged return value; }); In addition to its use of toJSON() described earlier, JSON.stringify() also allows its output to be customized by passing an array or a function as the optional second argument. If an array of strings (or numbers—they are converted to strings) is passed instead as the second argument, these are used as the names of object properties (or array elements). Any property whose name is not in the array will be omitted from stringification. Furthermore, the returned string will include properties in the same order that they appear in the array (which can be very useful when writing tests). If you pass a function, it is a replacer function—effectively the inverse of the optional reviver function you can pass to JSON.parse(). If specified, the replacer function is invoked for each value to be stringified. The first argument to the replacer function is the object property name or array index of the value within that object, and the second argument is the value itself. The replacer function is invoked as a method of the object or array that contains the value to be stringified. The return value of the replacer function is stringified in place of the original value. If the replacer returns undefined or returns nothing at all, then that value (and its array element or object property) is omitted from the stringification. // Specify what fields to serialize, and what order to serialize them in let text = JSON.stringify(address, [\"city\",\"state\",\"country\"]); // Specify a replacer function that omits RegExp-value properties let json = JSON.stringify(o, (k, v) =\u003e v instanceof RegExp ? undefined : v); The two JSON.stringify() calls here use the second argument in a benign way, producing serialized output that can be deseriali","date":"2020-11-02","objectID":"/posts/ch11/:6:1","tags":null,"title":"第 11 章 JavaScript 标准库","uri":"/posts/ch11/"},{"categories":null,"content":"11.7 The Internationalization API The JavaScript internationalization API consists of the three classes Intl.NumberFormat, Intl.DateTimeFormat, and Intl.Collator that allow us to format numbers (including monetary amounts and percentages), dates, and times in locale-appropriate ways and to compare strings in locale-appropriate ways. These classes are not part of the ECMAScript standard but are defined as part of the ECMA402 standard and are well-supported by web browsers. The Intl API is also supported in Node, but at the time of this writing, prebuilt Node binaries do not ship with the localization data required to make them work with locales other than US English. So in order to use these classes with Node, you may need to download a separate data package or use a custom build of Node. One of the most important parts of internationalization is displaying text that has been translated into the user’s language. There are various ways to achieve this, but none of them are within the scope of the Intl API described here. ","date":"2020-11-02","objectID":"/posts/ch11/:7:0","tags":null,"title":"第 11 章 JavaScript 标准库","uri":"/posts/ch11/"},{"categories":null,"content":"11.7.1 Formatting Numbers Users around the world expect numbers to be formatted in different ways. Decimal points can be periods or commas. Thousands separators can be commas or periods, and they aren’t used every three digits in all places. Some currencies are divided into hundredths, some into thousandths, and some have no subdivisions. Finally, although the so-called “Arabic numerals” 0 through 9 are used in many languages, this is not universal, and users in some countries will expect to see numbers written using the digits from their own scripts. The Intl.NumberFormat class defines a format() method that takes all of these formatting possibilities into account. The constructor takes two arguments. The first argument specifies the locale that the number should be formatted for and the second is an object that specifies more details about how the number should be formatted. If the first argument is omitted or undefined, then the system locale (which we assume to be the user’s preferred locale) will be used. If the first argument is a string, it specifies a desired locale, such as “en-US” (English as used in the United States), “fr” (French), or “zh-Hans-CN” (Chinese, using the simplified Han writing system, in China). The first argument can also be an array of locale strings, and in this case, Intl.NumberFormat will choose the most specific one that is well supported. The second argument to the Intl.NumberFormat() constructor, if specified, should be an object that defines one or more of the following properties: style Specifies the kind of number formatting that is required. The default is “decimal”. Specify “percent” to format a number as a percentage or specify “currency” to specify a number as an amount of money. currency If style is “currency”, then this property is required to specify the three-letter ISO currency code (such as “USD” for US dollars or “GBP” for British pounds) of the desired currency. currencyDisplay If style is “currency”, then this property specifies how the currency is displayed. The default value “symbol” uses a currency symbol if the currency has one. The value “code” uses the three-letter ISO code, and the value “name” spells out the name of the currency in long form. useGrouping Set this property to false if you do not want numbers to have thousands separators (or their locale-appropriate equivalents). minimumIntegerDigits The minimum number of digits to use to display the integer part of the number. If the number has fewer digits than this, it will be padded on the left with zeros. The default value is 1, but you can use values as high as 21. minimumFractionDigits, maximumFractionDigits These two properties control the formatting of the fractional part of the number. If a number has fewer fractional digits than the minimum, it will be padded with zeros on the right. If it has more than the maximum, then the fractional part will be rounded. Legal values for both properties are between 0 and 20. The default minimum is 0 and the default maximum is 3, except when formatting monetary amounts, when the length of the fractional part varies depending on the specified currency. minimumSignificantDigits, maximumSignificantDigits These properties control the number of significant digits used when formatting a number, making them suitable when formatting scientific data, for example. If specified, these properties override the integer and fractional digit properties listed previously. Legal values are between 1 and 21. Once you have created an Intl.NumberFormat object with the desired locale and options, you use it by passing a number to its format() method, which returns an appropriately formatted string. For example: let euros = Intl.NumberFormat(\"es\", {style: \"currency\", currency: \"EUR\"}); euros.format(10) // =\u003e \"10,00 €\": ten euros, Spanish formatting let pounds = Intl.NumberFormat(\"en\", {style: \"currency\", currency: \"GBP\"}); pounds.format(1000) // =\u003e \"£1,000.00\": One thousand pounds, English formatti","date":"2020-11-02","objectID":"/posts/ch11/:7:1","tags":null,"title":"第 11 章 JavaScript 标准库","uri":"/posts/ch11/"},{"categories":null,"content":"11.7.2 Formatting Dates and Times The Intl.DateTimeFormat class is a lot like the Intl.NumberFormat class. The Intl.DateTimeFormat() constructor takes the same two arguments that Intl.NumberFormat() does: a locale or array of locales and an object of formatting options. And the way you use an Intl.DateTimeFormat instance is by calling its format() method to convert a Date object to a string. As mentioned in §11.4, the Date class defines simple toLocaleDateString() and toLocaleTimeString() methods that produce locale-appropriate output for the user’s locale. But these methods don’t give you any control over what fields of the date and time are displayed. Maybe you want to omit the year but add a weekday to the date format. Do you want the month to be represented numerically or spelled out by name? The Intl.DateTimeFormat class provides fine-grained control over what is output based on the properties in the options object that is passed as the second argument to the constructor. Note, however, that Intl.DateTimeFormat cannot always display exactly what you ask for. If you specify options to format hours and seconds but omit minutes, you’ll find that the formatter displays the minutes anyway. The idea is that you use the options object to specify what date and time fields you’d like to present to the user and how you’d like those formatted (by name or by number, for example), then the formatter will look for a locale-appropriate format that most closely matches what you have asked for. The available options are the following. Only specify properties for date and time fields that you would like to appear in the formatted output. year Use “numeric” for a full, four-digit year or “2-digit” for a two-digit abbreviation. month Use “numeric” for a possibly short number like “1”, or “2-digit” for a numeric representation that always has two digits, like “01”. Use “long” for a full name like “January”, “short” for an abbreviated name like “Jan”, and “narrow” for a highly abbreviated name like “J” that is not guaranteed to be unique. day Use “numeric” for a one- or two-digit number or “2-digit” for a two-digit number for the day-of-month. weekday Use “long” for a full name like “Monday”, “short” for an abbreviated name like “Mon”, and “narrow” for a highly abbreviated name like “M” that is not guaranteed to be unique. era This property specifies whether a date should be formatted with an era, such as CE or BCE. This may be useful if you are formatting dates from very long ago or if you are using a Japanese calendar. Legal values are “long”, “short”, and “narrow”. hour, minute, second These properties specify how you would like time displayed. Use “numeric” for a one- or two-digit field or “2-digit” to force single-digit numbers to be padded on the left with a 0. timeZone This property specifies the desired time zone for which the date should be formatted. If omitted, the local time zone is used. Implementations always recognize “UTC” and may also recognize Internet Assigned Numbers Authority (IANA) time zone names, such as “America/Los_Angeles”. timeZoneName This property specifies how the time zone should be displayed in a formatted date or time. Use “long” for a fully spelled-out time zone name and “short” for an abbreviated or numeric time zone. hour12 This boolean property specifies whether or not to use 12-hour time. The default is locale dependent, but you can override it with this property. hourCycle This property allows you to specify whether midnight is written as 0 hours, 12 hours, or 24 hours. The default is locale dependent, but you can override the default with this property. Note that hour12 takes precedence over this property. Use the value “h11” to specify that midnight is 0 and the hour before midnight is 11pm. Use “h12” to specify that midnight is 12. Use “h23” to specify that midnight is 0 and the hour before midnight is 23. And use “h24” to specify that midnight is 24. Here are some examples: let d = new Date(\"2020-01-","date":"2020-11-02","objectID":"/posts/ch11/:7:2","tags":null,"title":"第 11 章 JavaScript 标准库","uri":"/posts/ch11/"},{"categories":null,"content":"11.7.3 Comparing Strings The problem of sorting strings into alphabetical order (or some more general “collation order” for nonalphabetical scripts) is more challenging than English speakers often realize. English uses a relatively small alphabet with no accented letters, and we have the benefit of a character encoding (ASCII, since incorporated into Unicode) whose numerical values perfectly match our standard string sort order. Things are not so simple in other languages. Spanish, for example treats ñ as a distinct letter that comes after n and before o. Lithuanian alphabetizes Y before J, and Welsh treats digraphs like CH and DD as single letters with CH coming after C and DD sorting after D. If you want to display strings to a user in an order that they will find natural, it is not enough use the sort() method on an array of strings. But if you create an Intl.Collator object, you can pass the compare() method of that object to the sort() method to perform locale-appropriate sorting of the strings. Intl.Collator objects can be configured so that the compare() method performs case-insensitive comparisons or even comparisons that only consider the base letter and ignore accents and other diacritics. Like Intl.NumberFormat() and Intl.DateTimeFormat(), the Intl.Collator() constructor takes two arguments. The first specifies a locale or an array of locales, and the second is an optional object whose properties specify exactly what kind of string comparison is to be done. The supported properties are these: usage This property specifies how the collator object is to be used. The default value is “sort”, but you can also specify “search”. The idea is that, when sorting strings, you typically want a collator that differentiates as many strings as possible to produce a reliable ordering. But when comparing two strings, some locales may want a less strict comparison that ignores accents, for example. sensitivity This property specifies whether the collator is sensitive to letter case and accents when comparing strings. The value “base” causes comparisons that ignore case and accents, considering only the base letter for each character. (Note, however, that some languages consider certain accented characters to be distinct base letters.) “accent” considers accents in comparisons but ignores case. “case” considers case and ignores accents. And “variant” performs strict comparisons that consider both case and accents. The default value for this property is “variant” when usage is “sort”. If usage is “search”, then the default sensitivity depends on the locale. ignorePunctuation Set this property to true to ignore spaces and punctuation when comparing strings. With this property set to true, the strings “any one” and “anyone”, for example, will be considered equal. numeric Set this property to true if the strings you are comparing are integers or contain integers and you want them to be sorted into numerical order instead of alphabetical order. With this option set, the string “Version 9” will be sorted before “Version 10”, for example. caseFirst This property specifies which letter case should come first. If you specify “upper”, then “A” will sort before “a”. And if you specify “lower”, then “a” will sort before “A”. In either case, note that the upper- and lowercase variants of the same letter will be next to one another in sort order, which is different than Unicode lexicographic ordering (the default behavior of the Array sort() method) in which all ASCII uppercase letters come before all ASCII lowercase letters. The default for this property is locale dependent, and implementations may ignore this property and not allow you to override the case sort order. Once you have created an Intl.Collator object for the desired locale and options, you can use its compare() method to compare two strings. This method returns a number. If the returned value is less than zero, then the first string comes before the second string. If it is greater t","date":"2020-11-02","objectID":"/posts/ch11/:7:3","tags":null,"title":"第 11 章 JavaScript 标准库","uri":"/posts/ch11/"},{"categories":null,"content":"11.8 The Console API You’ve seen the console.log() function used throughout this book: in web browsers, it prints a string in the “Console” tab of the browser’s developer tools pane, which can be very helpful when debugging. In Node, console.log() is a general-purpose output function and prints its arguments to the process’s stdout stream, where it typically appears to the user in a terminal window as program output. The Console API defines a number of useful functions in addition to console.log(). The API is not part of any ECMAScript standard, but it is supported by browsers and by Node and has been formally written up and standardized at https://console.spec.whatwg.org. The Console API defines the following functions: console.log() This is the most well-known of the console functions. It converts its arguments to strings and outputs them to the console. It includes spaces between the arguments and starts a new line after outputting all arguments. console.debug(), console.info(), console.warn(), console.error() These functions are almost identical to console.log(). In Node, console.error() sends its output to the stderr stream rather than the stdout stream, but the other functions are aliases of console.log(). In browsers, output messages generated by each of these functions may be prefixed by an icon that indicates its level or severity, and the developer console may also allow developers to filter console messages by level. console.assert() If the first argument is truthy (i.e., if the assertion passes), then this function does nothing. But if the first argument is false or another falsy value, then the remaining arguments are printed as if they had been passed to console.error() with an “Assertion failed” prefix. Note that, unlike typical assert() functions, console.assert() does not throw an exception when an assertion fails. console.clear() This function clears the console when that is possible. This works in browsers and in Node when Node is displaying its output to a terminal. If Node’s output has been redirected to a file or a pipe, however, then calling this function has no effect. console.table() This function is a remarkably powerful but little-known feature for producing tabular output, and it is particularly useful in Node programs that need to produce output that summarizes data. console.table() attempts to display its argument in tabular form (although, if it can’t do that, it displays it using regular console.log() formatting). This works best when the argument is a relatively short array of objects, and all of the objects in the array have the same (relatively small) set of properties. In this case, each object in the array is formatted as a row of the table, and each property is a column of the table. You can also pass an array of property names as an optional second argument to specify the desired set of columns. If you pass an object instead of an array of objects, then the output will be a table with one column for property names and one column for property values. Or, if those property values are themselves objects, their property names will become columns in the table. console.trace() This function logs its arguments like console.log() does, and, in addition, follows its output with a stack trace. In Node, the output goes to stderr instead of stdout. console.count() This function takes a string argument and logs that string, followed by the number of times it has been called with that string. This can be useful when debugging an event handler, for example, if you need to keep track of how many times the event handler has been triggered. console.countReset() This function takes a string argument and resets the counter for that string. console.group() This function prints its arguments to the console as if they had been passed to console.log(), then sets the internal state of the console so that all subsequent console messages (until the next console.groupEnd() call) will be indented relative to the mess","date":"2020-11-02","objectID":"/posts/ch11/:8:0","tags":null,"title":"第 11 章 JavaScript 标准库","uri":"/posts/ch11/"},{"categories":null,"content":"11.8.1 Formatted Output with Console Console functions that print their arguments like console.log() have a little-known feature: if the first argument is a string that includes %s, %i, %d, %f, %o, %O, or %c, then this first argument is treated as format string,6 and the values of subsequent arguments are substituted into the string in place of the two-character % sequences. The meanings of the sequences are as follows: %s The argument is converted to a string. %i and %d The argument is converted to a number and then truncated to an integer. %f The argument is converted to a number %o and %O The argument is treated as an object, and property names and values are displayed. (In web browsers, this display is typically interactive, and users can expand and collapse properties to explore a nested data structure.) %o and %O both display object details. The uppercase variant uses an implementation-dependent output format that is judged to be most useful for software developers. %c In web browsers, the argument is interpreted as a string of CSS styles and used to style any text that follows (until the next %c sequence or the end of the string). In Node, the %c sequence and its corresponding argument are simply ignored. Note that it is not often necessary to use a format string with the console functions: it is usually easy to obtain suitable output by simply passing one or more values (including objects) to the function and allowing the implementation to display them in a useful way. As an example, note that, if you pass an Error object to console.log(), it is automatically printed along with its stack trace. ","date":"2020-11-02","objectID":"/posts/ch11/:8:1","tags":null,"title":"第 11 章 JavaScript 标准库","uri":"/posts/ch11/"},{"categories":null,"content":"11.9 URL APIs Since JavaScript is so commonly used in web browsers and web servers, it is common for JavaScript code to need to manipulate URLs. The URL class parses URLs and also allows modification (adding search parameters or altering paths, for example) of existing URLs. It also properly handles the complicated topic of escaping and unescaping the various components of a URL. The URL class is not part of any ECMAScript standard, but it works in Node and all internet browsers other than Internet Explorer. It is standardized at https://url.spec.whatwg.org. Create a URL object with the URL() constructor, passing an absolute URL string as the argument. Or pass a relative URL as the first argument and the absolute URL that it is relative to as the second argument. Once you have created the URL object, its various properties allow you to query unescaped versions of the various parts of the URL: let url = new URL(\"https://example.com:8000/path/name?q=term#fragment\"); url.href // =\u003e \"https://example.com:8000/path/name?q=term#fragment\" url.origin // =\u003e \"https://example.com:8000\" url.protocol // =\u003e \"https:\" url.host // =\u003e \"example.com:8000\" url.hostname // =\u003e \"example.com\" url.port // =\u003e \"8000\" url.pathname // =\u003e \"/path/name\" url.search // =\u003e \"?q=term\" url.hash // =\u003e \"#fragment\" Although it is not commonly used, URLs can include a username or a username and password, and the URL class can parse these URL components, too: let url = new URL(\"ftp://admin:1337!@ftp.example.com/\"); url.href // =\u003e \"ftp://admin:1337!@ftp.example.com/\" url.origin // =\u003e \"ftp://ftp.example.com\" url.username // =\u003e \"admin\" url.password // =\u003e \"1337!\" The origin property here is a simple combination of the URL protocol and host (including the port if one is specified). As such, it is a read-only property. But each of the other properties demonstrated in the previous example is read/write: you can set any of these properties to set the corresponding part of the URL: let url = new URL(\"https://example.com\"); // Start with our server url.pathname = \"api/search\"; // Add a path to an API endpoint url.search = \"q=test\"; // Add a query parameter url.toString() // =\u003e \"https://example.com/api/search?q=test\" One of the important features of the URL class is that it correctly adds punctuation and escapes special characters in URLs when that is needed: let url = new URL(\"https://example.com\"); url.pathname = \"path with spaces\"; url.search = \"q=foo#bar\"; url.pathname // =\u003e \"/path%20with%20spaces\" url.search // =\u003e \"?q=foo%23bar\" url.href // =\u003e \"https://example.com/path%20with%20spaces?q=foo%23bar\" The href property in these examples is a special one: reading href is equivalent to calling toString(): it reassembles all parts of the URL into the canonical string form of the URL. And setting href to a new string reruns the URL parser on the new string as if you had called the URL() constructor again. In the previous examples, we’ve been using the search property to refer to the entire query portion of a URL, which consists of the characters from a question mark to the end of the URL or to the first hash character. Sometimes, it is sufficient to just treat this as a single URL property. Often, however, HTTP requests encode the values of multiple form fields or multiple API parameters into the query portion of a URL using the application/x-www-form-urlencoded format. In this format, the query portion of the URL is a question mark followed by one or more name/value pairs, which are separated from one another by ampersands. The same name can appear more than once, resulting in a named search parameter with more than one value. If you want to encode these kinds of name/value pairs into the query portion of a URL, then the searchParams property will be more useful than the search property. The search property is a read/write string that lets you get and set the entire query portion of the URL. The searchParams property is a read-only reference to a URLSearchParams object, which has an ","date":"2020-11-02","objectID":"/posts/ch11/:9:0","tags":null,"title":"第 11 章 JavaScript 标准库","uri":"/posts/ch11/"},{"categories":null,"content":"11.9.1 Legacy URL Functions Prior to the definition of the URL API described previously, there have been multiple attempts to support URL escaping and unescaping in the core JavaScript language. The first attempt was the globally defined escape() and unescape() functions, which are now deprecated but still widely implemented. They should not be used. When escape() and unescape() were deprecated, ECMAScript introduced two pairs of alternative global functions: encodeURI() and decodeURI() encodeURI() takes a string as its argument and returns a new string in which non-ASCII characters plus certain ASCII characters (such as space) are escaped. decodeURI() reverses the process. Characters that need to be escaped are first converted to their UTF-8 encoding, then each byte of that encoding is replaced with a %xx escape sequence, where xx is two hexadecimal digits. Because encodeURI() is intended for encoding entire URLs, it does not escape URL separator characters such as /, ?, and #. But this means that encodeURI() cannot work correctly for URLs that have those characters within their various components. encodeURIComponent() and decodeURIComponent() This pair of functions works just like encodeURI() and decodeURI() except that they are intended to escape individual components of a URI, so they also escape characters like /, ?, and # that are used to separate those components. These are the most useful of the legacy URL functions, but be aware that encodeURIComponent() will escape / characters in a path name that you probably do not want escaped. And it will convert spaces in a query parameter to %20, even though spaces are supposed to be escaped with a + in that portion of a URL. The fundamental problem with all of these legacy functions is that they seek to apply a single encoding scheme to all parts of a URL when the fact is that different portions of a URL use different encodings. If you want a properly formatted and encoded URL, the solution is simply to use the URL class for all URL manipulation you do. ","date":"2020-11-02","objectID":"/posts/ch11/:9:1","tags":null,"title":"第 11 章 JavaScript 标准库","uri":"/posts/ch11/"},{"categories":null,"content":"11.10 Timers Since the earliest days of JavaScript, web browsers have defined two functions—setTimeout() and setInterval()—that allow programs to ask the browser to invoke a function after a specified amount of time has elapsed or to invoke the function repeatedly at a specified interval. These functions have never been standardized as part of the core language, but they work in all browsers and in Node and are a de facto part of the JavaScript standard library. The first argument to setTimeout() is a function, and the second argument is a number that specifies how many milliseconds should elapse before the function is invoked. After the specified amount of time (and maybe a little longer if the system is busy), the function will be invoked with no arguments. Here, for example, are three setTimeout() calls that print console messages after one second, two seconds, and three seconds: setTimeout(() =\u003e { console.log(\"Ready...\"); }, 1000); setTimeout(() =\u003e { console.log(\"set...\"); }, 2000); setTimeout(() =\u003e { console.log(\"go!\"); }, 3000); Note that setTimeout() does not wait for the time to elapse before returning. All three lines of code in this example run almost instantly, but then nothing happens until 1,000 milliseconds elapse. If you omit the second argument to setTimeout(), it defaults to 0. That does not mean, however, that the function you specify is invoked immediately. Instead, the function is registered to be called “as soon as possible.” If a browser is particularly busy handling user input or other events, it may take 10 milliseconds or more before the function is invoked. setTimeout() registers a function to be invoked once. Sometimes, that function will itself call setTimeout() to schedule another invocation at a future time. If you want to invoke a function repeatedly, however, it is often simpler to use setInterval(). setInterval() takes the same two arguments as setTimeout() but invokes the function repeatedly every time the specified number of milliseconds (approximately) have elapsed. Both setTimeout() and setInterval() return a value. If you save this value in a variable, you can then use it later to cancel the execution of the function by passing it to clearTimeout() or clearInterval(). The returned value is typically a number in web browsers and is an object in Node. The actual type doesn’t matter, and you should treat it as an opaque value. The only thing you can do with this value is pass it to clearTimeout() to cancel the execution of a function registered with setTimeout() (assuming it hasn’t been invoked yet) or to stop the repeating execution of a function registered with setInterval(). Here is an example that demonstrates the use of setTimeout(), setInterval(), and clearInterval() to display a simple digital clock with the Console API: // Once a second: clear the console and print the current time let clock = setInterval(() =\u003e { console.clear(); console.log(new Date().toLocaleTimeString()); }, 1000); // After 10 seconds: stop the repeating code above. setTimeout(() =\u003e { clearInterval(clock); }, 10000); We’ll see setTimeout() and setInterval() again when we cover asynchronous programming in Chapter 13. ","date":"2020-11-02","objectID":"/posts/ch11/:10:0","tags":null,"title":"第 11 章 JavaScript 标准库","uri":"/posts/ch11/"},{"categories":null,"content":"11.11 Summary Learning a programming language is not just about mastering the grammar. It is equally important to study the standard library so that you are familiar with all the tools that are shipped with the language. This chapter has documented JavaScript’s standard library, which includes: Important data structures, such as Set, Map, and typed arrays. The Date and URL classes for working with dates and URLs. JavaScript’s regular expression grammar and its RegExp class for textual pattern matching. JavaScript’s internationalization library for formatting dates, time, and numbers and for sorting strings. The JSON object for serializing and deserializing simple data structures and the console object for logging messages. This predictable iteration order is another thing about JavaScript sets that Python programmers may find surprising. Typed arrays were first introduced to client-side JavaScript when web browsers added support for WebGL graphics. What is new in ES6 is that they have been elevated to a core language feature. Except within a character class (square brackets), where \\b matches the backspace character. Parsing URLs with regular expressions is not a good idea. See §11.9 for a more robust URL parser. C programmers will recognize many of these character sequences from the printf() function. Not everything documented here is defined by the JavaScript language specification: some of the classes and functions documented here were first implemented in web browsers and then adopted by Node, making them de facto members of the JavaScript standard library. ↩︎ ","date":"2020-11-02","objectID":"/posts/ch11/:11:0","tags":null,"title":"第 11 章 JavaScript 标准库","uri":"/posts/ch11/"},{"categories":null,"content":"Iterable objects and their associated iterators are a feature of ES6 that we’ve seen several times throughout this book. Arrays (including TypedArrays) are iterable, as are strings and Set and Map objects. This means that the contents of these data structures can be iterated—looped over—with the for/of loop, as we saw in §5.4.4: 可迭代对象及其关联的迭代器是 ES6 的一个特性，在本书中我们已经多次看到。数组（包括 typedarray）是可迭代的，字符串、Set 和 Map 对象也是如此。这意味着这些数据结构的内容可以被 for/of 循环遍历，就像我们在 §5.4.4 中看到的那样： let sum = 0; for(let i of [1,2,3]) { // Loop once for each of these values sum += i; } sum // =\u003e 6 Iterators can also be used with the … operator to expand or “spread” an iterable object into an array initializer or function invocation, as we saw in §7.1.2: 迭代器还可以用 … 运算符将可迭代对象展开或“扩展”到数组初始化或函数调用中，如 §7.1.2 所示： let chars = [...\"abcd\"]; // chars == [\"a\", \"b\", \"c\", \"d\"] let data = [1, 2, 3, 4, 5]; Math.max(...data) // =\u003e 5 Iterators can be used with destructuring assignment: 迭代器可以与析构赋值一起使用： let purpleHaze = Uint8Array.of(255, 0, 255, 128); let [r, g, b, a] = purpleHaze; // a == 128 When you iterate a Map object, the returned values are [key, value] pairs, which work well with destructuring assignment in a for/of loop: 当你迭代一个 Map 对象时，返回的值是 [key, value] 对，这在 for/of 循环的解构赋值中很好用： let m = new Map([[\"one\", 1], [\"two\", 2]]); for(let [k,v] of m) console.log(k, v); // Logs 'one 1' and 'two 2' If you want to iterate just the keys or just the values rather than the pairs, you can use the keys() and values() methods: 如果只迭代键或只迭代值而不是一对，可以使用 keys() 和 values() 方法: [...m] // =\u003e [[\"one\", 1], [\"two\", 2]]: default iteration [...m.entries()] // =\u003e [[\"one\", 1], [\"two\", 2]]: entries() method is the same [...m.keys()] // =\u003e [\"one\", \"two\"]: keys() method iterates just map keys [...m.values()] // =\u003e [1, 2]: values() method iterates just map values Finally, a number of built-in functions and constructors that are commonly used with Array objects are actually written (in ES6 and later) to accept arbitrary iterators instead. The Set() constructor is one such API: 最后，通常用于数组对象的许多内置函数和构造函数实际上被编写（在ES6及以后版本中）为接受任意实参的迭代器。Set() 构造函数就是这样一种API： // Strings are iterable, so the two sets are the same: new Set(\"abc\") // =\u003e new Set([\"a\", \"b\", \"c\"]) This chapter explains how iterators work and demonstrates how to create your own data structures that are iterable. After explaining basic iterators, this chapter covers generators, a powerful new feature of ES6 that is primarily used as a particularly easy way to create iterators. 本章说明了迭代器是如何工作的，并演示了如何创建自己的可迭代的数据结构。在说明了基本的迭代器之后，本章将介绍生成器，这是 ES6 的一个强大的新特性，它是一种特别简单的方法创建迭代器。 ","date":"2020-11-02","objectID":"/posts/ch12/:0:0","tags":null,"title":"第 12 章 迭代器和生成器","uri":"/posts/ch12/"},{"categories":null,"content":"12.1 How Iterators Work The for/of loop and spread operator work seamlessly with iterable objects, but it is worth understanding what is actually happening to make the iteration work. There are three separate types that you need to understand to understand iteration in JavaScript. First, there are the iterable objects: these are types like Array, Set, and Map that can be iterated. Second, there is the iterator object itself, which performs the iteration. And third, there is the iteration result object that holds the result of each step of the iteration. for/of 循环和展开运算符可与可迭代对象无缝配合，但是值得了解使迭代工作的实际情况。需要了解三种独立的类型才能理解 JavaScript 中的迭代。首先，可迭代的对象：可以迭代的是诸如 Array，Set 和 Map 之类的类型。其次，迭代器对象本身，它执行迭代。第三，一个迭代结果对象，该对象保存迭代的每个步骤的结果。 An iterable object is any object with a special iterator method that returns an iterator object. An iterator is any object with a next() method that returns an iteration result object. And an iteration result object is an object with properties named value and done. To iterate an iterable object, you first call its iterator method to get an iterator object. Then, you call the next() method of the iterator object repeatedly until the returned value has its done property set to true. The tricky thing about this is that the iterator method of an iterable object does not have a conventional name but uses the Symbol Symbol.iterator as its name. So a simple for/of loop over an iterable object iterable could also be written the hard way, like this: 任何对象具有特殊迭代器方法，并且该方法返回迭代器对象，那么该对象为可迭代对象。迭代器对象具有 next() 方法，该方法返回迭代结果对象。迭代结果对象是具有名为 value 和 done 的属性的对象。要迭代一个可迭代的对象，首先要调用其迭代器方法以获取一个迭代器对象。然后，重复调用迭代器对象的 next() 方法，直到返回的值的 done 属性设置为 true。棘手的事情是，可迭代对象的迭代器方法没有常规名称，而是使用 Symbol Symbol.iterator 作为其名称。因此，也可以用很复杂的方式编写可迭代对象的简单 for/of 循环，如下所示： let iterable = [99]; let iterator = iterable[Symbol.iterator](); for(let result = iterator.next(); !result.done; result = iterator.next()) { console.log(result.value) // result.value == 99 } The iterator object of the built-in iterable datatypes is itself iterable. (That is, it has a method named Symbol.iterator that just returns itself.) This is occasionally useful in code like the following when you want to iterate though a “partially used” iterator: 内置可迭代数据类型的迭代器对象本身是可迭代的。（也就是说，它具有一个名为 Symbol.iterator 的方法，该方法会自行返回。）当要通过“部分使用”的迭代器进行迭代时，以下代码中有时会很有用： let list = [1,2,3,4,5]; let iter = list[Symbol.iterator](); let head = iter.next().value; // head == 1 let tail = [...iter]; // tail == [2,3,4,5] ","date":"2020-11-02","objectID":"/posts/ch12/:1:0","tags":null,"title":"第 12 章 迭代器和生成器","uri":"/posts/ch12/"},{"categories":null,"content":"12.2 Implementing Iterable Objects Iterable objects are so useful in ES6 that you should consider making your own datatypes iterable whenever they represent something that can be iterated. The Range classes shown in Examples 9-2 and 9-3 in Chapter 9 were iterable. Those classes used generator functions to make themselves iterable. We’ll document generators later in this chapter, but first, we will implement the Range class one more time, making it iterable without relying on a generator. 可迭代对象在 ES6 中非常有用，应该考虑使自己的数据类型在可以表示迭代的任何时候都可迭代。第 9 章示例 9-2 和 9-3 中显示的 Range 类是可迭代的。这些类使用生成器函数使其可迭代。我们将在本章稍后介绍生成器，但首先，我们将再次实现 Range 类，使其无需依赖生成器即可迭代。 In order to make a class iterable, you must implement a method whose name is the Symbol Symbol.iterator. That method must return an iterator object that has a next() method. And the next() method must return an iteration result object that has a value property and/or a boolean done property. Example 12-1 implements an iterable Range class and demonstrates how to create iterable, iterator, and iteration result objects. 为了使类可迭代，必须实现一个名称为 Symbol Symbol.iterator 的方法。该方法必须返回一个具有 next() 方法的迭代器对象。并且 next() 方法必须返回具有 value 属性和或或布尔型 done 属性的迭代结果对象。示例 12-1 实现了一个可迭代的 Range 类，并演示了如何创建可迭代的、迭代器和迭代结果对象。 Example 12-1. An iterable numeric Range class 示例 12-1 一个可迭代数值范围类 /* * A Range object represents a range of numbers {x: from \u003c= x \u003c= to} * Range defines a has() method for testing whether a given number is a member * of the range. Range is iterable and iterates all integers within the range. */ class Range { constructor (from, to) { this.from = from; this.to = to; } // Make a Range act like a Set of numbers has(x) { return typeof x === \"number\" \u0026\u0026 this.from \u003c= x \u0026\u0026 x \u003c= this.to; } // Return string representation of the range using set notation toString() { return `{ x | ${this.from}≤ x ≤ ${this.to}}`; } // Make a Range iterable by returning an iterator object. // Note that the name of this method is a special symbol, not a string. [Symbol.iterator]() { // Each iterator instance must iterate the range independently of // others. So we need a state variable to track our location in the // iteration. We start at the first integer \u003e= from. let next = Math.ceil(this.from); // This is the next value we return let last = this.to; // We won't return anything \u003e this return { // This is the iterator object // This next() method is what makes this an iterator object. // It must return an iterator result object. next() { return (next \u003c= last) // If we haven't returned last value yet ? { value: next++ } // return next value and increment it : { done: true }; // otherwise indicate that we're done. }, // As a convenience, we make the iterator itself iterable. [Symbol.iterator]() { return this; } }; } } for(let x of new Range(1,10)) console.log(x); // Logs numbers 1 to 10 [...new Range(-2,2)] // =\u003e [-2, -1, 0, 1, 2] In addition to making your classes iterable, it can be quite useful to define functions that return iterable values. Consider these iterable-based alternatives to the map() and filter() methods of JavaScript arrays: 除了使类可迭代外，定义返回可迭代值的函数也非常有用。考虑 JavaScript 数组的 map() 和 filter() 方法的这些基于迭代的替代方法： // Return an iterable object that iterates the result of applying f() // to each value from the source iterable function map(iterable, f) { let iterator = iterable[Symbol.iterator](); return { // This object is both iterator and iterable [Symbol.iterator]() { return this; }, next() { let v = iterator.next(); if (v.done) { return v; } else { return { value: f(v.value) }; } } }; } // Map a range of integers to their squares and convert to an array [...map(new Range(1,4), x =\u003e x*x)] // =\u003e [1, 4, 9, 16] // Return an iterable object that filters the specified iterable, // iterating only those elements for which the predicate returns true function filter(iterable, predicate) { let iterator = iterable[Symbol.iterator](); return { // This object is both iterator and iterable [Symbol.iterator]() { return this; }, next() { for(;;) { let v = it","date":"2020-11-02","objectID":"/posts/ch12/:2:0","tags":null,"title":"第 12 章 迭代器和生成器","uri":"/posts/ch12/"},{"categories":null,"content":"12.2.1 “Closing” an Iterator: The Return Method Imagine a (server-side) JavaScript variant of the words() iterator that, instead of taking a source string as its argument, takes the name of a file, opens the file, reads lines from it, and iterates the words from those lines. In most operating systems, programs that open files to read from them need to remember to close those files when they are done reading, so this hypothetical iterator would be sure to close the file after the next() method returns the last word in it. 想象一下 words() 迭代器的（服务器端）JavaScript 变体，它不用源字符串作为实参，而是使用文件名，打开文件，从文件中读取行，然后从这些行中迭代单词。在大多数操作系统中，打开文件以从其中读取文件的程序需要记住在完成读取后关闭这些文件，因此，这个假设的迭代器将确保在 next() 方法返回文件中的最后一个字之后关闭文件。 But iterators don’t always run all the way to the end: a for/of loop might be terminated with a break or return or by an exception. Similarly, when an iterator is used with destructuring assignment, the next() method is only called enough times to obtain values for each of the specified variables. The iterator may have many more values it could return, but they will never be requested. 但是迭代器并不总是一直运行到最后：for/of 循环可能会因中断或返回或异常而终止。同样，当迭代器用于解构赋值时，仅调用 next() 方法足够多次，以获取每个指定变量的值。迭代器可能有更多可能返回的值，但是它们永远不会被请求。 If our hypothetical words-in-a-file iterator never runs all the way to the end, it still needs to close the file it opened. For this reason, iterator objects may implement a return() method to go along with the next() method. If iteration stops before next() has returned an iteration result with the done property set to true (most commonly because you left a for/of loop early via a break statement), then the interpreter will check to see if the iterator object has a return() method. If this method exists, the interpreter will invoke it with no arguments, giving the iterator the chance to close files, release memory, and otherwise clean up after itself. The return() method must return an iterator result object. The properties of the object are ignored, but it is an error to return a non-object value. 如果我们假设的文件中单词迭代器从未一直运行到最后，它仍然需要关闭它打开的文件。因此，迭代器对象可以实现 return() 方法与 next() 方法一起使用。如果迭代在 next() 返回完了属性设置为 true 的迭代结果之前停止（通常是因为通过 break 语句提前离开了 for/of 循环），则解释器将检查迭代器对象是否具有 return() 方法。如果存在此方法，则解释器将不带任何参数调用它，从而使迭代器有机会关闭文件，释放内存以及自行清理。return() 方法必须返回迭代器结果对象。对象的属性被忽略，但是返回非对象值是错误的。 The for/of loop and the spread operator are really useful features of JavaScript, so when you are creating APIs, it is a good idea to use them when possible. But having to work with an iterable object, its iterator object, and the iterator’s result objects makes the process somewhat complicated. Fortunately, generators can dramatically simplify the creation of custom iterators, as we’ll see in the rest of this chapter. for/of 循环和展开运算符是 JavaScript 真正实用功能，因此在创建 API 时，最好在尽可能的使用它们。但是必须使用一个可迭代的对象，其迭代器对象以及迭代器的结果对象，这会使过程变得有些复杂。幸运的是，生成器可以极大地简化自定义迭代器的创建，这将在本章的其余部分中看到。 ","date":"2020-11-02","objectID":"/posts/ch12/:2:1","tags":null,"title":"第 12 章 迭代器和生成器","uri":"/posts/ch12/"},{"categories":null,"content":"12.3 Generators A generator is a kind of iterator defined with powerful new ES6 syntax; it’s particularly useful when the values to be iterated are not the elements of a data structure, but the result of a computation. 生成器是一种使用强大的新 ES6 语法定义的迭代器；当要迭代的值不是数据结构的元素而是计算结果时，此功能特别有用。 To create a generator, you must first define a generator function. A generator function is syntactically like a regular JavaScript function but is defined with the keyword function* rather than function. (Technically, this is not a new keyword, just a * after the keyword function and before the function name.) When you invoke a generator function, it does not actually execute the function body, but instead returns a generator object. This generator object is an iterator. Calling its next() method causes the body of the generator function to run from the start (or whatever its current position is) until it reaches a yield statement. yield is new in ES6 and is something like a return statement. The value of the yield statement becomes the value returned by the next() call on the iterator. An example makes this clearer: 要创建生成器，必须首先定义一个生成器函数。生成器函数在语法上类似于常规 JavaScript 函数，但使用关键字 function* 而不是 function 定义。（从技术上讲，这不是新关键字，只是关键字 function 之后和函数名称之前的 *。）调用生成器函数时，它实际上并不执行函数主体，而是返回生成器对象。该生成器对象是一个迭代器。调用其 next() 方法会使生成器函数的主体从头开始运行（或无论其当前位置是什么），直到到达 yield 语句为止。yield 是 ES6 新特性，类似于 return 语句。yield 语句的值成为迭代器上 next() 调用返回的值。一个示例使这更加清楚： // A generator function that yields the set of one digit (base-10) primes. function* oneDigitPrimes() { // Invoking this function does not run the code yield 2; // but just returns a generator object. Calling yield 3; // the next() method of that generator runs yield 5; // the code until a yield statement provides yield 7; // the return value for the next() method. } // When we invoke the generator function, we get a generator let primes = oneDigitPrimes(); // A generator is an iterator object that iterates the yielded values primes.next().value // =\u003e 2 primes.next().value // =\u003e 3 primes.next().value // =\u003e 5 primes.next().value // =\u003e 7 primes.next().done // =\u003e true // Generators have a Symbol.iterator method to make them iterable primes[Symbol.iterator]() // =\u003e primes // We can use generators like other iterable types [...oneDigitPrimes()] // =\u003e [2,3,5,7] let sum = 0; for(let prime of oneDigitPrimes()) sum += prime; sum // =\u003e 17 In this example, we used a function* statement to define a generator. Like regular functions, however, we can also define generators in expression form. Once again, we just put an asterisk after the function keyword: 在此示例中，我们使用 function* 语句定义了生成器。但是，像常规函数一样，我们也可以在 from 表达式中定义生成器。再一次，我们只在 function 关键字之后加上一个星号： const seq = function*(from,to) { for(let i = from; i \u003c= to; i++) yield i; }; [...seq(3,5)] // =\u003e [3, 4, 5] In classes and object literals, we can use shorthand notation to omit the function keyword entirely when we define methods. To define a generator in this context, we simply use an asterisk before the method name where the function keyword would have been, had we used it: 在类和对象文字中，我们在定义方法时可以使用速记标记来完全省略 function 关键字。要在这种情况下定义生成器，我们只需在方法名称之前使用星号即可： let o = { x: 1, y: 2, z: 3, // A generator that yields each of the keys of this object *g() { for(let key of Object.keys(this)) { yield key; } } }; [...o.g()] // =\u003e [\"x\", \"y\", \"z\", \"g\"] Note that there is no way to write a generator function using arrow function syntax. 请注意，无法使用箭头函数语法编写生成器函数。 Generators often make it particularly easy to define iterable classes. We can replace the [Symbol.iterator]() method show in Example 12-1 with a much shorter *[Symbol.iterator]() generator function that looks like this: 生成器通常使定义可迭代类特别容易。我们可以用更短的 *[Symbol.iterator];() 生成器函数代替示例 12-1 中的 [Symbol.iterator]() 方法，如下所示： *[Symbol.iterator]() { for(let x = Math.ceil(this.from); x \u003c= this.to; x++) yield x; } See Example 9-3 in Chapter 9 to see this generator-based iterator function in context. 请参阅第 9 章中的示例 9-3，可以看到在上下文中看到此基于生成器的迭代器函数。 ","date":"2020-11-02","objectID":"/posts/ch12/:3:0","tags":null,"title":"第 12 章 迭代器和生成器","uri":"/posts/ch12/"},{"categories":null,"content":"12.3.1 Generator Examples Generators are more interesting if they actually generate the values they yield by doing some kind of computation. Here, for example, is a generator function that yields Fibonacci numbers: 如果生成器实际上通过执行某种计算来生成它们产生的值，则它们会更有趣。例如，这里是生成斐波那契数的生成器函数： function* fibonacciSequence() { let x = 0, y = 1; for(;;) { yield y; [x, y] = [y, x+y]; // Note: destructuring assignment } } Note that the fibonacciSequence() generator function here has an infinite loop and yields values forever without returning. If this generator is used with the … spread operator, it will loop until memory is exhausted and the program crashes. With care, it is possible to use it in a for/of loop, however: 请注意，此处的 fibonacciSequence() 生成器函数具有无限循环，并且永久产生值而不会返回。如果将此生成器与 … 展开运算符一起使用，它将循环播放直到内存耗尽且程序崩溃。小心地在 for/of 循环中使用它： // Return the nth Fibonacci number function fibonacci(n) { for(let f of fibonacciSequence()) { if (n-- \u003c= 0) return f; } } fibonacci(20) // =\u003e 10946 This kind of infinite generator becomes more useful with a take() generator like this: 这种无限生成器在使用 take() 生成器时变得更加有用，如下所示： // Yield the first n elements of the specified iterable object function* take(n, iterable) { let it = iterable[Symbol.iterator](); // Get iterator for iterable object while(n-- \u003e 0) { // Loop n times: let next = it.next(); // Get the next item from the iterator. if (next.done) return; // If there are no more values, return early else yield next.value; // otherwise, yield the value } } // An array of the first 5 Fibonacci numbers [...take(5, fibonacciSequence())] // =\u003e [1, 1, 2, 3, 5] Here is another useful generator function that interleaves the elements of multiple iterable objects: 这是另一个有用的生成器函数，它交错多个可迭代对象的元素： // Given an array of iterables, yield their elements in interleaved order. function* zip(...iterables) { // Get an iterator for each iterable let iterators = iterables.map(i =\u003e i[Symbol.iterator]()); let index = 0; while(iterators.length \u003e 0) { // While there are still some iterators if (index \u003e= iterators.length) { // If we reached the last iterator index = 0; // go back to the first one. } let item = iterators[index].next(); // Get next item from next iterator. if (item.done) { // If that iterator is done iterators.splice(index, 1); // then remove it from the array. } else { // Otherwise, yield item.value; // yield the iterated value index++; // and move on to the next iterator. } } } // Interleave three iterable objects [...zip(oneDigitPrimes(),\"ab\",[0])] // =\u003e [2,\"a\",0,3,\"b\",5,7] ","date":"2020-11-02","objectID":"/posts/ch12/:3:1","tags":null,"title":"第 12 章 迭代器和生成器","uri":"/posts/ch12/"},{"categories":null,"content":"12.3.2 yield* and Recursive Generators In addition to the zip() generator defined in the preceding example, it might be useful to have a similar generator function that yields the elements of multiple iterable objects sequentially rather than interleaving them. We could write that generator like this: 除了前面示例中定义的 zip() 生成器之外，具有类似的生成器功能可能会很有用，该功能可以按顺序生成多个可迭代对象的元素，而不是交织它们。我们可以这样编写生成器： function* sequence(...iterables) { for(let iterable of iterables) { for(let item of iterable) { yield item; } } } [...sequence(\"abc\",oneDigitPrimes())] // =\u003e [\"a\",\"b\",\"c\",2,3,5,7] This process of yielding the elements of some other iterable object is common enough in generator functions that ES6 has special syntax for it. The yield* keyword is like yield except that, rather than yielding a single value, it iterates an iterable object and yields each of the resulting values. The sequence() generator function that we’ve used can be simplified with yield* like this: 这种生成其他可迭代对象的元素的过程在生成器函数中已经足够普遍，以至于为它 ES6 具有特殊的语法。yield* 关键字类似于 yield，除了它不产生单个值，而是迭代一个可迭代的对象并产生每个结果值。我们使用的 sequence() 生成器函数可以通过 yield* 进行简化，如下所示： function* sequence(...iterables) { for(let iterable of iterables) { yield* iterable; } } [...sequence(\"abc\",oneDigitPrimes())] // =\u003e [\"a\",\"b\",\"c\",2,3,5,7] The array forEach() method is often an elegant way to loop over the elements of an array, so you might be tempted to write the sequence() function like this: 数组 forEach() 方法通常是一种循环遍历数组元素的好方法，因此可能会很想像这样编写 sequence() 函数： function* sequence(...iterables) { iterables.forEach(iterable =\u003e yield* iterable ); // Error } This does not work, however. yield and yield* can only be used within generator functions, but the nested arrow function in this code is a regular function, not a function* generator function, so yield is not allowed. 但是，这不起作用。yield 和 yield* 只能在生成器函数中使用，但是此代码中的嵌套箭头函数是常规函数，而不是 function* 生成器函数，因此不允许 yield。 yield* can be used with any kind of iterable object, including iterables implemented with generators. This means that yield* allows us to define recursive generators, and you might use this feature to allow simple non-recursive iteration over a recursively defined tree structure, for example. yield* 可用于任何种类的可迭代对象，包括使用生成器实现的可迭代对象。这意味着 yield* 允许我们定义递归生成器，例如，可以使用此功能在递归定义的树结构上进行简单的非递归迭代。 ","date":"2020-11-02","objectID":"/posts/ch12/:3:2","tags":null,"title":"第 12 章 迭代器和生成器","uri":"/posts/ch12/"},{"categories":null,"content":"12.4 Advanced Generator Features The most common use of generator functions is to create iterators, but the fundamental feature of generators is that they allow us to pause a computation, yield intermediate results, and then resume the computation later. This means that generators have features beyond those of iterators, and we explore those features in the following sections. 生成器函数最常见的用途是创建迭代器，但是生成器的基本特性是它们允许我们暂停计算，产生中间结果，然后在以后恢复计算。这意味着生成器具有的功能超出了迭代器的功能，我们将在以下各节中探讨这些功能。 ","date":"2020-11-02","objectID":"/posts/ch12/:4:0","tags":null,"title":"第 12 章 迭代器和生成器","uri":"/posts/ch12/"},{"categories":null,"content":"12.4.1 The Return Value of a Generator Function The generator functions we’ve seen so far have not had return statements, or if they have, they have been used to cause an early return, not to return a value. Like any function, though, a generator function can return a value. In order to understand what happens in this case, recall how iteration works. The return value of the next() function is an object that has a value property and/or a done property. With typical iterators and generators, if the value property is defined, then the done property is undefined or is false. And if done is true, then value is undefined. But in the case of a generator that returns a value, the final call to next returns an object that has both value and done defined. The value property holds the return value of the generator function, and the done property is true, indicating that there are no more values to iterate. This final value is ignored by the for/of loop and by the spread operator, but it is available to code that manually iterates with explicit calls to next(): 到目前为止，我们看到的生成器函数还没有 return 语句，或者，如果有的话，它们只是被用来引起较早的返回，而不是产生返回值。但是，像任何函数一样，生成器函数可以返回一个值。为了了解在这种情况下会发生什么，请回忆一下迭代是如何工作的。next() 函数的返回值是一个具有 value 属性和或或 done 属性的对象。对于典型的迭代器和生成器，如果定义了 value 属性，则 done 属性是 undefined 或为 false。如果 done 为 true，那么值就是 undefined。但是，如果生成器返回一个值，则对 next 的最终调用将返回一个同时具有 value ​​和 done 定义的对象。 value 属性保存生成器函数的返回值，并且 done 属性为 true，表示没有更多的值可以迭代。最终值将被 for/of 循环和展开运算符忽略，但可用通过对 next() 的显式调用手动进行迭代： function *oneAndDone() { yield 1; return \"done\"; } // The return value does not appear in normal iteration. [...oneAndDone()] // =\u003e [1] // But it is available if you explicitly call next() let generator = oneAndDone(); generator.next() // =\u003e { value: 1, done: false} generator.next() // =\u003e { value: \"done\", done: true } // If the generator is already done, the return value is not returned again generator.next() // =\u003e { value: undefined, done: true } ","date":"2020-11-02","objectID":"/posts/ch12/:4:1","tags":null,"title":"第 12 章 迭代器和生成器","uri":"/posts/ch12/"},{"categories":null,"content":"12.4.2 The Value of a yield Expression In the preceding discussion, we’ve treated yield as a statement that takes a value but has no value of its own. In fact, however, yield is an expression, and it can have a value. 在前面的讨论中，我们将 yield 视为带有值但没有自身值的语句。但是，实际上，yield 是一个表达式，可以有一个值。 When the next() method of a generator is invoked, the generator function runs until it reaches a yield expression. The expression that follows the yield keyword is evaluated, and that value becomes the return value of the next() invocation. At this point, the generator function stops executing right in the middle of evaluating the yield expression. The next time the next() method of the generator is called, the argument passed to next() becomes the value of the yield expression that was paused. So the generator returns values to its caller with yield, and the caller passes values in to the generator with next(). The generator and caller are two separate streams of execution passing values (and control) back and forth. The following code illustrates: 调用生成器的 next() 方法时，生成器函数将运行直至到达 yield 表达式。将评估 yield 关键字之后的表达式，该值将成为 next() 调用的返回值。此时，生成器函数在评估 yield 表达式的中间立即停止执行。下次调用生成器的 next() 方法时，传递给 next() 的参数成为已暂停的 yield 表达式的值。因此，生成器将把 yield 的值返回给它的调用者，然后调用者通过 next() 将值传递给生成器。生成器和调用者是两个独立的执行流，来回传递值（和控制）。以下代码说明： function* smallNumbers() { console.log(\"next() invoked the first time; argument discarded\"); let y1 = yield 1; // y1 == \"b\" console.log(\"next() invoked a second time with argument\", y1); let y2 = yield 2; // y2 == \"c\" console.log(\"next() invoked a third time with argument\", y2); let y3 = yield 3; // y3 == \"d\" console.log(\"next() invoked a fourth time with argument\", y3); return 4; } let g = smallNumbers(); console.log(\"generator created; no code runs yet\"); let n1 = g.next(\"a\"); // n1.value == 1 console.log(\"generator yielded\", n1.value); let n2 = g.next(\"b\"); // n2.value == 2 console.log(\"generator yielded\", n2.value); let n3 = g.next(\"c\"); // n3.value == 3 console.log(\"generator yielded\", n3.value); let n4 = g.next(\"d\"); // n4 == { value: 4, done: true } console.log(\"generator returned\", n4.value); When this code runs, it produces the following output that demonstrates the back-and-forth between the two blocks of code: 此代码运行时，将产生以下输出，演示两个代码块之间的来回交互： generator created; no code runs yet next() invoked the first time; argument discarded generator yielded 1 next() invoked a second time with argument b generator yielded 2 next() invoked a third time with argument c generator yielded 3 next() invoked a fourth time with argument d generator returned 4 Note the asymmetry in this code. The first invocation of next() starts the generator, but the value passed to that invocation is not accessible to the generator. 注意此代码中的不对称性。next() 的首次调用将启动生成器，但是生成器无法访问传递给该调用的值。 ","date":"2020-11-02","objectID":"/posts/ch12/:4:2","tags":null,"title":"第 12 章 迭代器和生成器","uri":"/posts/ch12/"},{"categories":null,"content":"12.4.3 The return() and throw() Methods of a Generator We’ve seen that you can receive values yielded by or returned by a generator function. And you can pass values to a running generator by passing those values when you call the next() method of the generator. 我们已经看到可以接收生成器函数产生或返回的值。可以在调用生成器的 next() 方法时将值传递给正在运行的生成器。 In addition to providing input to a generator with next(), you can also alter the flow of control inside the generator by calling its return() and throw() methods. As the names suggest, calling these methods on a generator causes it to return a value or throw an exception as if the next statement in the generator was a return or throw. 除了使用 next() 向生成器提供输入之外，还可以通过调用生成器的 return() 和 throw() 方法来更改生成器内部的控制流。顾名思义，在生成器上调用这些方法会导致其返回值或引发异常，就像生成器中的下一条语句是 return 或 throw 一样。 Recall from earlier in the chapter that, if an iterator defines a return() method and iteration stops early, then the interpreter automatically calls the return() method to give the iterator a chance to close files or do other cleanup. In the case of generators, you can’t define a custom return() method to handle cleanup, but you can structure the generator code to use a try/finally statement that ensures the necessary cleanup is done (in the finally block) when the generator returns. By forcing the generator to return, the generator’s built-in return() method ensures that the cleanup code is run when the generator will no longer be used. 从本章前面的内容回想起，如果迭代器定义了 return() 方法且迭代提早停止，则解释器将自动调用 return() 方法，以使迭代器有机会关闭文件或进行其他清理。对于生成器，不能定义自定义的 return() 方法来处理清理，但是可以构造生成器代码以使用 try/finally 语句，以确保生成器返回时执行清理操作（在 finally 块中）。通过强制生成器返回，生成器的内置 return() 方法可确保在不再使用生成器时运行清除代码。 Just as the next() method of a generator allows us to pass arbitrary values into a running generator, the throw() method of a generator gives us a way to send arbitrary signals (in the form of exceptions) into a generator. Calling the throw() method always causes an exception inside the generator. But if the generator function is written with appropriate exception-handling code, the exception need not be fatal but can instead be a means of altering the behavior of the generator. Imagine, for example, a counter generator that yields an ever-increasing sequence of integers. This could be written so that an exception sent with throw() would reset the counter to zero. 正如生成器的 next() 方法允许我们将任意值传递给正在运行的生成器一样，生成器的 throw() 方法为我们提供了一种将任意信号（以异常形式）发送到生成器的方法。调用 throw() 方法总是会在生成器内部引起异常。但是，如果生成器函数有适当的异常处理代码编，则该异常是致命的，不过这可以用作更改生成器行为的一种手段。例如，想象一下产生一个不断增加的整数序列的计数器生成器。可以这样编写，使用 throw() 发送的异常将计数器重置为零。 When a generator uses yield* to yield values from some other iterable object, then a call to the next() method of the generator causes a call to the next() method of the iterable object. The same is true of the return() and throw() methods. If a generator uses yield* on an iterable object that has these methods defined, then calling return() or throw() on the generator causes the iterator’s return() or throw() method to be called in turn. All iterators must have a next() method. Iterators that need to clean up after incomplete iteration should define a return() method. And any iterator may define a throw() method, though I don’t know of any practical reason to do so. 当生成器使用 yield* 从其他可迭代对象生成值时，对生成器的 next() 方法的调用会导致对可迭代对象的 next() 方法的调用。return() 和 throw() 方法也是如此。 如果生成器在定义了这些方法的可迭代对象上使用 yield*，则在生成器上调用 return() 或 throw() 会导致依次调用迭代器的 return() 或 throw() 方法。所有迭代器都必须具有 next() 方法。需要在不完整的迭代后进行清理的迭代器应定义一个 return() 方法。而且，任何迭代器都可以定义 throw() 方法，尽管我不知道有任何实际原因。 ","date":"2020-11-02","objectID":"/posts/ch12/:4:3","tags":null,"title":"第 12 章 迭代器和生成器","uri":"/posts/ch12/"},{"categories":null,"content":"12.4.4 A Final Note About Generators Generators are a very powerful generalized control structure. They give us the ability to pause a computation with yield and restart it again at some arbitrary later time with an arbitrary input value. It is possible to use generators to create a kind of cooperative threading system within single-threaded JavaScript code. And it is possible to use generators to mask asynchronous parts of your program so that your code appears sequential and synchronous, even though some of your function calls are actually asynchronous and depend on events from the network. 生成器是一个非常强大的通用控制结构。它们使我们能够使用 yield 暂停计算，并在以后任意任意时间使用任意输入值重新开始计算。可以使用生成器在单线程 JavaScript 代码中创建一种协作线程系统。而且，即使某些函数调用实际上是异步的并且依赖于网络事件，也可以使用生成器来掩盖程序的异步部分，从而使代码显得顺序和同步。 Trying to do these things with generators leads to code that is mind-bendingly hard to understand or to explain. It has been done, however, and the only really practical use case has been for managing asynchronous code. JavaScript now has async and await keywords (see Chapter 13) for this very purpose, however, and there is no longer any reason to abuse generators in this way. 尝试使用生成器执行这些操作会导致代码难以理解或解释。但是，它已经成为了过去时，唯一真正实用的用例是管理异步代码。为此，JavaScript 现在具有 async 和 await 关键字（请参阅第 13 章），并且不再有任何理由以这种方式滥用生成器。 ","date":"2020-11-02","objectID":"/posts/ch12/:4:4","tags":null,"title":"第 12 章 迭代器和生成器","uri":"/posts/ch12/"},{"categories":null,"content":"12.5 Summary In this chapter, you have learned: 在本章中，您学习了： The for/of loop and the … spread operator work with iterable objects. for/of 循环和 … 展开运算符可迭代对象。 An object is iterable if it has a method with the symbolic name [Symbol.iterator] that returns an iterator object. 如果对象具有符号名称为 [Symbol.iterator] 的方法，则该方法返回迭代器对象，该对象是可迭代的。 An iterator object has a next() method that returns an iteration result object. 迭代器对象具有 next() 方法，该方法返回迭代结果对象。 An iteration result object has a value property that holds the next iterated value, if there is one. If the iteration has completed, then the result object must have a done property set to true. 迭代结果对象具有一个 value 属性，该属性保存下一个迭代值（如果有）。如果迭代已完成，则结果对象必须将 done 属性设置为 true。 You can implement your own iterable objects by defining a [Symbol.iterator]() method that returns an object with a next() method that returns iteration result objects. You can also implement functions that accept iterator arguments and return iterator values. 可以通过定义返回对象的 [Symbol.iterator]() 方法和返回迭代结果对象的 next() 方法来实现自己的可迭代对象。还可以实现接受迭代器参数并返回迭代器值的函数。 Generator functions (functions defined with function* instead of function) are another way to define iterators. 生成器函数（用 function* 代替 function 定义的函数）是定义迭代器的另一种方法。 When you invoke a generator function, the body of the function does not run right away; instead, the return value is an iterable iterator object. Each time the next() method of the iterator is called, another chunk of the generator function runs. 当调用生成器函数时，该函数的主体不会立即运行。相反，返回值是一个可迭代的迭代器对象。每次调用迭代器的 next() 方法时，都会运行另一部分生成器函数。 Generator functions can use the yield operator to specify the values that are returned by the iterator. Each call to next() causes the generator function to run up to the next yield expression. The value of that yield expression then becomes the value returned by the iterator. When there are no more yield expressions, then the generator function returns, and the iteration is complete. 生成器函数可以使用 yield 运算符来指定迭代器返回的值。每次调用 next() 都会使生成器函数运行到下一个 yield 表达式。然后，该 yield 表达式的值将成为迭代器返回的值。当没有更多的 yield 表达式时，生成器函数将返回，并且迭代完成。 ","date":"2020-11-02","objectID":"/posts/ch12/:5:0","tags":null,"title":"第 12 章 迭代器和生成器","uri":"/posts/ch12/"},{"categories":null,"content":"Some computer programs, such as scientific simulations and machine learning models, are compute-bound: they run continuously, without pause, until they have computed their result. Most real-world computer programs, however, are significantly asynchronous. This means that they often have to stop computing while waiting for data to arrive or for some event to occur. JavaScript programs in a web browser are typically event-driven, meaning that they wait for the user to click or tap before they actually do anything. And JavaScript-based servers typically wait for client requests to arrive over the network before they do anything. 一些计算机程序，如科学模拟和机器学习模型，是计算受限的：它们不停地运行，没有停顿，直到计算出结果。然而，值得注意的是现实世界中的大多数计算机程序都是异步的。这意味着在等待数据到达或某些事件发生时，它们常常不得不停止计算。web 浏览器中的 JavaScript 程序是典型地事件驱动的，这意味着它们在实际执行任何操作之前等待用户单击或点击。基于 javascript 的服务器通常在执行任何操作之前等待客户机请求通过网络到达。 This kind of asynchronous programming is commonplace in JavaScript, and this chapter documents three important language features that help make it easier to work with asynchronous code. Promises, new in ES6, are objects that represent the not-yet-available result of an asynchronous operation. The keywords async and await were introduced in ES2017 and provide new syntax that simplifies asynchronous programming by allowing you to structure your Promise-based code as if it was synchronous. Finally, asynchronous iterators and the for/await loop were introduced in ES2018 and allow you to work with streams of asynchronous events using simple loops that appear synchronous. 这种异步编程在 JavaScript 中很常见，本章将介绍三种重要的语言特性，它们有助于简化异步代码的使用。Promise 是 ES6 中的新特性，是表示目前不可用结果的异步操作对象。关键字 async 和 await 是在 ES2017 中引入的，它们提供了新的语法，通过允许将基于 Promise 的代码构造成同步的方式来简化异步编程。最后，在 ES2018 中引入了异步迭代器和 for/await 循环，允许使用简单的同步循环处理异步事件流。 Ironically, even though JavaScript provides these powerful features for working with asynchronous code, there are no features of the core language that are themselves asynchronous. In order to demonstrate Promises, async, await, and for/await, therefore, we will first take a detour into client-side and server-side JavaScript to explain some of the asynchronous features of web browsers and Node. (You can learn more about client-side and server-side JavaScript in Chapters 15 and 16.) 具有讽刺意味的是，尽管 JavaScript 为处理异步代码提供了这些强大的特性，但核心语言本身并没有异步的特性。因此，为了演示 Promise、async、await 和 for/await，我们将首先使用客户端和服务器端 JavaScript 来解释 web 浏览器和 Node 的一些异步特性。（可以在第 15 章和第 16 章中了解更多关于客户端和服务器端 JavaScript 的知识。） ","date":"2020-11-02","objectID":"/posts/ch13/:0:0","tags":null,"title":"第 13 章 异步 JavaScript","uri":"/posts/ch13/"},{"categories":null,"content":"13.1 Asynchronous Programming with Callbacks At its most fundamental level, asynchronous programming in JavaScript is done with callbacks. A callback is a function that you write and then pass to some other function. That other function then invokes (“calls back”) your function when some condition is met or some (asynchronous) event occurs. The invocation of the callback function you provide notifies you of the condition or event, and sometimes, the invocation will include function arguments that provide additional details. This is easier to understand with some concrete examples, and the subsections that follow demonstrate various forms of callback-based asynchronous programming using both client-side JavaScript and Node. 在最基本的层次上，JavaScript 中的异步编程是通过回调来完成的。回调是一个你编写的函数，然后传递给其他函数。当满足某些条件或发生某些（异步）事件时，其他函数调用（“回调”）你的函数。提供的回调函数的调用会通知你条件或事件，有时，调用将提供包含额外细节的函数实参。通过一些具体的示例会更容易理解，下面的子节将演示使用客户端 JavaScript 和 Node 的各种形式的基于回调的异步编程。 ","date":"2020-11-02","objectID":"/posts/ch13/:1:0","tags":null,"title":"第 13 章 异步 JavaScript","uri":"/posts/ch13/"},{"categories":null,"content":"13.1.1 Timers One of the simplest kinds of asynchrony is when you want to run some code after a certain amount of time has elapsed. As we saw in §11.10, you can do this with the setTimeout() function: 当希望在经过一定时间后运行某些代码是一种最简单的异步类型。正如我们在 §11.10 中看到的，可以通过 setTimeout() 函数来做到这一点： setTimeout(checkForUpdates, 60000); The first argument to setTimeout() is a function and the second is a time interval measured in milliseconds. In the preceding code, a hypothetical checkForUpdates() function will be called 60,000 milliseconds (1 minute) after the setTimeout() call. checkForUpdates() is a callback function that your program might define, and setTimeout() is the function that you invoke to register your callback function and specify under what asynchronous conditions it should be invoked. setTimeout() 的第一个实参是一个函数，第二个实参是一个以毫秒为单位的时间间隔。前面的代码中，在 setTimeout() 调用后 60,000 毫秒（1分钟）后，将调用一个假定的 checkForUpdates() 函数。checkForUpdates() 是程序定义的一个回调函数，而 setTimeout() 是用于注册回调函数并指定应该在什么异步条件下调用它的函数。 setTimeout() calls the specified callback function one time, passing no arguments, and then forgets about it. If you are writing a function that really does check for updates, you probably want it to run repeatedly. You can do this by using setInterval() instead of setTimeout(): setTimeout() 调用一次指定的回调函数，不传递任何实参，然后忘记它。如果正在编写一个检查更新的函数，可能希望它重复运行。可以使用 setInterval() 来代替 setTimeout()： // Call checkForUpdates in one minute and then again every minute after that let updateIntervalId = setInterval(checkForUpdates, 60000); // setInterval() returns a value that we can use to stop the repeated // invocations by calling clearInterval(). (Similarly, setTimeout() // returns a value that you can pass to clearTimeout()) function stopCheckingForUpdates() { clearInterval(updateIntervalId); } ","date":"2020-11-02","objectID":"/posts/ch13/:1:1","tags":null,"title":"第 13 章 异步 JavaScript","uri":"/posts/ch13/"},{"categories":null,"content":"13.1.2 Events Client-side JavaScript programs are almost universally event driven: rather than running some kind of predetermined computation, they typically wait for the user to do something and then respond to the user’s actions. The web browser generates an event when the user presses a key on the keyboard, moves the mouse, clicks a mouse button, or touches a touchscreen device. Event-driven JavaScript programs register callback functions for specified types of events in specified contexts, and the web browser invokes those functions whenever the specified events occur. These callback functions are called event handlers or event listeners, and they are registered with addEventListener(): 客户端 JavaScript 程序几乎都是由事件驱动的：它们通常不等待用户执行某种预定的计算，而是等待用户执行某些操作，然后响应用户的操作。当用户按下键盘上的键，移动鼠标，单击鼠标按钮或触摸触摸屏设备时，Web 浏览器会发生事件。事件驱动的 JavaScript 程序在指定的上下文中为指定类型的事件注册回调函数，并且只要指定事件发生，Web 浏览器就会调用这些函数。这些回调函数称为事件句柄或事件监听器，并且使用 addEventListener() 注册： // Ask the web browser to return an object representing the HTML // \u003cbutton\u003e element that matches this CSS selector let okay = document.querySelector('#confirmUpdateDialog button.okay'); // Now register a callback function to be invoked when the user // clicks on that button. okay.addEventListener('click', applyUpdate); In this example, applyUpdate() is a hypothetical callback function that we assume is implemented somewhere else. The call to document.querySelector() returns an object that represents a single specified element in the web page. We call addEventListener() on that element to register our callback. Then the first argument to addEventListener() is a string that specifies the kind of event we’re interested in—a mouse click or touchscreen tap, in this case. If the user clicks or taps on that specific element of the web page, then the browser will invoke our applyUpdate() callback function, passing an object that includes details (such as the time and the mouse pointer coordinates) about the event. 在此示例中，假设 applyUpdate() 是我们在某个地方实现的回调函数。调用 document.querySelector() 返回一个对象，该对象表示网页中的单个指定元素。我们在该元素上调用 addEventListener() 来注册我们的回调。然后，addEventListener() 的第一个实参是一个字符串，该字符串指定了事件的类型（在这种情况下是单击鼠标或触摸屏）。如果用户单击或点击网页上的特定元素，则浏览器将调用我们的 applyUpdate() 回调函数，并传递一个包含事件详细信息（例如时间和鼠标指针坐标）的对象。 ","date":"2020-11-02","objectID":"/posts/ch13/:1:2","tags":null,"title":"第 13 章 异步 JavaScript","uri":"/posts/ch13/"},{"categories":null,"content":"13.1.3 Network Events Another common source of asynchrony in JavaScript programming is network requests. JavaScript running in the browser can fetch data from a web server with code like this: JavaScript 编程中异步的另一个常见来源是网络请求。在浏览器中运行的 JavaScript 可以使用以下代码从 Web 服务器获取数据： function getCurrentVersionNumber(versionCallback) { // Note callback argument // Make a scripted HTTP request to a backend version API let request = new XMLHttpRequest(); request.open(\"GET\", \"http://www.example.com/api/version\"); request.send(); // Register a callback that will be invoked when the response arrives request.onload = function() { if (request.status === 200) { // If HTTP status is good, get version number and call callback. let currentVersion = parseFloat(request.responseText); versionCallback(null, currentVersion); } else { // Otherwise report an error to the callback versionCallback(response.statusText, null); } }; // Register another callback that will be invoked for network errors request.onerror = request.ontimeout = function(e) { versionCallback(e.type, null); }; } Client-side JavaScript code can use the XMLHttpRequest class plus callback functions to make HTTP requests and asynchronously handle the server’s response when it arrives.1 The getCurrentVersionNumber() function defined here (we can imagine that it is used by the hypothetical checkForUpdates() function we discussed in §13.1.1) makes an HTTP request and defines event handlers that will be invoked when the server’s response is received or when a timeout or other error causes the request to fail. 客户端 JavaScript 代码可以使用 XMLHttpRequest 类以及回调函数来发出 HTTP 请求，并在服务器响应时异步处理。1 这里定义的 getCurrentVersionNumber() 函数（我们可以假设在 §13.1.1 提到的 checkForUpdates() 函数使用了该函数）发出 HTTP 请求并定义事件处理程序，该事件处理程序将在收到服务器的响应或超时或其他异常导致请求失败时被调用。 Notice that the code example above does not call addEventListener() as our previous example did. For most web APIs (including this one), event handlers can be defined by invoking addEventListener() on the object generating the event and passing the name of the event of interest along with the callback function. Typically, though, you can also register a single event listener by assigning it directly to a property of the object. That is what we do in this example code, assigning functions to the onload, onerror, and ontimeout properties. By convention, event listener properties like these always have names that begin with on. addEventListener() is the more flexible technique because it allows for multiple event handlers. But in cases where you are sure that no other code will need to register a listener for the same object and event type, it can be simpler to simply set the appropriate property to your callback. 请注意，上面的代码示例未像前面的示例那样调用 addEventListener()。对于大多数 Web API（包括此API），可以通过在生成事件的对象上调用 addEventListener() 并将事件的名称与回调函数一起传递来定义事件处理程序。不过，通常，也可以通过将单个事件侦听器直接分配给对象的属性来注册它。这就是我们在此示例代码中所做的，将函数分配给 onload、onerror 和 ontimeout 属性。按照惯例，此类事件侦听器属性的名称始终以 on 开头。 addEventListener() 是更灵活的技术，因为它允许多个事件处理程序。但是，如果确定没有其他代码需要为相同的对象和事件类型注册一个侦听器，则只需将适当的属性设置为回调会更简单。 Another thing to note about the getCurrentVersionNumber() function in this example code is that, because it makes an asynchronous request, it cannot synchronously return the value (the current version number) that the caller is interested in. Instead, the caller passes a callback function, which is invoked when the result is ready or when an error occurs. In this case, the caller supplies a callback function that expects two arguments. If the XMLHttpRequest works correctly, then getCurrentVersionNumber() invokes the callback with a null first argument and the version number as the second argument. Or, if an error occurs, then getCurrentVersionNumber() invokes the callback with error details in the first argument and null as the second argument. 此示例代码中关于 getCurrentVersionNumber() 函数的另一点注意事项是，由于它发出异步请求，因此无法同步返回调用者感兴趣的值（当前版本号）。相反，调用者传递了一个回调函数，当结果准备就绪或发生异常时调用。在这种情况下，调用方提供了一个回调函数，该函数需要两个参数。如果 XMLHttpRequest 正常工作，则 getCurrentVersionNumber() 会使用 null 为第一个实参和版本号为第","date":"2020-11-02","objectID":"/posts/ch13/:1:3","tags":null,"title":"第 13 章 异步 JavaScript","uri":"/posts/ch13/"},{"categories":null,"content":"13.1.4 Callbacks and Events in Node The Node.js server-side JavaScript environment is deeply asynchronous and defines many APIs that use callbacks and events. The default API for reading the contents of a file, for example, is asynchronous and invokes a callback function when the contents of the file have been read: const fs = require(\"fs\"); // The \"fs\" module has filesystem-related APIs let options = { // An object to hold options for our program // default options would go here }; // Read a configuration file, then call the callback function fs.readFile(\"config.json\", \"utf-8\", (err, text) =\u003e { if (err) { // If there was an error, display a warning, but continue console.warn(\"Could not read config file:\", err); } else { // Otherwise, parse the file contents and assign to the options object Object.assign(options, JSON.parse(text)); } // In either case, we can now start running the program startProgram(options); }); Node’s fs.readFile() function takes a two-parameter callback as its last argument. It reads the specified file asynchronously and then invokes the callback. If the file was read successfully, it passes the file contents as the second callback argument. If there was an error, it passes the error as the first callback argument. In this example, we express the callback as an arrow function, which is a succinct and natural syntax for this kind of simple operation. Node also defines a number of event-based APIs. The following function shows how to make an HTTP request for the contents of a URL in Node. It has two layers of asynchronous code handled with event listeners. Notice that Node uses an on() method to register event listeners instead of addEventListener(): const https = require(\"https\"); // Read the text content of the URL and asynchronously pass it to the callback. function getText(url, callback) { // Start an HTTP GET request for the URL request = https.get(url); // Register a function to handle the \"response\" event. request.on(\"response\", response =\u003e { // The response event means that response headers have been received let httpStatus = response.statusCode; // The body of the HTTP response has not been received yet. // So we register more event handlers to to be called when it arrives. response.setEncoding(\"utf-8\"); // We're expecting Unicode text let body = \"\"; // which we will accumulate here. // This event handler is called when a chunk of the body is ready response.on(\"data\", chunk =\u003e { body += chunk; }); // This event handler is called when the response is complete response.on(\"end\", () =\u003e { if (httpStatus === 200) { // If the HTTP response was good callback(null, body); // Pass response body to the callback } else { // Otherwise pass an error callback(httpStatus, null); } }); }); // We also register an event handler for lower-level network errors request.on(\"error\", (err) =\u003e { callback(err, null); }); } ","date":"2020-11-02","objectID":"/posts/ch13/:1:4","tags":null,"title":"第 13 章 异步 JavaScript","uri":"/posts/ch13/"},{"categories":null,"content":"13.2 Promises Now that we’ve seen examples of callback and event-based asynchronous programming in client-side and server-side JavaScript environments, we can introduce Promises, a core language feature designed to simplify asynchronous programming. 现在，我们已经见过了客户端和服务器端 JavaScript 环境中基于回调和基于事件的异步编程的示例，我们接着介绍 Promise，这是一种旨在简化异步编程的核心语言特性。 A Promise is an object that represents the result of an asynchronous computation. That result may or may not be ready yet, and the Promise API is intentionally vague about this: there is no way to synchronously get the value of a Promise; you can only ask the Promise to call a callback function when the value is ready. If you are defining an asynchronous API like the getText() function in the previous section, but want to make it Promise-based, omit the callback argument, and instead return a Promise object. The caller can then register one or more callbacks on this Promise object, and they will be invoked when the asynchronous computation is done. Promise 是描述异步计算结果的对象。该结果可能准备好或尚未准备好，Promise API 故意对此含糊其词：无法同步获取 Promise 的值；只能要求 promise 在值准备好时调用回调函数。如果要像上一节中的 getText() 函数那样定义异步 API，但想使其基于 Promise，则省略 callback 参数，而返回 Promise 对象。然后，调用者可以在此 Promise 对象上注册一个或多个回调，并且在异步计算完成后将调用它们。 So, at the simplest level, Promises are just a different way of working with callbacks. However, there are practical benefits to using them. One real problem with callback-based asynchronous programming is that it is common to end up with callbacks inside callbacks inside callbacks, with lines of code so highly indented that it is difficult to read. Promises allow this kind of nested callback to be re-expressed as a more linear Promise chain that tends to be easier to read and easier to reason about. 因此，最简单的说，promise 只是使用回调的另一种方式。但是，使用它有实际的好处。基于回调的异步编程的一个真正的问题是，通常在回调内部嵌套多层回调，并且代码行缩进程度很高，以至于很难阅读。Promise 允许将这种嵌套的回调作为更线性的 Promise 链重新表达，该链往往更易于阅读和推理。 Another problem with callbacks is that they can make handling errors difficult. If an asynchronous function (or an asynchronously invoked callback) throws an exception, there is no way for that exception to propagate back to the initiator of the asynchronous operation. This is a fundamental fact about asynchronous programming: it breaks exception handling. The alternative is to meticulously track and propagate errors with callback arguments and return values, but this is tedious and difficult to get right. Promises help here by standardizing a way to handle errors and providing a way for errors to propagate correctly through a chain of promises. 回调的另一个问题是，它们会使处理异常变得困难。如果异步函数（或异步调用的回调）引发异常，则该异常无法传播回异步操作的发起者。这是关于异步编程的基本事实：它破坏了异常处理。替代方法是使用回调实参和返回值来精心跟踪和传播异常，但这很繁琐且难以正确处理。Promise 通过标准化处理异常的方式以及为异常通过 Promise 链正确传播的方式提供帮助。 Note that Promises represent the future results of single asynchronous computations. They cannot be used to represent repeated asynchronous computations, however. Later in this chapter, we’ll write a Promise-based alternative to the setTimeout() function, for example. But we can’t use Promises to replace setInterval() because that function invokes a callback function repeatedly, which is something that Promises are just not designed to do. Similarly, we could use a Promise instead of the “load” event handler of an XMLHttpRequest object, since that callback is only ever called once. But we typically would not use a Promise in place of a “click” event handler of an HTML button object, since we normally want to allow the user to click a button multiple times. 请注意，promise 表示单个异步计算的未来结果。但是，它不能用于表示重复的异步计算。例如，在本章的后面，我们将写一个基于 Promise 的 setTieout() 函数替代方法。但是，我们不能使用 Promise 来代替 setInterval()，因为该函数会反复调用回调函数，而 Promise 并不是。同样，我们可以使用 Promise 代替 XMLHttpRequest 对象的“load”事件处理程序，因为该回调仅被调用一次。但是我们通常不会使用 Promise 来代替 HTML 按钮对象的“click”事件处理程序，因为我们通常希望允许用户多次单击按钮。 The subsections that follow will: 接下来的小节将： Explain Promise terminology and show basic Promise usage Show how promises can be chained Demonstrate how to create your own Promise-based APIs 解释 Promise 术语并演示 Promise 的基本用法 展示如何将 Promise 链接起来 演示","date":"2020-11-02","objectID":"/posts/ch13/:2:0","tags":null,"title":"第 13 章 异步 JavaScript","uri":"/posts/ch13/"},{"categories":null,"content":"13.2.1 Using Promises With the advent of Promises in the core JavaScript language, web browsers have begun to implement Promise-based APIs. In the previous section, we implemented a getText() function that made an asynchronous HTTP request and passed the body of the HTTP response to a specified callback function as a string. Imagine a variant of this function, getJSON(), which parses the body of the HTTP response as JSON and returns a Promise instead of accepting a callback argument. We will implement a getJSON() function later in this chapter, but for now, let’s look at how we would use this Promise-returning utility function: 随着核心 JavaScript 语言中 Promise 的出现，Web 浏览器已经开始实现基于 Promise 的 API。在上一节中，我们实现了一个 getText() 函数，该函数发出一个异步 HTTP 请求，并将 HTTP 响应的主体作为字符串传递给指定的回调函数。想象一下该函数的一个变体 getJSON()，它可以解析主体 HTTP 响应的形式为 JSON，并返回 Promise 而不是接受回调参数。我们将在本章稍后实现 getJSON() 函数，但现在，让我们看一下如何使用返回 Promise 功能程序函数： getJSON(url).then(jsonData =\u003e { // This is a callback function that will be asynchronously // invoked with the parsed JSON value when it becomes available. }); getJSON() starts an asynchronous HTTP request for the URL you specify and then, while that request is pending, it returns a Promise object. The Promise object defines a then() instance method. Instead of passing our callback function directly to getJSON(), we instead pass it to the then() method. When the HTTP response arrives, the body of that response is parsed as JSON, and the resulting parsed value is passed to the function that we passed to then(). getJSON() 对指定的 URL 启动一个异步 HTTP 请求，当该请求待定时，它返回一个 Promise 对象。Promise 对象定义了 then() 实例方法。我们没有将回调函数直接传递给 getJSON()，而是将其传递给 then() 方法。当 HTTP 响应时，该响应的主体将解析为 JSON，并将所解析的结果值传给我们传递给 then() 的回调函数。 You can think of the then() method as a callback registration method like the addEventListener() method used for registering event handlers in client-side JavaScript. If you call the then() method of a Promise object multiple times, each of the functions you specify will be called when the promised computation is complete. 可以将 then() 方法视为回调注册方法，例如用于在客户端 JavaScript 中注册事件处理程序的 addEventListener() 方法。如果多次调用 Promise 对象的 then() 方法，则在完成 promise 的计算后将调用指定的每个函数。 Unlike many event listeners, though, a Promise represents a single computation, and each function registered with then() will be invoked only once. It is worth noting that the function you pass to then() is invoked asynchronously, even if the asynchronous computation is already complete when you call then(). 但是，与许多事件侦听器不同，Promise 表示单个计算，并且 then() 注册的每个函数仅被调用一次。值得注意的是，传递给 then() 的函数是异步调用的，即使调用 then() 时异步计算已经完成。 At a simple syntactical level, the then() method is the distinctive feature of Promises, and it is idiomatic to append .then() directly to the function invocation that returns the Promise, without the intermediate step of assigning the Promise object to a variable. 在简单的语法级别上，then() 方法是 Promise 独有的特性，编码中习惯于将 .then() 直接跟随返回 Promise 的函数，而无需将 Promise 对象分配给变量的中间步骤。 It is also idiomatic to name functions that return Promises and functions that use the results of Promises with verbs, and these idioms lead to code that is particularly easy to read: 常用带有动词命名返回 Promise 的函数和使用 Promise 结果的函数，这些常用语使代码特别容易阅读： // Suppose you have a function like this to display a user profile function displayUserProfile(profile) { /* implementation omitted */ } // Here's how you might use that function with a Promise. // Notice how this line of code reads almost like an English sentence: getJSON(\"/api/user/profile\").then(displayUserProfile); HANDLING ERRORS WITH PROMISES Asynchronous operations, particularly those that involve networking, can typically fail in a number of ways, and robust code has to be written to handle the errors that will inevitably occur. 异步操作，尤其是涉及网络的异步操作，通常会以多种方式失败，并且必须编写健壮的代码来处理不可避免地会发生的异常。 For Promises, we can do this by passing a second function to the then() method: 对于 Promise，我们可以通过将第二个函数传递给 then() 方法来实现： getJSON(\"/api/user/profile\").then(displayUserProfile, handleProfileError); A Promise represents the fu","date":"2020-11-02","objectID":"/posts/ch13/:2:1","tags":null,"title":"第 13 章 异步 JavaScript","uri":"/posts/ch13/"},{"categories":null,"content":"13.2.2 Chaining Promises One of the most important benefits of Promises is that they provide a natural way to express a sequence of asynchronous operations as a linear chain of then() method invocations, without having to nest each operation within the callback of the previous one. Here, for example, is a hypothetical Promise chain: Promise 的最重要的好处之一是，它们提供了一种自然的方式来表达一系列异步操作，表示 then() 方法调用的线性链，而不必将每个操作嵌套在前一个回调中。例如，一个假设的 Promise 链： fetch(documentURL) // Make an HTTP request .then(response =\u003e response.json()) // Ask for the JSON body of the response .then(document =\u003e { // When we get the parsed JSON return render(document); // display the document to the user }) .then(rendered =\u003e { // When we get the rendered document cacheInDatabase(rendered); // cache it in the local database. }) .catch(error =\u003e handle(error)); // Handle any errors that occur This code illustrates how a chain of Promises can make it easy to express a sequence of asynchronous operations. We’re not going to discuss this particular Promise chain at all, however. We will continue to explore the idea of using Promise chains to make HTTP requests, however. 此代码表明了 Promise 链如何简化一系列异步操作。我们不会讨论这个特殊的 Promise 链。但是，我们将继续探索使用 Promise 链发出 HTTP 请求的想法。 Earlier in this chapter, we saw the XMLHttpRequest object used to make an HTTP request in JavaScript. That strangely named object has an old and awkward API, and it has largely been replaced by the newer, Promise-based Fetch API (§15.11.1). In its simplest form, this new HTTP API is just the function fetch(). You pass it a URL, and it returns a Promise. That promise is fulfilled when the HTTP response begins to arrive and the HTTP status and headers are available: 在本章的前面，我们看到了 XMLHttpRequest 对象，该对象用于在 JavaScript 中发出 HTTP 请求。这个奇怪命名的对象具有一个旧且笨拙的 API，并且在很大程度上已被较新的基于 Promise 的 Fetch API（§15.11.1）所取代。以最简单的形式，这个新的 HTTP API 只是 fetch() 函数。给它传递一个 URL，然后返回一个 Promise。当 HTTP 开始收到响应并且 HTTP 状态和标头可用时，这个 promise 已兑现： fetch(\"/api/user/profile\").then(response =\u003e { // When the promise resolves, we have status and headers if (response.ok \u0026\u0026 response.headers.get(\"Content-Type\") === \"application/json\") { // What can we do here? We don't actually have the response body yet. } }); When the Promise returned by fetch() is fulfilled, it passes a Response object to the function you passed to its then() method. This response object gives you access to request status and headers, and it also defines methods like text() and json(), which give you access to the body of the response in text and JSON-parsed forms, respectively. But although the initial Promise is fulfilled, the body of the response may not yet have arrived. So these text() and json() methods for accessing the body of the response themselves return Promises. Here’s a naive way of using fetch() and the response.json() method to get the body of an HTTP response: 当 fetch() 返回的 Promise 已兑现时，它将 Response 对象传递给传递给 then() 方法的函数。此响应对象可以访问请求状态和标头，并且还定义了诸如 text() 和 json() 之类的方法，这些方法可以分别以文本和 JSON 的形式访问响应的正文。但是，尽管最初的 Promise 已兑现，但响应的主体可能尚未到达。因此，这些用于访问响应正文的 text() 和 json() 方法本身返回 Promise。这是使用 fetch() 和 response.json() 方法获取 HTTP Response 响应正文的一种简单方法： fetch(\"/api/user/profile\").then(response =\u003e { response.json().then(profile =\u003e { // Ask for the JSON-parsed body // When the body of the response arrives, it will be automatically // parsed as JSON and passed to this function. displayUserProfile(profile); }); }); This is a naive way to use Promises because we nested them, like callbacks, which defeats the purpose. The preferred idiom is to use Promises in a sequential chain with code like this: 这是 Promise 一种没经验的使用方式，因为我们像回调一样嵌套了它们，这违背了目的。首选常用方法是在顺序链中使用 Promise，其代码如下所示： fetch(\"/api/user/profile\") .then(response =\u003e { return response.json(); }) .then(profile =\u003e { displayUserProfile(profile); }); Let’s look at the method invocations in this code, ignoring the arguments that are passed to the methods: 让我们看一下这段代码中的方法调用，忽略传递给方法的参数： fetch().then().then() When more than one method is invoked in a single expression like this, w","date":"2020-11-02","objectID":"/posts/ch13/:2:2","tags":null,"title":"第 13 章 异步 JavaScript","uri":"/posts/ch13/"},{"categories":null,"content":"13.2.3 Resolving Promises While explaining the URL-fetching Promise chain with the list in the last section, we talked about promises 1, 2, and 3. But there is actually a fourth Promise object involved as well, and this brings us to our important discussion of what it means for a Promise to be “resolved.” 在上一部分中用列表解释 URL-fetching Promise 链时，我们讨论了 promise 1、2 和 3。但是实际上也涉及第四个 Promise 对象，并且这为我们带来重要的讨论————什么是 Promise 的“已决议（resolved）”状态 。 Remember that fetch() returns a Promise object which, when fulfilled, passes a Response object to the callback function we register. This Response object has .text(), .json(), and other methods to request the body of the HTTP response in various forms. But since the body may not yet have arrived, these methods must return Promise objects. In the example we’ve been studying, “task 2” calls the .json() method and returns its value. This is the fourth Promise object, and it is the return value of the callback1() function. 请记住，fetch() 返回一个 Promise 对象，当其已兑现时，它将 Response 对象传递给我们注册的回调函数。此 Response 对象具有 .text()、.json() 和其他方法，以各种形式请求 HTTP 响应的主体。但是由于主体可能尚未到达，因此这些方法必须返回 Promise 对象。在我们一直在研究的示例中，“task 2”调用 .json() 方法并返回其值。这是第四个 Promise 对象，它是 callback1() 函数的返回值。 Let’s rewrite the URL-fetching code one more time in a verbose and nonidiomatic way that makes the callbacks and promises explicit: 让我们以冗长且非常用方式再次重写 URL-fetching 代码，使回调和 Promise 明确化： function c1(response) { // callback 1 let p4 = response.json(); return p4; // returns promise 4 } function c2(profile) { // callback 2 displayUserProfile(profile); } let p1 = fetch(\"/api/user/profile\"); // promise 1, task 1 let p2 = p1.then(c1); // promise 2, task 2 let p3 = p2.then(c2); // promise 3, task 3 In order for Promise chains to work usefully, the output of task 2 must become the input to task 3. And in the example we’re considering here, the input to task 3 is the body of the URL that was fetched, parsed as a JSON object. But, as we’ve just discussed, the return value of callback c1 is not a JSON object, but Promise p4 for that JSON object. This seems like a contradiction, but it is not: when p1 is fulfilled, c1 is invoked, and task 2 begins. And when p2 is fulfilled, c2 is invoked, and task 3 begins. But just because task 2 begins when c1 is invoked, it does not mean that task 2 must end when c1 returns. Promises are about managing asynchronous tasks, after all, and if task 2 is asynchronous (which it is, in this case), then that task will not be complete by the time the callback returns. 为了使 Promise 链有效地工作，task 2 的输出必须成为 task 3 的输入。在此示例中，我们在这里考虑的是，task 3 的输入是从 URL 所获取的的主体，将其解析为 JSON 对象。但是，正如我们刚刚讨论的那样，回调 c1 的返回值不是 JSON 对象，而是该 JSON 对象的 Promise p4。这似乎有矛盾，但并非如此：当 p1 已兑现时，将调用 c1，并且 task 2 开始。当 p2 已兑现时，c2 被调用，task 3 开始。但是，仅仅因为 c1 被调用时开始 task 2 ，可这并不意味着 task 2 必须在 c1 返回时结束。毕竟，Promise 是关于管理异步任务的，如果 task 2 是异步的（在本例中为异步），则在回调返回时该任务将不会完成。 We are now ready to discuss the final detail that you need to understand to really master Promises. When you pass a callback c to the then() method, then() returns a Promise p and arranges to asynchronously invoke c at some later time. The callback performs some computation and returns a value v. When the callback returns, p is resolved with the value v. When a Promise is resolved with a value that is not itself a Promise, it is immediately fulfilled with that value. So if c returns a non-Promise, that return value becomes the value of p, p is fulfilled and we are done. But if the return value v is itself a Promise, then p is resolved but not yet fulfilled. At this stage, p cannot settle until the Promise v settles. If v is fulfilled, then p will be fulfilled to the same value. If v is rejected, then p will be rejected for the same reason. This is what the “resolved” state of a Promise means: the Promise has become associated with, or “locked onto,” another Promise. We don’t know yet whether p will be fulfilled or rejected, but our callback c no longer has any control over that. p is “resolved” in the sense that its fate now depends enti","date":"2020-11-02","objectID":"/posts/ch13/:2:3","tags":null,"title":"第 13 章 异步 JavaScript","uri":"/posts/ch13/"},{"categories":null,"content":"13.2.4 More on Promises and Errors Earlier in the chapter, we saw that you can pass a second callback function to the .then() method and that this second function will be invoked if the Promise is rejected. When that happens, the argument to this second callback function is a value—typically an Error object—that represents the reason for the rejection. We also learned that it is uncommon (and even unidiomatic) to pass two callbacks to a .then() method. Instead, Promise-related errors are typically handled by adding a .catch() method invocation to a Promise chain. Now that we have examined Promise chains, we can return to error handling and discuss it in more detail. To preface the discussion, I’d like to stress that careful error handling is really important when doing asynchronous programming. With synchronous code, if you leave out error-handling code, you’ll at least get an exception and a stack trace that you can use to figure out what is going wrong. With asynchronous code, unhandled exceptions will often go unreported, and errors can occur silently, making them much harder to debug. The good news is that the .catch() method makes it easy to handle errors when working with Promises. 在本章的前面，我们看到可以将第二个回调函数传递给 .then() 方法，并且如果 Promise 被拒绝，则将调用该第二个函数。发生这种情况时，第二个回调函数的实参是一个值（通常是一个 Error 对象），它表示拒绝的原因。我们还了解到，将两个回调传递给 .then() 方法并不常见（甚至是单例的）。相反，通常通过向 Promise 链添加 .catch() 方法调用来处理与 Promise 相关的异常。现在我们已经检查了 Promise 链，我们可以返回异常处理并更详细地讨论它。在开始讨论之前，我想强调指出，进行异步编程时，仔细的异常处理非常重要。使用同步代码，如果省略了异常处理代码，则至少会得到一个异常和一个堆栈跟踪，可用于找出问题所在。对于异步代码，未处理的异常通常不会报告，异常可以静默发生，从而使调试更加困难。好消息是，使用 .catch() 方法可以更轻松地处理 Promise 的异常。 THE CATCH AND FINALLY METHODS The .catch() method of a Promise is simply a shorthand way to call .then() with null as the first argument and an error-handling callback as the second argument. Given any Promise p and a callback c, the following two lines are equivalent: .then() 可以处理异常，使用 null 为第一个实参，而异常处理回调为第二个实参，Promise 的 .catch() 方法只是这种 .then() 调用的一种简便写法。给定 Promise p 和回调 c，以下两行代码是等效的： p.then(null, c); p.catch(c); The .catch() shorthand is preferred because it is simpler and because the name matches the catch clause in a try/catch exception-handling statement. As we’ve discussed, normal exceptions don’t work with asynchronous code. The .catch() method of Promises is an alternative that does work for asynchronous code. When something goes wrong in synchronous code, we can speak of an exception “bubbling up the call stack” until it finds a catch block. With an asynchronous chain of Promises, the comparable metaphor might be of an error “trickling down the chain” until it finds a .catch() invocation. 首选 .catch() 速记，因为它更简单，并且名称与 try/catch 异常处理语句中的 catch 子句匹配。正如我们所讨论的，普通例外不适用于异步代码。Promise 的 .catch() 方法是一种适用于异步代码的替代方法。当同步代码中出现问题时，我们“使调用堆栈冒泡”描述一个异常，直到找到 catch 块为止。对于异步的 Promise 链，则是“向链下滴”，直到找到 .catch() 调用为止。 In ES2018, Promise objects also define a .finally() method whose purpose is similar to the finally clause in a try/catch/finally statement. If you add a .finally() invocation to your Promise chain, then the callback you pass to .finally() will be invoked when the Promise you called it on settles. Your callback will be invoked if the Promise fulfills or rejects, and it will not be passed any arguments, so you can’t find out whether it fulfilled or rejected. But if you need to run some kind of cleanup code (such as closing open files or network connections) in either case, a .finally() callback is the ideal way to do that. Like .then() and .catch(), .finally() returns a new Promise object. The return value of a .finally() callback is generally ignored, and the Promise returned by .finally() will typically resolve or reject with the same value that the Promise that .finally() was invoked on resolves or rejects with. If a .finally() callback throws an exception, however, then the Promise returned by .finally() will reject with that value. 在 ES2018 中，Promise 对象还定义了一个 .finally() 方法，其目的类似于 try/catch/finally 语句中的 finally 子句。如果将 .finally() 调用添加到 Promise 链中，那么","date":"2020-11-02","objectID":"/posts/ch13/:2:4","tags":null,"title":"第 13 章 异步 JavaScript","uri":"/posts/ch13/"},{"categories":null,"content":"13.2.5 Promises in Parallel We’ve spent a lot of time talking about Promise chains for sequentially running the asynchronous steps of a larger asynchronous operation. Sometimes, though, we want to execute a number of asynchronous operations in parallel. The function Promise.all() can do this. Promise.all() takes an array of Promise objects as its input and returns a Promise. The returned Promise will be rejected if any of the input Promises are rejected. Otherwise, it will be fulfilled with an array of the fulfillment values of each of the input Promises. So, for example, if you want to fetch the text content of multiple URLs, you could use code like this: 我们花了很多时间讨论 Promise 链，这些链可按顺序运行较大的异步的操作步骤。但是，有时我们想并行执行许多异步操作。函数 Promise.all() 可以做到这一点。Promise.all() 将 Promise 对象数组作为其输入，并返回 Promise。如果任何输入的 Promise 中有一个是已拒绝状态，则返回的 Promise 将被拒绝。否则，它将使用每个输入 Promise 的兑现值组成的数组来被兑现。因此，例如，如果要获取多个 URL 的文本内容，则可以使用如下代码： // We start with an array of URLs const urls = [ /* zero or more URLs here */ ]; // And convert it to an array of Promise objects promises = urls.map(url =\u003e fetch(url).then(r =\u003e r.text())); // Now get a Promise to run all those Promises in parallel Promise.all(promises) .then(bodies =\u003e { /* do something with the array of strings */ }) .catch(e =\u003e console.error(e)); Promise.all() is slightly more flexible than described before. The input array can contain both Promise objects and non-Promise values. If an element of the array is not a Promise, it is treated as if it is the value of an already fulfilled Promise and is simply copied unchanged into the output array. Promise.all() 比前面描述的要灵活一些。输入数组可以包含 Promise 对象和非 Promise 值。如果数组的元素不是 Promise，则将其视为已兑现的 Promise 的值，并原封不动地复制到输出数组中。 The Promise returned by Promise.all() rejects when any of the input Promises is rejected. This happens immediately upon the first rejection and can happen while other input Promises are still pending. In ES2020, Promise.allSettled() takes an array of input Promises and returns a Promise, just like Promise.all() does. But Promise.allSettled() never rejects the returned Promise, and it does not fulfill that Promise until all of the input Promises have settled. The Promise resolves to an array of objects, with one object for each input Promise. Each of these returned objects has a status property set to “fulfilled” or “rejected.” If the status is “fulfilled”, then the object will also have a value property that gives the fulfillment value. And if the status is “rejected”, then the object will also have a reason property that gives the error or rejection value of the corresponding Promise: 当任何输入的 Promise 被拒绝时，Promise.all() 返回的 Promise 也会被拒绝。这在第一次拒绝时立即发生，可能其他输入 Promise 仍是待定状态。在 ES2020 中，Promise.allSettled() 接受输入的 Promise 数组，并返回 Promise，就像 Promise.all() 一样。但是 Promise.allSettled() 永远不会拒绝返回的 Promise，并且不会兑现这个 Promise，直到所有输入 Promise 全部已敲定。Promise 解析为一组对象，每个输入 Promise 都有一个对象。每个返回的对象中有一个状态属性设置为“已兑现”或“已拒绝”。如果状态为“已兑现”，则对象还将具有一个 value 属性，该属性提供兑现值。并且，如果状态为“已拒绝”，则对象还将具有一个 reason 属性，该属性给出相应的 Promise 的异常或拒绝值： Promise.allSettled([Promise.resolve(1), Promise.reject(2), 3]).then(results =\u003e { results[0] // =\u003e { status: \"fulfilled\", value: 1 } results[1] // =\u003e { status: \"rejected\", reason: 2 } results[2] // =\u003e { status: \"fulfilled\", value: 3 } }); Occasionally, you may want to run a number of Promises at once but may only care about the value of the first one to fulfill. In that case, you can use Promise.race() instead of Promise.all(). It returns a Promise that is fulfilled or rejected when the first of the Promises in the input array is fulfilled or rejected. (Or, if there are any non-Promise values in the input array, it simply returns the first of those.) 有时，可能想一次运行多个 Promise，但可能只关心第一个要兑现的值。在这种情况下，可以使用 Promise.race() 代替 Promise.all()。当输入数组中的第一个 Promise 是已兑现或已拒绝状态时，它返回一个已兑现或已拒绝的 Promise。（或者，如果输入数组中有任何非 Promise 值，则只返回其中的第一个。） ","date":"2020-11-02","objectID":"/posts/ch13/:2:5","tags":null,"title":"第 13 章 异步 JavaScript","uri":"/posts/ch13/"},{"categories":null,"content":"13.2.6 Making Promises We’ve used the Promise-returning function fetch() in many of the previous examples because it is one of the simplest functions built in to web browsers that returns a Promise. Our discussion of Promises has also relied on hypothetical Promise-returning functions getJSON() and wait(). Functions written to return Promises really are quite useful, and this section shows how you can create your own Promise-based APIs. In particular, we’ll show implementations of getJSON() and wait(). 在之前的许多示例中，我们都使用了 Promise 返回函数 fetch()，因为它是内置于 Web 浏览器中的最简单的返回 Promise 的函数之一。我们对 Promise 的讨论还依赖于假设的 Promise 返回函数 getJSON() 和 wait()。编写用于返回 Promise 的函数确实非常有用，本节说明如何创建自己的基于 Promise 的 API。特别是，我们将展示 getJSON() 和 wait() 的实现。 PROMISES BASED ON OTHER PROMISES It is easy to write a function that returns a Promise if you have some other Promise-returning function to start with. Given a Promise, you can always create (and return) a new one by calling .then(). So if we use the existing fetch() function as a starting point, we can write getJSON() like this: 如果以 Promise 返回函数作为开头来写一个返回 Promise 的函数是很容易的。有了 Promise，总是可以通过调用 .then() 创建（并返回）一个新的 Promise。因此，如果我们使用现有的 fetch() 函数作为起点，则可以这样编写 getJSON()： function getJSON(url) { return fetch(url).then(response =\u003e response.json()); } The code is trivial because the Response object of the fetch() API has a predefined json() method. The json() method returns a Promise, which we return from our callback (the callback is an arrow function with a single-expression body, so the return is implicit), so the Promise returned by getJSON() resolves to the Promise returned by response.json(). When that Promise fulfills, the Promise returned by getJSON() fulfills to the same value. Note that there is no error handling in this getJSON() implementation. Instead of checking response.ok and the Content-Type header, we instead just allow the json() method to reject the Promise it returned with a SyntaxError if the response body cannot be parsed as JSON. 该代码很简单，因为 fetch() API 的 Response 对象具有预定义的 json() 方法。我们从回调（该回调是带有单个表达式主体的箭头函数，因此返回值是隐式的）中通过 json() 方法返回一个 Promise，因此 getJSON() 返回的 Promise 解析为 response.json()。当该 Promise 兑现时，由 getJSON() 返回的 Promise 将兑现为相同的值。请注意，此 getJSON() 实现中没有异常处理。如果不能将 response 主体解析为 JSON，则无需检查 response.ok 和 Content-Type 标头，而只需允许 json() 方法拒绝它的 Promise 并返回 SyntaxError。 Let’s write another Promise-returning function, this time using getJSON() as the source of the initial Promise: 让我们编写另一个 Promise 返回函数，这次使用 getJSON() 作为初始 Promise 的来源： function getHighScore() { return getJSON(\"/api/user/profile\").then(profile =\u003e profile.highScore); } We’re assuming that this function is part of some sort of web-based game and that the URL “/api/user/profile” returns a JSON-formatted data structure that includes a highScore property. 我们假设此函数是某种基于网络的游戏的一部分，并且 URL“/api/user/profile”返回的是包含 highScore 属性的 JSON 格式的数据结构。 PROMISES BASED ON SYNCHRONOUS VALUES Sometimes, you may need to implement an existing Promise-based API and return a Promise from a function, even though the computation to be performed does not actually require any asynchronous operations. In that case, the static methods Promise.resolve() and Promise.reject() will do what you want. Promise.resolve() takes a value as its single argument and returns a Promise that will immediately (but asynchronously) be fulfilled to that value. Similarly, Promise.reject() takes a single argument and returns a Promise that will be rejected with that value as the reason. (To be clear: the Promises returned by these static methods are not already fulfilled or rejected when they are returned, but they will fulfill or reject immediately after the current synchronous chunk of code has finished running. Typically, this happens within a few milliseconds unless there are many pending asynchronous tasks waiting to run.) 有时，即使要执行的计算实际上不需要任何异步操作，也可能需要实现现有的基于 Promise 的 API 并从函数返回 Promise。在这种情况下，静态方法 Promise.resolve() 和 Promise.reject() 会做您想要的。Promise.resolve() 采用一个单个实参值，并返回一个 Promise，该 Promise 将","date":"2020-11-02","objectID":"/posts/ch13/:2:6","tags":null,"title":"第 13 章 异步 JavaScript","uri":"/posts/ch13/"},{"categories":null,"content":"13.2.7 Promises in Sequence Promise.all() makes it easy to run an arbitrary number of Promises in parallel. And Promise chains make it easy to express a sequence of a fixed number of Promises. Running an arbitrary number of Promises in sequence is trickier, however. Suppose, for example, that you have an array of URLs to fetch, but that to avoid overloading your network, you want to fetch them one at a time. If the array is of arbitrary length and unknown content, you can’t write out a Promise chain in advance, so you need to build one dynamically, with code like this: Promise.all() 使得并行运行任意数量的 Promise 变得容易。Promise 链使表达固定数量的 Promise 序列变得容易。但是，依次执行任意数量的 Promise 会比较棘手。例如，假设您要获取一组 URL，但是为了避免网络过载，希望一次获取一个 URL。如果数组的长度是任意的且内容未知，则无法提前写出 Promise 链，因此需要使用以下代码动态构建一个： function fetchSequentially(urls) { // We'll store the URL bodies here as we fetch them const bodies = []; // Here's a Promise-returning function that fetches one body function fetchOne(url) { return fetch(url) .then(response =\u003e response.text()) .then(body =\u003e { // We save the body to the array, and we're purposely // omitting a return value here (returning undefined) bodies.push(body); }); } // Start with a Promise that will fulfill right away (with value undefined) let p = Promise.resolve(undefined); // Now loop through the desired URLs, building a Promise chain // of arbitrary length, fetching one URL at each stage of the chain for(url of urls) { p = p.then(() =\u003e fetchOne(url)); } // When the last Promise in that chain is fulfilled, then the // bodies array is ready. So let's return a Promise for that // bodies array. Note that we don't include any error handlers: // we want to allow errors to propagate to the caller. return p.then(() =\u003e bodies); } With this fetchSequentially() function defined, we could fetch the URLs one at a time with code much like the fetch-in-parallel code we used earlier to demonstrate Promise.all(): 定义了这个 fetchSequentially() 函数之后，我们可以用一个代码一次来获取多个 URL，就像我们之前用来演示 Promise.all() 的并行获取代码一样： fetchSequentially(urls) .then(bodies =\u003e { /* do something with the array of strings */ }) .catch(e =\u003e console.error(e)); The fetchSequentially() function starts by creating a Promise that will fulfill immediately after it returns. It then builds a long, linear Promise chain off of that initial Promise and returns the last Promise in the chain. It is like setting up a row of dominoes and then knocking the first one over. fetchSequentially() 函数首先创建一个 Promise，该 Promise 将在返回后立即兑现。然后，它从该初始 Promise 构建一个长的线性 Promise 链，并返回链中的最后一个 Promise。这就像设置一排多米诺骨牌，然后将第一个多米诺骨牌撞倒一样。 There is another (possibly more elegant) approach that we can take. Rather than creating the Promises in advance, we can have the callback for each Promise create and return the next Promise. That is, instead of creating and chaining a bunch of Promises, we instead create Promises that resolve to other Promises. Rather than creating a domino-like chain of Promises, we are instead creating a sequence of Promises nested one inside the other like a set of matryoshka dolls. With this approach, our code can return the first (outermost) Promise, knowing that it will eventually fulfill (or reject!) to the same value that the last (innermost) Promise in the sequence does. The promiseSequence() function that follows is written to be generic and is not specific to URL fetching. It is here at the end of our discussion of Promises because it is complicated. If you’ve read this chapter carefully, however, I hope you’ll be able to understand how it works. In particular, note that the nested function inside promiseSequence() appears to call itself recursively, but because the “recursive” call is through a then() method, there is not actually any traditional recursion happening: 我们可以采用另一种方法（可能更优雅）。除了提前创建 Promise 外，我们还可以为每个 Promise 创建回调，并返回下一个 Promise。也就是说，我们没有创建和链接一堆 Promise，而是创建了决议于其他承诺的承诺。与其创建类似多米诺骨牌的 Promise 链，不如创建一系列彼此嵌套在一起的 Promise 序列，就像俄罗斯套娃一样。使用这种方法，我们的代码可以知道第一个（最外面的）Promise 最终将兑现（或拒绝！），使其返回序列中最后一个（最里面的）Promise 相同的值。后面是通","date":"2020-11-02","objectID":"/posts/ch13/:2:7","tags":null,"title":"第 13 章 异步 JavaScript","uri":"/posts/ch13/"},{"categories":null,"content":"13.3 async and await ES2017 introduces two new keywords—async and await—that represent a paradigm shift in asynchronous JavaScript programming. These new keywords dramatically simplify the use of Promises and allow us to write Promise-based, asynchronous code that looks like synchronous code that blocks while waiting for network responses or other asynchronous events. Although it is still important to understand how Promises work, much of their complexity (and sometimes even their very presence!) vanishes when you use them with async and await. ES2017 引入了两个新的关键字（async 和 await）描述异步 JavaScript 编程中的模式转变。这些新关键字极大地简化了 Promises 的使用，使我们能够编写基于 Promise 的异步代码看起来像是等待网络响应或其他异步事件而阻塞的同步代码。尽管了解 Promises 的工作原理仍然很重要，但是当将它们与 async 和 await 一起使用时，它们的大部分复杂性（有时甚至是它们的存在！）就消失了。 As we discussed earlier in the chapter, asynchronous code can’t return a value or throw an exception the way that regular synchronous code can. And this is why Promises are designed the way the are. The value of a fulfilled Promise is like the return value of a synchronous function. And the value of a rejected Promise is like a value thrown by a synchronous function. This latter similarity is made explicit by the naming of the .catch() method. async and await take efficient, Promise-based code and hide the Promises so that your asynchronous code can be as easy to read and as easy to reason about as inefficient, blocking, synchronous code. 如本章前面所述，异步代码无法像常规同步代码那样返回值或引发异常。这就是为什么 Promise 如此设计的原因。已兑现的 Promise 的值类似于同步函数的返回值。而且已拒绝的 Promise 的值就像同步函数抛出的值。后者通过类似的 .catch() 方法命名，使得表述更清晰。async 和 await 使用高效的、基于 Promise 的代码并隐藏 Promise，以便异步代码可以像低效、阻塞、同步代码一样容易阅读和推理。 ","date":"2020-11-02","objectID":"/posts/ch13/:3:0","tags":null,"title":"第 13 章 异步 JavaScript","uri":"/posts/ch13/"},{"categories":null,"content":"13.3.1 await Expressions The await keyword takes a Promise and turns it back into a return value or a thrown exception. Given a Promise object p, the expression await p waits until p settles. If p fulfills, then the value of await p is the fulfillment value of p. On the other hand, if p is rejected, then the await p expression throws the rejection value of p. We don’t usually use await with a variable that holds a Promise; instead, we use it before the invocation of a function that returns a Promise: 关键字 await 接受一个 Promise，并将其转换为返回值或引发的异常。给定一个 Promise 对象 p，表达式 await p 等待直到 p 敲定。如果 p 兑现，则等待 p 的值就是 p 的兑现值。另一方面，如果 p 被拒绝，则 await p 表达式将抛出 p 的拒绝值。我们通常不将 await 与保存 Promise 的变量一起使用；相反，我们在调用返回 Promise 的函数之前使用它： let response = await fetch(\"/api/user/profile\"); let profile = await response.json(); It is critical to understand right away that the await keyword does not cause your program to block and literally do nothing until the specified Promise settles. The code remains asynchronous, and the await simply disguises this fact. This means that any code that uses await is itself asynchronous. 立即了解至关重要的一点是，在指定的 Promise 敲定之前，await 关键字不会导致程序阻塞，并且实际上什么也不做。代码保持异步，并且 await 只是掩盖了这一事实。这意味着使用 await 的任何代码本身都是异步的。 ","date":"2020-11-02","objectID":"/posts/ch13/:3:1","tags":null,"title":"第 13 章 异步 JavaScript","uri":"/posts/ch13/"},{"categories":null,"content":"13.3.2 async Functions Because any code that uses await is asynchronous, there is one critical rule: you can only use the await keyword within functions that have been declared with the async keyword. Here’s a version of the getHighScore() function from earlier in the chapter, rewritten to use async and await: 因为任何使用 await 的代码都是异步的，所以有一个关键规则：只能在使用 async 关键字声明的函数中使用 await 关键字。下面是本章前面的 getHighScore() 函数的一个版本，使用 async 和 await 重写： async function getHighScore() { let response = await fetch(\"/api/user/profile\"); let profile = await response.json(); return profile.highScore; } Declaring a function async means that the return value of the function will be a Promise even if no Promise-related code appears in the body of the function. If an async function appears to return normally, then the Promise object that is the real return value of the function will resolve to that apparent return value. And if an async function appears to throw an exception, then the Promise object that it returns will be rejected with that exception. 异步声明函数意味着函数的返回值将是一个 Promise，即使函数体中没有出现与 Promise 相关的代码。如果异步函数看起来正常返回，那么作为函数实际返回值的 Promise 对象将决议为该返回值。如果一个异步函数出现抛出异常，那么它返回的 Promise 对象将被那个异常拒绝。 The getHighScore() function is declared async, so it returns a Promise. And because it returns a Promise, we can use the await keyword with it: getHighScore() 函数被声明为异步，因此它返回一个承诺。因为它返回一个承诺，所以我们可以使用 await 关键字： displayHighScore(await getHighScore()); But remember, that line of code will only work if it is inside another async function! You can nest await expressions within async functions as deeply as you want. But if you’re at the top level 2 or are inside a function that is not async for some reason, then you can’t use await and have to deal with a returned Promise in the regular way: 但是请记住，只有在另一个异步函数中，该行代码才有效！可以根据需要在异步函数中嵌套任何层 await 表达式。但是，如果处于最高级别 2 或由于某种原因而处于不异步的函数内，那么您无法使用 await 并且必须以常规方式处理返回的 Promise： getHighScore().then(displayHighScore).catch(console.error); You can use the async keyword with any kind of function. It works with the function keyword as a statement or as an expression. It works with arrow functions and with the method shortcut form in classes and object literals. (See Chapter 8 for more about the various ways to write functions.) 可以将 async 关键字与任何函数一起使用。它用作于 function 关键字作为语句或表达式。它可与箭头函数以及类和对象字面量中的速记方法方式一起使用。（有关如何编写函数的各种方法，请参见第 8 章。） ","date":"2020-11-02","objectID":"/posts/ch13/:3:2","tags":null,"title":"第 13 章 异步 JavaScript","uri":"/posts/ch13/"},{"categories":null,"content":"13.3.3 Awaiting Multiple Promises Suppose that we’ve written our getJSON() function using async: 假设我们已经使用 async 编写了 getJSON() 函数： async function getJSON(url) { let response = await fetch(url); let body = await response.json(); return body; } And now suppose that we want to fetch two JSON values with this function: 并且现在假设我们要用这个方法获取两个 JSON 值： let value1 = await getJSON(url1); let value2 = await getJSON(url2); The problem with this code is that it is unnecessarily sequential: the fetch of the second URL will not begin until the first fetch is complete. If the second URL does not depend on the value obtained from the first URL, then we should probably try to fetch the two values at the same time. This is a case where the Promise-based nature of async functions shows. In order to await a set of concurrently executing async functions, we use Promise.all() just as we would if working with Promises directly: 此代码的问题在于，它不必要地是连续的：第二个 URL 的获取要等到第一次获取完成后才能开始。如果第二个 URL 不依赖于从第一个 URL 获得的值，那么我们可能应该尝试同时获取两个值。这是基于 Promise 的异步函数本质的一种情况。为了等待一组并发执行的异步函数，我们使用 Promise.all() 就像直接使用 Promise 一样： let [value1, value2] = await Promise.all([getJSON(url1), getJSON(url2)]); ","date":"2020-11-02","objectID":"/posts/ch13/:3:3","tags":null,"title":"第 13 章 异步 JavaScript","uri":"/posts/ch13/"},{"categories":null,"content":"13.3.4 Implementation Details Finally, in order to understand how async functions work, it may help to think about what is going on under the hood. 最后，为了了解异步功能是如何工作的，考虑一下幕后发生了什么可能会有所帮助。 Suppose you write an async function like this: 假设写这样的一个异步函数： async function f(x) { /* body */ } You can think about this as a Promise-returning function wrapped around the body of your original function: 可以将其视为包装原始函数主体的 Promise 返回函数： function f(x) { return new Promise(function(resolve, reject) { try { resolve((function(x) { /* body */ })(x)); } catch(e) { reject(e); } }); } It is harder to express the await keyword in terms of a syntax transformation like this one. But think of the await keyword as a marker that breaks a function body up into separate, synchronous chunks. An ES2017 interpreter can break the function body up into a sequence of separate subfunctions, each of which gets passed to the then() method of the await-marked Promise that precedes it. 用像这样的语法转换来表达 await 关键字比较困难。但是，将 await 关键字视为将函数主体分解为单独的同步块的标记。ES2017 解释器可以将函数主体分解为一系列单独的子函数，每个子函数都传递给位于其前面 await 标记的 Promise 的 then() 方法。 ","date":"2020-11-02","objectID":"/posts/ch13/:3:4","tags":null,"title":"第 13 章 异步 JavaScript","uri":"/posts/ch13/"},{"categories":null,"content":"13.4 Asynchronous Iteration We began this chapter with a discussion of callback- and event-based asynchrony, and when we introduced Promises, we noted that they were useful for single-shot asynchronous computations but were not suitable for use with sources of repetitive asynchronous events, such as setInterval(), the “click” event in a web browser, or the “data” event on a Node stream. Because single Promises do not work for sequences of asynchronous events, we also cannot use regular async functions and the await statements for these things. 在本章的开头我们讨论了基于回调和基于事件的异步，当我们介绍 Promise 时，我们注意到它们对于单次异步计算很有用，但不适用于重复性异步事件的代码，例如 setInterval()，网络浏览器中的“click”事件或 Node 流上的“data”事件。因为单个 Promise 不适用于异步事件序列，所以我们也不能对这些事物使用常规的异步函数和 await 语句。 ES2018 provides a solution, however. Asynchronous iterators are like the iterators described in Chapter 12, but they are Promise-based and are meant to be used with a new form of the for/of loop: for/await. 但是 ES2018 提供了一个解决方案。异步迭代器类似于第 12 章中描述的迭代器，但是它们基于 Promise，并且打算与 for/of 循环一起使用的新形式：for/await。 ","date":"2020-11-02","objectID":"/posts/ch13/:4:0","tags":null,"title":"第 13 章 异步 JavaScript","uri":"/posts/ch13/"},{"categories":null,"content":"13.4.1 The for/await Loop Node 12 makes its readable streams asynchronously iterable. This means you can read successive chunks of data from a stream with a for/await loop like this one: Node 12 使其可读流可以异步迭代。这意味着可以使用如下所示的 for/await 循环从流中读取连续的数据块： const fs = require(\"fs\"); async function parseFile(filename) { let stream = fs.createReadStream(filename, { encoding: \"utf-8\"}); for await (let chunk of stream) { parseChunk(chunk); // Assume parseChunk() is defined elsewhere } } Like a regular await expression, the for/await loop is Promise-based. Roughly speaking, the asynchronous iterator produces a Promise and the for/await loop waits for that Promise to fulfill, assigns the fulfillment value to the loop variable, and runs the body of the loop. And then it starts over, getting another Promise from the iterator and waiting for that new Promise to fulfill. 像普通的 await 表达式一样，for/await 循环是基于 promise 的。粗略地说，异步迭代器产生一个 Promise，for/await 循环等待该 Promise 兑现，将兑现值分配给循环变量，然后运行循环的主体。然后重新开始，从迭代器中获得另一个 Promise，然后等待该新 Promise 兑现。 Suppose you have an array of URLs: 假设有一个 URL 数组： const urls = [url1, url2, url3]; You can call fetch() on each URL to get an array of Promises: 可以在每个 URL 上调用 fetch() 以获取一个 promise 数组： const promises = urls.map(url =\u003e fetch(url)); We saw earlier in the chapter that we could now use Promise.all() to wait for all the Promises in the array to be fulfilled. But suppose we want the results of the first fetch as soon as they become available and don’t want to wait for all the URLs to be fetched. (Of course, the first fetch might take longer than any of the others, so this is not necessarily faster than using Promise.all().) Arrays are iterable, so we can iterate through the array of promises with a regular for/of loop: 我们在本章的前面已经看到，我们现在可以使用 Promise.all() 等待数组中的所有 promise 都已兌現。但是，假设我们希望第一个提取的结果尽快可用，并且不想等待所有 URL 都被获取。（当然，第一次获取可能比其他任何获取都要花费更长的时间，因此不一定比使用 Promise.all() 更快。）数组是可迭代的，因此我们可以使用常规的 for/of 对数组进行遍历： for(const promise of promises) { response = await promise; handle(response); } This example code uses a regular for/of loop with a regular iterator. But because this iterator returns Promises, we can also use the new for/await for slightly simpler code: 此示例代码使用 for/of 循环遍历常规迭代器。但是因为此迭代器返回 Promise，所以我们还可以将新的 for/await 稍微简化下代码： for await (const response of promises) { handle(response); } In this case, the for/await loop just builds the await call into the loop and makes our code slightly more compact, but the two examples do exactly the same thing. Importantly, both examples will only work if they are within functions declared async; a for/await loop is no different than a regular await expression in that way. 在这种情况下，for/await 循环仅将 await 调用构建到循环中，并使我们的代码稍微紧凑一些，但是两个示例的作用完全相同。重要的是，这两个示例只有在声明为异步的函数中时才起作用。for/await 循环与常规 await 表达式没有什么不同。 It is important to realize, however, that we’re using for/await with a regular iterator in this example. Things are more interesting with fully asynchronous iterators. 但是，重要的是要意识到，在此示例中，我们正在使用 for/wait 作用于常规迭代器的。作用于完全异步的迭代器使事情变得更加有趣。 ","date":"2020-11-02","objectID":"/posts/ch13/:4:1","tags":null,"title":"第 13 章 异步 JavaScript","uri":"/posts/ch13/"},{"categories":null,"content":"13.4.2 Asynchronous Iterators Let’s review some terminology from Chapter 12. An iterable object is one that can be used with a for/of loop. It defines a method with the symbolic name Symbol.iterator. This method returns an iterator object. The iterator object has a next() method, which can be called repeatedly to obtain the values of the iterable object. The next() method of the iterator object returns iteration result objects. The iteration result object has a value property and/or a done property. 让我们回顾一下第 12 章中的一些术语。可迭代对象是可以与 for/of 循环一起使用的对象。它定义了一个名称为 Symbol.iterator 的方法。此方法返回一个迭代器对象。迭代器对象具有 next() 方法，可以重复调用该方法以获得可迭代对象的值。迭代器对象的 next() 方法返回迭代结果对象。迭代结果对象具有 value 属性和或或 done 属性。 Asynchronous iterators are quite similar to regular iterators, but there are two important differences. First, an asynchronously iterable object implements a method with the symbolic name Symbol.asyncIterator instead of Symbol.iterator. (As we saw earlier, for/await is compatible with regular iterable objects but it prefers asynchronously iterable objects, and tries the Symbol.asyncIterator method before it tries the Symbol.iterator method.) Second, the next() method of an asynchronous iterator returns a Promise that resolves to an iterator result object instead of returning an iterator result object directly. 异步迭代器与常规迭代器非常相似，但是有两个重要的区别。 首先，一个异步可迭代对象以符号名称 Symbol.asyncIterator 而不是 Symbol.iterator 实现一个方法。（如前所述，for/await 与常规可迭代对象兼容，但是它更喜欢异步可迭代对象，并在尝试 Symbol.iterator 方法之前先尝试使用 Symbol.asyncIterator 方法。）其次，异步迭代器的 next() 方法返回解析为迭代器结果对象的 Promise，而不是直接返回迭代器结果对象。 NOTE In the previous section, when we used for/await on a regular, synchronously iterable array of Promises, we were working with synchronous iterator result objects in which the value property was a Promise object but the done property was synchronous. True asynchronous iterators return Promises for iteration result objects, and both the value and the done properties are asynchronous. The difference is a subtle one: with asynchronous iterators, the choice about when iteration ends can be made asynchronously. 在上一节中，当我们在常规的、同步可迭代的 Promise 数组上使用 for/await 时，我们正在使用同步迭代器结果对象，其中 value 属性是 Promise 对象，但 done 属性是同步的。真正的异步迭代器为迭代结果对象返回 Promise，并且 value 和 done 属性都是异步的。这是一个微妙的区别：使用异步迭代器，可以异步选择何时结束迭代。 ","date":"2020-11-02","objectID":"/posts/ch13/:4:2","tags":null,"title":"第 13 章 异步 JavaScript","uri":"/posts/ch13/"},{"categories":null,"content":"13.4.3 Asynchronous Generators As we saw in Chapter 12, the easiest way to implement an iterator is often to use a generator. The same is true for asynchronous iterators, which we can implement with generator functions that we declare async. An async generator has the features of async functions and the features of generators: you can use await as you would in a regular async function, and you can use yield as you would in a regular generator. But values that you yield are automatically wrapped in Promises. Even the syntax for async generators is a combination: async function and function * combine into async function *. Here is an example that shows how you might use an async generator and a for/await loop to repetitively run code at fixed intervals using loop syntax instead of a setInterval() callback function: 正如我们在第 12 章中看到的那样，实现迭代器的最简单方法通常是使用生成器。异步迭代器也是如此，我们可以使用声明为异步的生成器函数来实现。异步生成器具有异步特性和生成器特性：可以像在常规异步函数中一样使用 await，并且可以像在常规生成器中一样使用 yield。但是，产生的值会自动包装在 Promise 中。甚至异步生成器的语法也是一个组合：异步函数和 function* 组合为 async function*。这是一个示例，描述如何使用异步生成器和 for/await 循环代替 setInterval() 回调函数以固定的间隔重复运行代码： // A Promise-based wrapper around setTimeout() that we can use await with. // Returns a Promise that fulfills in the specified number of milliseconds function elapsedTime(ms) { return new Promise(resolve =\u003e setTimeout(resolve, ms)); } // An async generator function that increments a counter and yields it // a specified (or infinite) number of times at a specified interval. async function* clock(interval, max=Infinity) { for(let count = 1; count \u003c= max; count++) { // regular for loop await elapsedTime(interval); // wait for time to pass yield count; // yield the counter } } // A test function that uses the async generator with for/await async function test() { // Async so we can use for/await for await (let tick of clock(300, 100)) { // Loop 100 times every 300ms console.log(tick); } } ","date":"2020-11-02","objectID":"/posts/ch13/:4:3","tags":null,"title":"第 13 章 异步 JavaScript","uri":"/posts/ch13/"},{"categories":null,"content":"13.4.4 Implementing Asynchronous Iterators Instead of using async generators to implement asynchronous iterators, it is also possible to implement them directly by defining an object with a Symbol.asyncIterator() method that returns an object with a next() method that returns a Promise that resolves to an iterator result object. In the following code, we re-implement the clock() function from the preceding example so that it is not a generator and instead just returns an asynchronously iterable object. Notice that the next() method in this example does not explicitly return a Promise; instead, we just declare next() to be async: 除了使用异步生成器来实现异步迭代器外，还可以通过使用 Symbol.asyncIterator() 方法定义一个对象来直接实现它们，而 Symbol.asyncIterator() 方法将返回一个对象，而 next() 方法将返回一个决议为迭代器结果对象的 Promise。在下面的代码中，我们重新实现了上一个示例中的 clock() 函数，因此它不是生成器，而仅是返回一个异步可迭代的对象。请注意，此示例中的 next() 方法未明确返回 Promise；相反，我们只声明 next() 是异步的： function clock(interval, max=Infinity) { // A Promise-ified version of setTimeout that we can use await with. // Note that this takes an absolute time instead of an interval. function until(time) { return new Promise(resolve =\u003e setTimeout(resolve, time - Date.now())); } // Return an asynchronously iterable object return { startTime: Date.now(), // Remember when we started count: 1, // Remember which iteration we're on async next() { // The next() method makes this an iterator if (this.count \u003e max) { // Are we done? return { done: true }; // Iteration result indicating done } // Figure out when the next iteration should begin, let targetTime = this.startTime + this.count * interval; // wait until that time, await until(targetTime); // and return the count value in an iteration result object. return { value: this.count++ }; }, // This method means that this iterator object is also an iterable. [Symbol.asyncIterator]() { return this; } }; } This iterator-based version of the clock() function fixes a flaw in the generator-based version. Note that, in this newer code, we target the absolute time at which each iteration should begin and subtract the current time from that in order to compute the interval that we pass to setTimeout(). If we use clock() with a for/await loop, this version will run loop iterations more precisely at the specified interval because it accounts for the time required to actually run the body of the loop. But this fix isn’t just about timing accuracy. The for/await loop always waits for the Promise returned by one iteration to be fulfilled before it begins the next iteration. But if you use an asynchronous iterator without a for/await loop, there is nothing to prevent you from calling the next() method whenever you want. With the generator-based version of clock(), if you call the next() method three times sequentially, you’ll get three Promises that will all fulfill at almost exactly the same time, which is probably not what you want. The iterator-based version we’ve implemented here does not have that problem. 这个基于迭代器版本的 clock() 函数修复了基于生成器版本中的一个缺陷。请注意，在此代码中，我们在每次迭代开始时设置了绝对目标时间，并将其与当前时间的差值作为间隔传递给 setTimeout()。如果我们将 clock() 与 for/await 循环一起使用，则此版本将在指定的时间间隔内更精确地运行循环迭代，因为它考虑了实际运行循环主体所需的时间。但是，此修补程序不仅涉及定时精度。for/await 循环始终在开始下一次迭代之前等待一次迭代返回的 Promise 被兑现。但是，如果使用不带 for/await 循环的异步迭代器，则没有什么可以阻止在需要时调用 next() 方法。使用基于生成器的 clock() 版本，如果依次调用 next() 方法三遍，将获得三个 Promise，这些 Promise 几乎都在同一时间完成，这可能不是想要的结果。我们在这里实现的基于迭代器的版本没有这个问题。 The benefit of asynchronous iterators is that they allow us to represent streams of asynchronous events or data. The clock() function discussed previously was fairly simple to write because the source of the asynchrony was the setTimeout() calls we were making ourselves. But when we are trying to work with other asynchronous sources, such as the triggering of event handlers, it becomes substantially harder to implement asynchronous iterators—we typically have a single event handler function that responds to events, but each call to the iterator’s next() method must return a distinct Promise object, and multiple calls to next() may ","date":"2020-11-02","objectID":"/posts/ch13/:4:4","tags":null,"title":"第 13 章 异步 JavaScript","uri":"/posts/ch13/"},{"categories":null,"content":"13.5 Summary In this chapter, you have learned: 在本章中，您学习了： Most real-world JavaScript programming is asynchronous. 大多数真实的 JavaScript 程序都是异步的。 Traditionally, asynchrony has been handled with events and callback functions. This can get complicated, however, because you can end up with multiple levels of callbacks nested inside other callbacks, and because it is difficult to do robust error handling. 传统上，异步是通过事件和回调函数来处理的。但是，这可能会变得复杂，因为最终可能会嵌套在其他回调中嵌套的多个级别的回调，并且因为很难进行可靠的异常处理。 Promises provide a new way of structuring callback functions. If used correctly (and unfortunately, Promises are easy to use incorrectly), they can convert asynchronous code that would have been nested into linear chains of then() calls where one asynchronous step of a computation follows another. Also, Promises allow you to centralize your error-handling code into a single catch() call at the end of a chain of then() calls. Promise 提供了构造回调函数的新方法。如果正确使用（不幸的是，Promise 易于错误使用），它们可以将异步代码转换为嵌套在调用 then() 的线性链中的代码，一个计算的异步步骤跟随在其他之后。而且，Promise 允许将异常处理代码集中到一个 then() 调用链末尾的单个 catch() 调用中。 The async and await keywords allow us to write asynchronous code that is Promise-based under the hood but that looks like synchronous code. This makes the code easier to understand and reason about. If a function is declared async, it will implicitly return a Promise. Inside an async function, you can await a Promise (or a function that returns a Promise) as if the Promise value was synchronously computed. async 和 await 关键字允许我们编写异步代码，该代码基于 Promise，但看起来像同步代码。这使代码更易于理解和推理。如果一个函数被声明为 async，它将隐式返回一个 Promise。在异步函数内部，可以 await Promise（或返回 Promise 的函数），就像 Promise 值是同步计算的一样。 Objects that are asynchronously iterable can be used with a for/await loop. You can create asynchronously iterable objects by implementing a Symbol.asyncIterator method or by invoking an async function * generator function. Asynchronous iterators provide an alternative to “data” events on streams in Node and can be used to represent a stream of user input events in client-side JavaScript. 异步可迭代的对象可以与 for/await 循环一起使用。可以通过实现 [Symbol.asyncIterator]() 方法或调用 async function* 生成器函数来创建异步可迭代对象。异步迭代器为 Node 中流的“data”事件提供了一种替代方法，可用于表示客户端 JavaScript 中的用户输入事件的流。 The XMLHttpRequest class has nothing in particular to do with XML. In modern client-side JavaScript, it has largely been replaced by the fetch() API, which is covered in §15.11.1. The code example shown here is the last XMLHttpRequest-based example remaining in this book. ↩︎ You can typically use await at the top level in a browser’s developer console. And there is a pending proposal to allow top-level await in a future version of JavaScript. ↩︎ I learned about this approach to asynchronous iteration from the blog of Dr. Axel Rauschmayer, https://2ality.com. ↩︎ ","date":"2020-11-02","objectID":"/posts/ch13/:5:0","tags":null,"title":"第 13 章 异步 JavaScript","uri":"/posts/ch13/"},{"categories":null,"content":"This chapter covers a number of advanced JavaScript features that are not commonly used in day-to-day programming but that may be valuable to programmers writing reusable libraries and of interest to anyone who wants to tinker with the details about how JavaScript objects behave. 本章涵盖了一些高级的JavaScript特性，这些特性在日常编程中并不常用，但对于编写可重用库的程序员来说可能很有价值，对于那些想要修改JavaScript对象行为细节的人来说也很有兴趣。 Many of the features described here can loosely be described as “metaprogramming”: if regular programming is writing code to manipulate data, then metaprogramming is writing code to manipulate other code. In a dynamic language like JavaScript, the lines between programming and metaprogramming are blurry—even the simple ability to iterate over the properties of an object with a for/in loop might be considered “meta” by programmers accustomed to more static languages. 这里描述的许多特性可以粗略地描述为“元编程”:如果常规编程是编写代码来操作数据，那么元编程就是编写代码来操作其他代码。在像JavaScript这样的动态语言中，编程和元编程之间的界限是模糊的——即使是使用for/ In循环迭代对象属性的简单能力，对于习惯了更多静态语言的程序员来说也可能被认为是“元”的。 The metaprogramming topics covered in this chapter include: 本章涉及的元编程主题包括: §14.1 Controlling the enumerability, deleteability, and configurability of object properties §14.2 Controlling the extensibility of objects, and creating “sealed” and “frozen” objects §14.3 Querying and setting the prototypes of objects §14.4 Fine-tuning the behavior of your types with well-known Symbols §14.5 Creating DSLs (domain-specific languages) with template tag functions §14.6 Probing objects with reflect methods §14.7 Controlling object behavior with Proxy §14.1控制对象属性的可枚举性、可删除性和可配置性 §14.2控制对象的可扩展性，并创建“密封”和“冻结”对象 §14.3查询和设置对象的原型 §14.4用众所周知的符号微调类型的行为 §14.5用模板标签函数创建dsl(领域特定语言 §14.6用反射方法探测对象 §14.7用代理控制对象行为 ","date":"2020-11-02","objectID":"/posts/ch14/:0:0","tags":null,"title":"第 14 章 元编程","uri":"/posts/ch14/"},{"categories":null,"content":"14.1 Property Attributes The properties of a JavaScript object have names and values, of course, but each property also has three associated attributes that specify how that property behaves and what you can do with it: 当然，JavaScript对象的属性有名称和值，但是每个属性也有三个相关的属性，它们指定属性的行为方式以及你可以用它做什么: The writable attribute specifies whether or not the value of a property can change. The enumerable attribute specifies whether the property is enumerated by the for/in loop and the Object.keys() method. The configurable attribute specifies whether a property can be deleted and also whether the property’s attributes can be changed. writable属性指定属性的值是否可以更改。 enumerable属性指定该属性是否由for/in循环和Object.keys()方法枚举。 可配置属性指定是否一个属性可以删除，也是否属性的属性可以改变。 Properties defined in object literals or by ordinary assignment to an object are writable, enumerable, and configurable. But many of the properties defined by the JavaScript standard library are not. 用对象文本或通过对对象的普通赋值定义的属性是可写的、可枚举的和可配置的。但是JavaScript标准库定义的许多属性不是这样的。 This section explains the API for querying and setting property attributes. This API is particularly important to library authors because: 本节解释用于查询和设置属性属性的API。这个API对于库的作者来说特别重要，因为: It allows them to add methods to prototype objects and make them non-enumerable, like built-in methods. It allows them to “lock down” their objects, defining properties that cannot be changed or deleted. 它允许向原型对象添加方法并使其不可枚举，就像内置方法一样。 它允许他们“锁定”他们的对象，定义不能改变或删除的属性。 Recall from §6.10.6 that, while “data properties” have a value, “accessor properties” have a getter and/or a setter method instead. For the purposes of this section, we are going to consider the getter and setter methods of an accessor property to be property attributes. Following this logic, we’ll even say that the value of a data property is an attribute as well. Thus, we can say that a property has a name and four attributes. The four attributes of a data property are value, writable, enumerable, and configurable. Accessor properties don’t have a value attribute or a writable attribute: their writability is determined by the presence or absence of a setter. So the four attributes of an accessor property are get, set, enumerable, and configurable. The JavaScript methods for querying and setting the attributes of a property use an object called a property descriptor to represent the set of four attributes. A property descriptor object has properties with the same names as the attributes of the property it describes. Thus, the property descriptor object of a data property has properties named value, writable, enumerable, and configurable. And the descriptor for an accessor property has get and set properties instead of value and writable. The writable, enumerable, and configurable properties are boolean values, and the get and set properties are function values. To obtain the property descriptor for a named property of a specified object, call Object.getOwnPropertyDescriptor(): // Returns {value: 1, writable:true, enumerable:true, configurable:true} Object.getOwnPropertyDescriptor({x: 1}, \"x\"); // Here is an object with a read-only accessor property const random = { get octet() { return Math.floor(Math.random()*256); }, }; // Returns { get: /*func*/, set:undefined, enumerable:true, configurable:true} Object.getOwnPropertyDescriptor(random, \"octet\"); // Returns undefined for inherited properties and properties that don't exist. Object.getOwnPropertyDescriptor({}, \"x\") // =\u003e undefined; no such prop Object.getOwnPropertyDescriptor({}, \"toString\") // =\u003e undefined; inherited As its name implies, Object.getOwnPropertyDescriptor() works only for own properties. To query the attributes of inherited properties, you must explicitly traverse the prototype chain. (See Object.getPrototypeOf() in §14.3); see also the similar Reflect.getOwnPropertyDescriptor() function in §14.6.) To set the attributes of a property or to create a new property with the specified attributes, call Object.defineProperty(), passing the object to be modified, the","date":"2020-11-02","objectID":"/posts/ch14/:1:0","tags":null,"title":"第 14 章 元编程","uri":"/posts/ch14/"},{"categories":null,"content":"14.2 Object Extensibility The extensible attribute of an object specifies whether new properties can be added to the object or not. Ordinary JavaScript objects are extensible by default, but you can change that with the functions described in this section. To determine whether an object is extensible, pass it to Object.isExtensible(). To make an object non-extensible, pass it to Object.preventExtensions(). Once you have done this, any attempt to add a new property to the object will throw a TypeError in strict mode and simply fail silently without an error in non-strict mode. In addition, attempting to change the prototype (see §14.3) of a non-extensible object will always throw a TypeError. Note that there is no way to make an object extensible again once you have made it non-extensible. Also note that calling Object.preventExtensions() only affects the extensibility of the object itself. If new properties are added to the prototype of a non-extensible object, the non-extensible object will inherit those new properties. Two similar functions, Reflect.isExtensible() and Reflect.preventExtensions(), are described in §14.6. The purpose of the extensible attribute is to be able to “lock down” objects into a known state and prevent outside tampering. The extensible attribute of objects is often used in conjunction with the configurable and writable attributes of properties, and JavaScript defines functions that make it easy to set these attributes together: Object.seal() works like Object.preventExtensions(), but in addition to making the object non-extensible, it also makes all of the own properties of that object nonconfigurable. This means that new properties cannot be added to the object, and existing properties cannot be deleted or configured. Existing properties that are writable can still be set, however. There is no way to unseal a sealed object. You can use Object.isSealed() to determine whether an object is sealed. Object.freeze() locks objects down even more tightly. In addition to making the object non-extensible and its properties nonconfigurable, it also makes all of the object’s own data properties read-only. (If the object has accessor properties with setter methods, these are not affected and can still be invoked by assignment to the property.) Use Object.isFrozen() to determine if an object is frozen. It is important to understand that Object.seal() and Object.freeze() affect only the object they are passed: they have no effect on the prototype of that object. If you want to thoroughly lock down an object, you probably need to seal or freeze the objects in the prototype chain as well. Object.preventExtensions(), Object.seal(), and Object.freeze() all return the object that they are passed, which means that you can use them in nested function invocations: // Create a sealed object with a frozen prototype and a non-enumerable property let o = Object.seal(Object.create(Object.freeze({x: 1}), {y: {value: 2, writable: true}})); If you are writing a JavaScript library that passes objects to callback functions written by the users of your library, you might use Object.freeze() on those objects to prevent the user’s code from modifying them. This is easy and convenient to do, but there are trade-offs: frozen objects can interfere with common JavaScript testing strategies, for example. ","date":"2020-11-02","objectID":"/posts/ch14/:2:0","tags":null,"title":"第 14 章 元编程","uri":"/posts/ch14/"},{"categories":null,"content":"14.3 The prototype Attribute An object’s prototype attribute specifies the object from which it inherits properties. (Review §6.2.3 and §6.3.2 for more on prototypes and property inheritance.) This is such an important attribute that we usually simply say “the prototype of o\" rather than “the prototype attribute of o.” Remember also that when prototype appears in code font, it refers to an ordinary object property, not to the prototype attribute: Chapter 9 explained that the prototype property of a constructor function specifies the prototype attribute of the objects created with that constructor. The prototype attribute is set when an object is created. Objects created from object literals use Object.prototype as their prototype. Objects created with new use the value of the prototype property of their constructor function as their prototype. And objects created with Object.create() use the first argument to that function (which may be null) as their prototype. You can query the prototype of any object by passing that object to Object.getPrototypeOf(): Object.getPrototypeOf({}) // =\u003e Object.prototype Object.getPrototypeOf([]) // =\u003e Array.prototype Object.getPrototypeOf(()=\u003e{}) // =\u003e Function.prototype A very similar function, Reflect.getPrototypeOf(), is described in §14.6. To determine whether one object is the prototype of (or is part of the prototype chain of) another object, use the isPrototypeOf() method: let p = {x: 1}; // Define a prototype object. let o = Object.create(p); // Create an object with that prototype. p.isPrototypeOf(o) // =\u003e true: o inherits from p Object.prototype.isPrototypeOf(p) // =\u003e true: p inherits from Object.prototype Object.prototype.isPrototypeOf(o) // =\u003e true: o does too Note that isPrototypeOf() performs a function similar to the instanceof operator (see §4.9.4). The prototype attribute of an object is set when the object is created and normally remains fixed. You can, however, change the prototype of an object with Object.setPrototypeOf(): let o = {x: 1}; let p = {y: 2}; Object.setPrototypeOf(o, p); // Set the prototype of o to p o.y // =\u003e 2: o now inherits the property y let a = [1, 2, 3]; Object.setPrototypeOf(a, p); // Set the prototype of array a to p a.join // =\u003e undefined: a no longer has a join() method There is generally no need to ever use Object.setPrototypeOf(). JavaScript implementations may make aggressive optimizations based on the assumption that the prototype of an object is fixed and unchanging. This means that if you ever call Object.setPrototypeOf(), any code that uses the altered objects may run much slower than it would normally. A similar function, Reflect.setPrototypeOf(), is described in §14.6. Some early browser implementations of JavaScript exposed the prototype attribute of an object through the proto property (written with two underscores at the start and end). This has long since been deprecated, but enough existing code on the web depends on proto that the ECMAScript standard mandates it for all JavaScript implementations that run in web browsers. (Node supports it, too, though the standard does not require it for Node.) In modern JavaScript, proto is readable and writeable, and you can (though you shouldn’t) use it as an alternative to Object.getPrototypeOf() and Object.setPrototypeOf(). One interesting use of proto, however, is to define the prototype of an object literal: let p = {z: 3}; let o = { x: 1, y: 2, __proto__: p }; o.z // =\u003e 3: o inherits from p ","date":"2020-11-02","objectID":"/posts/ch14/:3:0","tags":null,"title":"第 14 章 元编程","uri":"/posts/ch14/"},{"categories":null,"content":"14.4 Well-Known Symbols The Symbol type was added to JavaScript in ES6, and one of the primary reasons for doing so was to safely add extensions to the language without breaking compatibility with code already deployed on the web. We saw an example of this in Chapter 12, where we learned that you can make a class iterable by implementing a method whose “name” is the Symbol Symbol.iterator. Symbol.iterator is the best-known example of the “well-known Symbols.” These are a set of Symbol values stored as properties of the Symbol() factory function that are used to allow JavaScript code to control certain low-level behaviors of objects and classes. The subsections that follow describe each of these well-known Symbols and explain how they can be used. ","date":"2020-11-02","objectID":"/posts/ch14/:4:0","tags":null,"title":"第 14 章 元编程","uri":"/posts/ch14/"},{"categories":null,"content":"14.4.1 Symbol.iterator and Symbol.asyncIterator The Symbol.iterator and Symbol.asyncIterator Symbols allow objects or classes to make themselves iterable or asynchronously iterable. They were covered in detail in Chapter 12 and §13.4.2, respectively, and are mentioned again here only for completeness. ","date":"2020-11-02","objectID":"/posts/ch14/:4:1","tags":null,"title":"第 14 章 元编程","uri":"/posts/ch14/"},{"categories":null,"content":"14.4.2 Symbol.hasInstance When the instanceof operator was described in §4.9.4, we said that the righthand side must be a constructor function and that the expression o instanceof f was evaluated by looking for the value f.prototype within the prototype chain of o. That is still true, but in ES6 and beyond, Symbol.hasInstance provides an alternative. In ES6, if the righthand side of instanceof is any object with a [Symbol.hasInstance] method, then that method is invoked with the lefthand side value as its argument, and the return value of the method, converted to a boolean, becomes the value of the instanceof operator. And, of course, if the value on the righthand side does not have a [Symbol.hasInstance] method but is a function, then the instanceof operator behaves in its ordinary way. Symbol.hasInstance means that we can use the instanceof operator to do generic type checking with suitably defined pseudotype objects. For example: // Define an object as a \"type\" we can use with instanceof let uint8 = { [Symbol.hasInstance](x) { return Number.isInteger(x) \u0026\u0026 x \u003e= 0 \u0026\u0026 x \u003c= 255; } }; 128 instanceof uint8 // =\u003e true 256 instanceof uint8 // =\u003e false: too big Math.PI instanceof uint8 // =\u003e false: not an integer Note that this example is clever but confusing because it uses a nonclass object where a class would normally be expected. It would be just as easy—and clearer to readers of your code—to write a isUint8() function instead of relying on this Symbol.hasInstance behavior. ","date":"2020-11-02","objectID":"/posts/ch14/:4:2","tags":null,"title":"第 14 章 元编程","uri":"/posts/ch14/"},{"categories":null,"content":"14.4.3 Symbol.toStringTag If you invoke the toString() method of a basic JavaScript object, you get the string “[object Object]”: {}.toString() // =\u003e \"[object Object]\" If you invoke this same Object.prototype.toString() function as a method of instances of built-in types, you get some interesting results: Object.prototype.toString.call([]) // =\u003e \"[object Array]\" Object.prototype.toString.call(/./) // =\u003e \"[object RegExp]\" Object.prototype.toString.call(()=\u003e{}) // =\u003e \"[object Function]\" Object.prototype.toString.call(\"\") // =\u003e \"[object String]\" Object.prototype.toString.call(0) // =\u003e \"[object Number]\" Object.prototype.toString.call(false) // =\u003e \"[object Boolean]\" It turns out that you can use this Object.prototype.toString().call() technique with any JavaScript value to obtain the “class attribute” of an object that contains type information that is not otherwise available. The following classof() function is arguably more useful than the typeof operator, which makes no distinction between types of objects: function classof(o) { return Object.prototype.toString.call(o).slice(8,-1); } classof(null) // =\u003e \"Null\" classof(undefined) // =\u003e \"Undefined\" classof(1) // =\u003e \"Number\" classof(10n**100n) // =\u003e \"BigInt\" classof(\"\") // =\u003e \"String\" classof(false) // =\u003e \"Boolean\" classof(Symbol()) // =\u003e \"Symbol\" classof({}) // =\u003e \"Object\" classof([]) // =\u003e \"Array\" classof(/./) // =\u003e \"RegExp\" classof(()=\u003e{}) // =\u003e \"Function\" classof(new Map()) // =\u003e \"Map\" classof(new Set()) // =\u003e \"Set\" classof(new Date()) // =\u003e \"Date\" Prior to ES6, this special behavior of the Object.prototype.toString() method was available only to instances of built-in types, and if you called this classof() function on an instance of a class you had defined yourself, it would simply return “Object”. In ES6, however, Object.prototype.toString() looks for a property with the symbolic name Symbol.toStringTag on its argument, and if such a property exists, it uses the property value in its output. This means that if you define a class of your own, you can easily make it work with functions like classof(): class Range { get [Symbol.toStringTag]() { return \"Range\"; } // the rest of this class is omitted here } let r = new Range(1, 10); Object.prototype.toString.call(r) // =\u003e \"[object Range]\" classof(r) // =\u003e \"Range\" ","date":"2020-11-02","objectID":"/posts/ch14/:4:3","tags":null,"title":"第 14 章 元编程","uri":"/posts/ch14/"},{"categories":null,"content":"14.4.4 Symbol.species Prior to ES6, JavaScript did not provide any real way to create robust subclasses of built-in classes like Array. In ES6, however, you can extend any built-in class simply by using the class and extends keywords. §9.5.2 demonstrated that with this simple subclass of Array: // A trivial Array subclass that adds getters for the first and last elements. class EZArray extends Array { get first() { return this[0]; } get last() { return this[this.length-1]; } } let e = new EZArray(1,2,3); let f = e.map(x =\u003e x * x); e.last // =\u003e 3: the last element of EZArray e f.last // =\u003e 9: f is also an EZArray with a last property Array defines methods concat(), filter(), map(), slice(), and splice(), which return arrays. When we create an array subclass like EZArray that inherits these methods, should the inherited method return instances of Array or instances of EZArray? Good arguments can be made for either choice, but the ES6 specification says that (by default) the five array-returning methods will return instances of the subclass. Here’s how it works: In ES6 and later, the Array() constructor has a property with the symbolic name Symbol.species. (Note that this Symbol is used as the name of a property of the constructor function. Most of the other well-known Symbols described here are used as the name of methods of a prototype object.) When we create a subclass with extends, the resulting subclass constructor inherits properties from the superclass constructor. (This is in addition to the normal kind of inheritance, where instances of the subclass inherit methods of the superclass.) This means that the constructor for every subclass of Array also has an inherited property with name Symbol.species. (Or a subclass can define its own property with this name, if it wants.) Methods like map() and slice() that create and return new arrays are tweaked slightly in ES6 and later. Instead of just creating a regular Array, they (in effect) invoke new this.constructorSymbol.species to create the new array. Now here’s the interesting part. Suppose that Array[Symbol.species] was just a regular data property, defined like this: Array[Symbol.species] = Array; In that case, then subclass constructors would inherit the Array() constructor as their “species,” and invoking map() on an array subclass would return an instance of the superclass rather than an instance of the subclass. That is not how ES6 actually behaves, however. The reason is that Array[Symbol.species] is a read-only accessor property whose getter function simply returns this. Subclass constructors inherit this getter function, which means that by default, every subclass constructor is its own “species.” Sometimes this default behavior is not what you want, however. If you wanted the array-returning methods of EZArray to return regular Array objects, you just need to set EZArray[Symbol.species] to Array. But since the inherited property is a read-only accessor, you can’t just set it with an assignment operator. You can use defineProperty(), however: EZArray[Symbol.species] = Array; // Attempt to set a read-only property fails // Instead we can use defineProperty(): Object.defineProperty(EZArray, Symbol.species, {value: Array}); The simplest option is probably to explicitly define your own Symbol.species getter when creating the subclass in the first place: class EZArray extends Array { static get [Symbol.species]() { return Array; } get first() { return this[0]; } get last() { return this[this.length-1]; } } let e = new EZArray(1,2,3); let f = e.map(x =\u003e x - 1); e.last // =\u003e 3 f.last // =\u003e undefined: f is a regular array with no last getter Creating useful subclasses of Array was the primary use case that motivated the introduction of Symbol.species, but it is not the only place that this well-known Symbol is used. Typed array classes use the Symbol in the same way that the Array class does. Similarly, the slice() method of ArrayBuffer looks at the Symbol.species property ","date":"2020-11-02","objectID":"/posts/ch14/:4:4","tags":null,"title":"第 14 章 元编程","uri":"/posts/ch14/"},{"categories":null,"content":"14.4.5 Symbol.isConcatSpreadable The Array method concat() is one of the methods described in the previous section that uses Symbol.species to determine what constructor to use for the returned array. But concat() also uses Symbol.isConcatSpreadable. Recall from §7.8.3 that the concat() method of an array treats its this value and its array arguments differently than its nonarray arguments: nonarray arguments are simply appended to the new array, but the this array and any array arguments are flattened or “spread” so that the elements of the array are concatenated rather than the array argument itself. Before ES6, concat() just used Array.isArray() to determine whether to treat a value as an array or not. In ES6, the algorithm is changed slightly: if the argument (or the this value) to concat() is an object and has a property with the symbolic name Symbol.isConcatSpreadable, then the boolean value of that property is used to determine whether the argument should be “spread.” If no such property exists, then Array.isArray() is used as in previous versions of the language. There are two cases when you might want to use this Symbol: If you create an Array-like (see §7.9) object and want it to behave like a real array when passed to concat(), you can simply add the symbolic property to your object: let arraylike = { length: 1, 0: 1, [Symbol.isConcatSpreadable]: true }; [].concat(arraylike) // =\u003e [1]: (would be [[1]] if not spread) Array subclasses are spreadable by default, so if you are defining an array subclass that you do not want to act like an array when used with concat(), then you can1 add a getter like this to your subclass: class NonSpreadableArray extends Array { get [Symbol.isConcatSpreadable]() { return false; } } let a = new NonSpreadableArray(1,2,3); [].concat(a).length // =\u003e 1; (would be 3 elements long if a was spread) ","date":"2020-11-02","objectID":"/posts/ch14/:4:5","tags":null,"title":"第 14 章 元编程","uri":"/posts/ch14/"},{"categories":null,"content":"14.4.6 Pattern-Matching Symbols §11.3.2 documented the String methods that perform pattern-matching operations using a RegExp argument. In ES6 and later, these methods have been generalized to work with RegExp objects or any object that defines pattern-matching behavior via properties with symbolic names. For each of the string methods match(), matchAll(), search(), replace(), and split(), there is a corresponding well-known Symbol: Symbol.match, Symbol.search, and so on. RegExps are a general and very powerful way to describe textual patterns, but they can be complicated and not well suited to fuzzy matching. With the generalized string methods, you can define your own pattern classes using the well-known Symbol methods to provide custom matching. For example, you could perform string comparisons using Intl.Collator (see §11.7.3) to ignore accents when matching. Or you could define a pattern class based on the Soundex algorithm to match words based on their approximate sounds or to loosely match strings up to a given Levenshtein distance. In general, when you invoke one of these five String methods on a pattern object like this: string.method(pattern, arg) that invocation turns into an invocation of a symbolically named method on your pattern object: pattern[symbol](string, arg) As an example, consider the pattern-matching class in the next example, which implements pattern matching using the simple * and ? wildcards that you are probably familar with from filesystems. This style of pattern matching dates back to the very early days of the Unix operating system, and the patterns are often called globs: class Glob { constructor(glob) { this.glob = glob; // We implement glob matching using RegExp internally. // ? matches any one character except /, and * matches zero or more // of those characters. We use capturing groups around each. let regexpText = glob.replace(\"?\", \"([^/])\").replace(\"*\", \"([^/]*)\"); // We use the u flag to get Unicode-aware matching. // Globs are intended to match entire strings, so we use the ^ and $ // anchors and do not implement search() or matchAll() since they // are not useful with patterns like this. this.regexp = new RegExp(`^${regexpText}$`, \"u\"); } toString() { return this.glob; } [Symbol.search](s) { return s.search(this.regexp); } [Symbol.match](s) { return s.match(this.regexp); } [Symbol.replace](s, replacement) { return s.replace(this.regexp, replacement); } } let pattern = new Glob(\"docs/*.txt\"); \"docs/js.txt\".search(pattern) // =\u003e 0: matches at character 0 \"docs/js.htm\".search(pattern) // =\u003e -1: does not match let match = \"docs/js.txt\".match(pattern); match[0] // =\u003e \"docs/js.txt\" match[1] // =\u003e \"js\" match.index // =\u003e 0 \"docs/js.txt\".replace(pattern, \"web/$1.htm\") // =\u003e \"web/js.htm\" ","date":"2020-11-02","objectID":"/posts/ch14/:4:6","tags":null,"title":"第 14 章 元编程","uri":"/posts/ch14/"},{"categories":null,"content":"14.4.7 Symbol.toPrimitive §3.9.3 explained that JavaScript has three slightly different algorithms for converting objects to primitive values. Loosely speaking, for conversions where a string value is expected or preferred, JavaScript invokes an object’s toString() method first and falls back on the valueOf() method if toString() is not defined or does not return a primitive value. For conversions where a numeric value is preferred, JavaScript tries the valueOf() method first and falls back on toString() if valueOf() is not defined or if it does not return a primitive value. And finally, in cases where there is no preference, it lets the class decide how to do the conversion. Date objects convert using toString() first, and all other types try valueOf() first. In ES6, the well-known Symbol Symbol.toPrimitive allows you to override this default object-to-primitive behavior and gives you complete control over how instances of your own classes will be converted to primitive values. To do this, define a method with this symbolic name. The method must return a primitive value that somehow represents the object. The method you define will be invoked with a single string argument that tells you what kind of conversion JavaScript is trying to do on your object: If the argument is “string”, it means that JavaScript is doing the conversion in a context where it would expect or prefer (but not require) a string. This happens when you interpolate the object into a template literal, for example. If the argument is “number”, it means that JavaScript is doing the conversion in a context where it would expect or prefer (but not require) a numeric value. This happens when you use the object with a \u003c or \u003e operator or with arithmetic operators like - and *. If the argument is “default”, it means that JavaScript is converting your object in a context where either a numeric or string value could work. This happens with the +, ==, and != operators. Many classes can ignore the argument and simply return the same primitive value in all cases. If you want instances of your class to be comparable and sortable with \u003c and \u003e, then that is a good reason to define a [Symbol.toPrimitive] method. ","date":"2020-11-02","objectID":"/posts/ch14/:4:7","tags":null,"title":"第 14 章 元编程","uri":"/posts/ch14/"},{"categories":null,"content":"14.4.8 Symbol.unscopables The final well-known Symbol that we’ll cover here is an obscure one that was introduced as a workaround for compatibility issues caused by the deprecated with statement. Recall that the with statement takes an object and executes its statement body as if it were in a scope where the properties of that object were variables. This caused compatibility problems when new methods were added to the Array class, and it broke some existing code. Symbol.unscopables is the result. In ES6 and later, the with statement has been slightly modified. When used with an object o, a with statement computes Object.keys(o[Symbol.unscopables]||{}) and ignores properties whose names are in the resulting array when creating the simulated scope in which to execute its body. ES6 uses this to add new methods to Array.prototype without breaking existing code on the web. This means that you can find a list of the newest Array methods by evaluating: let newArrayMethods = Object.keys(Array.prototype[Symbol.unscopables]); ","date":"2020-11-02","objectID":"/posts/ch14/:4:8","tags":null,"title":"第 14 章 元编程","uri":"/posts/ch14/"},{"categories":null,"content":"14.5 Template Tags Strings within backticks are known as “template literals” and were covered in §3.3.4. When an expression whose value is a function is followed by a template literal, it turns into a function invocation, and we call it a “tagged template literal.” Defining a new tag function for use with tagged template literals can be thought of as metaprogramming, because tagged templates are often used to define DSLs—domain-specific languages—and defining a new tag function is like adding new syntax to JavaScript. Tagged template literals have been adopted by a number of frontend JavaScript packages. The GraphQL query language uses a gql tag function to allow queries to be embedded within JavaScript code. And the Emotion library uses a css tag function to enable CSS styles to be embedded in JavaScript. This section demonstrates how to write your own tag functions like these. There is nothing special about tag functions: they are ordinary JavaScript functions, and no special syntax is required to define them. When a function expression is followed by a template literal, the function is invoked. The first argument is an array of strings, and this is followed by zero or more additional arguments, which can have values of any type. The number of arguments depends on the number of values that are interpolated into the template literal. If the template literal is simply a constant string with no interpolations, then the tag function will be called with an array of that one string and no additional arguments. If the template literal includes one interpolated value, then the tag function is called with two arguments. The first is an array of two strings, and the second is the interpolated value. The strings in that initial array are the string to the left of the interpolated value and the string to its right, and either one of them may be the empty string. If the template literal includes two interpolated values, then the tag function is invoked with three arguments: an array of three strings and the two interpolated values. The three strings (any or all of which may be empty) are the text to the left of the first value, the text between the two values, and the text to the right of the second value. In the general case, if the template literal has n interpolated values, then the tag function will be invoked with n+1 arguments. The first argument will be an array of n+1 strings, and the remaining arguments are the n interpolated values, in the order that they appear in the template literal. The value of a template literal is always a string. But the value of a tagged template literal is whatever value the tag function returns. This may be a string, but when the tag function is used to implement a DSL, the return value is typically a non-string data structure that is a parsed representation of the string. As an example of a template tag function that returns a string, consider the following html`` template, which is useful when you want to safely interpolate values into a string of HTML. The tag performs HTML escaping on each of the values before using it to build the final string: function html(strings, ...values) { // Convert each value to a string and escape special HTML characters let escaped = values.map(v =\u003e String(v) .replace(\"\u0026\", \"\u0026amp;\") .replace(\"\u003c\", \"\u0026lt;\") .replace(\"\u003e\", \"\u0026gt;\") .replace('\"', \"\u0026quot;\") .replace(\"'\", \"\u0026#39;\")); // Return the concatenated strings and escaped values let result = strings[0]; for(let i = 0; i \u003c escaped.length; i++) { result += escaped[i] + strings[i+1]; } return result; } let operator = \"\u003c\"; html`\u003cb\u003ex ${operator}y\u003c/b\u003e` // =\u003e \"\u003cb\u003ex \u0026lt; y\u003c/b\u003e\" let kind = \"game\", name = \"D\u0026D\"; html`\u003cdiv class=\"${kind}\"\u003e${name}\u003c/div\u003e` // =\u003e'\u003cdiv class=\"game\"\u003eD\u0026amp;D\u003c/div\u003e' For an example of a tag function that does not return a string but instead a parsed representation of a string, think back to the Glob pattern class defined in §14.4.6. Since the Glob() constructor takes a single string argument, we can define ","date":"2020-11-02","objectID":"/posts/ch14/:5:0","tags":null,"title":"第 14 章 元编程","uri":"/posts/ch14/"},{"categories":null,"content":"14.6 The Reflect API The Reflect object is not a class; like the Math object, its properties simply define a collection of related functions. These functions, added in ES6, define an API for “reflecting upon” objects and their properties. There is little new functionality here: the Reflect object defines a convenient set of functions, all in a single namespace, that mimic the behavior of core language syntax and duplicate the features of various pre-existing Object functions. Although the Reflect functions do not provide any new features, they do group the features together in one convenient API. And, importantly, the set of Reflect functions maps one-to-one with the set of Proxy handler methods that we’ll learn about in §14.7. The Reflect API consists of the following functions: Reflect.apply(f, o, args) This function invokes the function f as a method of o (or invokes it as a function with no this value if o is null) and passes the values in the args array as arguments. It is equivalent to f.apply(o, args). Reflect.construct(c, args, newTarget) This function invokes the constructor c as if the new keyword had been used and passes the elements of the array args as arguments. If the optional newTarget argument is specified, it is used as the value of new.target within the constructor invocation. If not specified, then the new.target value will be c. Reflect.defineProperty(o, name, descriptor) This function defines a property on the object o, using name (a string or symbol) as the name of the property. The Descriptor object should define the value (or getter and/or setter) and attributes of the property. Reflect.defineProperty() is very similar to Object.defineProperty() but returns true on success and false on failures. (Object.defineProperty() returns o on success and throws TypeError on failure.) Reflect.deleteProperty(o, name) This function deletes the property with the specified string or symbolic name from the object o, returning true if successful (or if no such property existed) and false if the property could not be deleted. Calling this function is similar to writing delete o[name]. Reflect.get(o, name, receiver) This function returns the value of the property of o with the specified name (a string or symbol). If the property is an accessor method with a getter, and if the optional receiver argument is specified, then the getter function is called as a method of receiver instead of as a method of o. Calling this function is similar to evaluating o[name]. Reflect.getOwnPropertyDescriptor(o, name) This function returns a property descriptor object that describes the attributes of the property named name of the object o, or returns undefined if no such property exists. This function is nearly identical to Object.getOwnPropertyDescriptor(), except that the Reflect API version of the function requires that the first argument be an object and throws TypeError if it is not. Reflect.getPrototypeOf(o) This function returns the prototype of object o or null if the object has no prototype. It throws a TypeError if o is a primitive value instead of an object. This function is almost identical to Object.getPrototypeOf() except that Object.getPrototypeOf() only throws a TypeError for null and undefined arguments and coerces other primitive values to their wrapper objects. Reflect.has(o, name) This function returns true if the object o has a property with the specified name (which must be a string or a symbol). Calling this function is similar to evaluating name in o. Reflect.isExtensible(o) This function returns true if the object o is extensible (§14.2) and false if it is not. It throws a TypeError if o is not an object. Object.isExtensible() is similar but simply returns false when passed an argument that is not an object. Reflect.ownKeys(o) This function returns an array of the names of the properties of the object o or throws a TypeError if o is not an object. The names in the returned array will be strings and/or symbols. Call","date":"2020-11-02","objectID":"/posts/ch14/:6:0","tags":null,"title":"第 14 章 元编程","uri":"/posts/ch14/"},{"categories":null,"content":"14.7 Proxy Objects The Proxy class, available in ES6 and later, is JavaScript’s most powerful metaprogramming feature. It allows us to write code that alters the fundamental behavior of JavaScript objects. The Reflect API described in §14.6 is a set of functions that gives us direct access to a set of fundamental operations on JavaScript objects. What the Proxy class does is allows us a way to implement those fundamental operations ourselves and create objects that behave in ways that are not possible for ordinary objects. ES6 之后引入的 Proxy 类是 JavaScript 非常强大的元编程特性。它允许我们通过编写代码来改变 JavaScript 对象的基本行为。§14.6 描述的 Reflect API 是一组让我们可以直接访问 JavaScript 对象的基本操作的函数。而 Proxy 类是允许我们自己实现那些基本操作的一种方法，并且创建对象 TODO When we create a Proxy object, we specify two other objects, the target object and the handlers object: 当创建一个 Proxy 对象时需要指定另外两个对象，target 对象和 handlers 对象： let proxy = new Proxy(target, handlers); The resulting Proxy object has no state or behavior of its own. Whenever you perform an operation on it (read a property, write a property, define a new property, look up the prototype, invoke it as a function), it dispatches those operations to the handlers object or to the target object. Proxy 对象返回值没有状态和行为。每当使用它执行一个操作时（读属性，写属性，定义一个新的属性，寻找 prototype，将其作为函数调用），它会将操作派发给 handlers 或者 target 对象。 The operations supported by Proxy objects are the same as those defined by the Reflect API. Suppose that p is a Proxy object and you write delete p.x. The Reflect.deleteProperty() function has the same behavior as the delete operator. And when you use the delete operator to delete a property of a Proxy object, it looks for a deleteProperty() method on the handlers object. If such a method exists, it invokes it. And if no such method exists, then the Proxy object performs the property deletion on the target object instead. Proxy 对象支持的操作和 Reflect API 定义的操作一样。假设 p 是一个 Proxy 对象，并且你写一段代码 delete p.x。Reflect.deleteProperty() 和 delete 操作符有同样的行为。而且当使用 delete 操作符去删除一个 Proxy 对象的属性时，它会去寻找 handlers 对象的 deleteProperty() 方法。如果存在这样一个方法，它将被调用。如果方法不存在，那么 Proxy 对象将在 target 对象上执行属性删除。 Proxies work this way for all of the fundamental operations: if an appropriate method exists on the handlers object, it invokes that method to perform the operation. (The method names and signatures are the same as those of the Reflect functions covered in §14.6.) And if that method does not exist on the handlers object, then the Proxy performs the fundamental operation on the target object. This means that a Proxy can obtain its behavior from the target object or from the handlers object. If the handlers object is empty, then the proxy is essentially a transparent wrapper around the target object: Proxy 这种方式作用于所有的基本操作：如果有一个适当的方法存在于 handlers 对象，它就会调用这个方法来执行这个操作。（方法的方法名和签名与 §14.6 Reflect 包含的函数一致）如果那个方法不存在于 handlers 对象，那么 Proxy 会在 target 对象上执行该基本操作。这意味 Proxy 可以从 target 对象或 handlers 对象上获取它的行为。如果 handlers 对象是空的，Proxy 本质上是 target 对象的透明包装器： let t = { x: 1, y: 2 }; let p = new Proxy(t, {}); p.x // =\u003e 1 delete p.y // =\u003e true: delete property y of the proxy t.y // =\u003e undefined: this deletes it in the target, too p.z = 3; // Defining a new property on the proxy t.z // =\u003e 3: defines the property on the target This kind of transparent wrapper proxy is essentially equivalent to the underlying target object, which means that there really isn’t a reason to use it instead of the wrapped object. Transparent wrappers can be useful, however, when created as “revocable proxies.” Instead of creating a Proxy with the Proxy() constructor, you can use the Proxy.revocable() factory function. This function returns an object that includes a Proxy object and also a revoke() function. Once you call the revoke() function, the proxy immediately stops working: 这种透明的包装 proxy 本质上等同于底层的 target 对象，这意味着确实没有理由使用它来代替被包装的对象。但创建类似于可回收的代理时，透明的包装是很实用的。可以使用 Proxy.revocable() 工厂函数创建 Proxy。这个函数返回一个 Proxy 对象和 revoke() 函数。当调用 revoke() 函数时，代理立即停止工作： function accessTheDatabase() { /* implementation omitted */ return 42; } let {proxy, revoke} = Pro","date":"2020-11-02","objectID":"/posts/ch14/:7:0","tags":null,"title":"第 14 章 元编程","uri":"/posts/ch14/"},{"categories":null,"content":"14.7.1 Proxy Invariants The readOnlyProxy() function defined earlier creates Proxy objects that are effectively frozen: any attempt to alter a property value or property attribute or to add or remove properties will throw an exception. But as long as the target object is not frozen, we’ll find that if we can query the proxy with Reflect.isExtensible() and Reflect.getOwnPropertyDescriptor(), and it will tell us that we should be able to set, add, and delete properties. So readOnlyProxy() creates objects in an inconsistent state. We could fix this by adding isExtensible() and getOwnPropertyDescriptor() handlers, or we can just live with this kind of minor inconsistency. The Proxy handler API allows us to define objects with major inconsistencies, however, and in this case, the Proxy class itself will prevent us from creating Proxy objects that are inconsistent in a bad way. At the start of this section, we described proxies as objects with no behavior of their own because they simply forward all operations to the handlers object and the target object. But this is not entirely true: after forwarding an operation, the Proxy class performs some sanity checks on the result to ensure important JavaScript invariants are not being violated. If it detects a violation, the proxy will throw a TypeError instead of letting the operation proceed. As an example, if you create a proxy for a non-extensible object, the proxy will throw a TypeError if the isExtensible() handler ever returns true: let target = Object.preventExtensions({}); let proxy = new Proxy(target, { isExtensible() { return true; }}); Reflect.isExtensible(proxy); // !TypeError: invariant violation Relatedly, proxy objects for non-extensible targets may not have a getPrototypeOf() handler that returns anything other than the real prototype object of the target. Also, if the target object has nonwritable, nonconfigurable properties, then the Proxy class will throw a TypeError if the get() handler returns anything other than the actual value: let target = Object.freeze({x: 1}); let proxy = new Proxy(target, { get() { return 99; }}); proxy.x; // !TypeError: value returned by get() doesn't match target Proxy enforces a number of additional invariants, almost all of them having to do with non-extensible target objects and nonconfigurable properties on the target object. ","date":"2020-11-02","objectID":"/posts/ch14/:7:1","tags":null,"title":"第 14 章 元编程","uri":"/posts/ch14/"},{"categories":null,"content":"14.8 Summary In this chapter, you have learned: JavaScript objects have an extensible attribute and object properties have writable, enumerable, and configurable attributes, as well as a value and a getter and/or setter attribute. You can use these attributes to “lock down” your objects in various ways, including creating “sealed” and “frozen” objects. JavaScript defines functions that allow you to traverse the prototype chain of an object and even to change the prototype of an object (though doing this can make your code slower). The properties of the Symbol object have values that are “well-known Symbols,” which you can use as property or method names for the objects and classes that you define. Doing so allows you to control how your object interacts with JavaScript language features and with the core library. For example, well-known Symbols allow you to make your classes iterable and control the string that is displayed when an instance is passed to Object.prototype.toString(). Prior to ES6, this kind of customization was available only to the native classes that were built in to an implementation. Tagged template literals are a function invocation syntax, and defining a new tag function is kind of like adding a new literal syntax to the language. Defining a tag function that parses its template string argument allows you to embed DSLs within JavaScript code. Tag functions also provide access to a raw, unescaped form of string literals where backslashes have no special meaning. The Proxy class and the related Reflect API allow low-level control over the fundamental behaviors of JavaScript objects. Proxy objects can be used as optionally revocable wrappers to improve code encapsulation, and they can also be used to implement nonstandard object behaviors (like some of the special case APIs defined by early web browsers). 1 A bug in the V8 JavaScript engine means that this code does not work correctly in Node 13. ","date":"2020-11-02","objectID":"/posts/ch14/:8:0","tags":null,"title":"第 14 章 元编程","uri":"/posts/ch14/"},{"categories":null,"content":"The JavaScript language was created in 1994 with the express purpose of enabling dynamic behavior in the documents displayed by web browsers. The language has evolved significantly since then, and at the same time, the scope and capabilities of the web platform have grown explosively. Today, JavaScript programmers can think of the web as a full-featured platform for application development. Web browsers specialize in the display of formatted text and images, but, like native operating systems, browsers also provide other services, including graphics, video, audio, networking, storage, and threading. JavaScript is the language that enables web applications to use the services provided by the web platform, and this chapter demonstrates how you can use the most important of these services. JavaScript语言创建于1994年，其主要目的是在web浏览器显示的文档中启用动态行为。从那时起，该语言已经发生了显著的发展，同时，web平台的范围和功能也爆炸式地增长。如今，JavaScript程序员可以将web看作是应用程序开发的功能齐全的平台。Web浏览器专门用于显示格式化的文本和图像，但是，与本机操作系统一样，浏览器也提供其他服务，包括图形、视频、音频、网络、存储和线程处理。JavaScript是一种使web应用程序能够使用web平台提供的服务的语言，本章将演示如何使用这些服务中最重要的一种。 The chapter begins with the web platform’s programming model, explaining how scripts are embedded within HTML pages (§15.1) and how JavaScript code is triggered asynchronously by events (§15.2). The sections that follow this introductory material document the core JavaScript APIs that enable your web applications to: 本章从web平台的编程模型开始，说明了脚本是如何嵌入到HTML页面中的(§15.1)，以及JavaScript代码是如何被事件异步触发的(§15.2)。接下来的章节介绍了核心JavaScript api，使您的web应用程序: Control document content (§15.3) and style (§15.4) Determine the on-screen position of document elements (§15.5) Create reusable user interface components (§15.6) Draw graphics (§15.7 and §15.8) Play and generate sounds (§15.9) Manage browser navigation and history (§15.10) Exchange data over the network (§15.11) Store data on the user’s computer (§15.12) Perform concurrent computation with threads (§15.13) 控制文件内容(§15.3)和样式(§15.4) 确定文档元素在屏幕上的位置(§15.5) 创建可重用的用户界面组件(§15.6) 绘制图形(§15.7和§15.8) 播放和生成声音(§15.9) 管理浏览器导航和历史记录(§15.10) 通过网络交换数据(§15.11) 在用户的计算机上存储数据(§15.12) 用线程执行并发计算(§15.13) CLIENT-SIDE JAVASCRIPT In this book, and on the web, you’ll see the term “client-side JavaScript.” The term is simply a synonym for JavaScript written to run in a web browser, and it stands in contrast to “server-side” code, which runs in web servers. 在本书和web上，您将看到术语“客户端JavaScript”。这个术语只是在web浏览器中运行的JavaScript的同义词，它与在web服务器中运行的“服务器端”代码形成对比。 The two “sides” refer to the two ends of the network connection that separate the web server and the web browser, and software development for the web typically requires code to be written on both “sides.” Client-side and server-side are also often called “frontend” and “backend.” 这两个“端”指的是网络连接的两端，它将web服务器和web浏览器分开，而web的软件开发通常需要在这两个“端”编写代码。客户端和服务器端通常也称为前端和后端。 Previous editions of this book attempted to comprehensively cover all JavaScript APIs defined by web browsers, and as a result, this book was too long a decade ago. The number and complexity of web APIs has continued to grow, and I no longer think it makes sense to attempt to cover them all in one book. As of the seventh edition, my goal is to cover the JavaScript language definitively and to provide an in-depth introduction to using the language with Node and with web browsers. This chapter cannot cover all the web APIs, but it introduces the most important ones in enough detail that you can start using them right away. And, having learned about the core APIs covered here, you should be able to pick up new APIs (like those summarized in §15.15) when and if you need them. 本书的前几个版本试图全面地涵盖web浏览器定义的所有JavaScript api，因此，这本书在十年前就显得太长了。web api的数量和复杂性一直在增长，我认为在一本书中涵盖它们已经没有意义了。在第7版中，我的目标是详细介绍JavaScript语言，并深入介绍如何在Node和web浏览器中使用该语言。本章不能涵盖所有的web api，但它介绍了最重要的api，足够详细，您可以立即开始使用它们。并且，在了解了这里所涵盖的核心api之后，您应该能够在需要的时候获得新的api(如§15.15中总结的那些api)。 Node has a single implementation and a single authoritative source for documentation. Web APIs, by contrast, are defined by consensus among the major web browser vendors, and the au","date":"2020-11-02","objectID":"/posts/ch15/:0:0","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.1 Web Programming Basics This section explains how JavaScript programs for the web are structured, how they are loaded into a web browser, how they obtain input, how they produce output, and how they run asynchronously by responding to events. ","date":"2020-11-02","objectID":"/posts/ch15/:1:0","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.1.1 JavaScript in HTML \u003cscript\u003e Tags Web browsers display HTML documents. If you want a web browser to execute JavaScript code, you must include (or reference) that code from an HTML document, and this is what the HTML \u003cscript\u003e tag does. JavaScript code can appear inline within an HTML file between \u003cscript\u003e and \u003c/script\u003e tags. Here, for example, is an HTML file that includes a script tag with JavaScript code that dynamically updates one element of the document to make it behave like a digital clock: \u003c!DOCTYPE html\u003e \u003c!-- This is an HTML5 file --\u003e \u003chtml\u003e \u003c!-- The root element --\u003e \u003chead\u003e \u003c!-- Title, scripts \u0026 styles can go here --\u003e \u003ctitle\u003eDigital Clock\u003c/title\u003e \u003cstyle\u003e /* A CSS stylesheet for the clock */ #clock { /* Styles apply to element with id=\"clock\" */ font: bold 24px sans-serif; /* Use a big bold font */ background: #ddf; /* on a light bluish-gray background. */ padding: 15px; /* Surround it with some space */ border: solid black 2px; /* and a solid black border */ border-radius: 10px; /* with rounded corners. */ } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003c!-- The body holds the content of the document. --\u003e \u003ch1\u003eDigital Clock\u003c/h1\u003e \u003c!-- Display a title. --\u003e \u003cspan id=\"clock\"\u003e\u003c/span\u003e \u003c!-- We will insert the time into this element. --\u003e \u003cscript\u003e // Define a function to display the current time function displayTime() { let clock = document.querySelector(\"#clock\"); // Get element with id=\"clock\" let now = new Date(); // Get current time clock.textContent = now.toLocaleTimeString(); // Display time in the clock } displayTime() // Display the time right away setInterval(displayTime, 1000); // And then update it every second. \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e Although JavaScript code can be embedded directly within a \u003cscript\u003e tag, it is more common to instead use the src attribute of the \u003cscript\u003e tag to specify the URL (an absolute URL or a URL relative to the URL of the HTML file being displayed) of a file containing JavaScript code. If we took the JavaScript code out of this HTML file and stored it in its own scripts/digital_clock.js file, then the \u003cscript\u003e tag might reference that file of code like this: \u003cscript src=\"scripts/digital_clock.js\"\u003e\u003c/script\u003e A JavaScript file contains pure JavaScript, without \u003cscript\u003e tags or any other HTML. By convention, files of JavaScript code have names that end with .js. A \u003cscript\u003e tag with the a src attribute behaves exactly as if the contents of the specified JavaScript file appeared directly between the \u003cscript\u003e and \u003c/script\u003e tags. Note that the closing \u003c/script\u003e tag is required in HTML documents even when the src attribute is specified: HTML does not support a \u003cscript/\u003e tag. There are a number of advantages to using the src attribute: It simplifies your HTML files by allowing you to remove large blocks of JavaScript code from them—that is, it helps keep content and behavior separate. When multiple web pages share the same JavaScript code, using the src attribute allows you to maintain only a single copy of that code, rather than having to edit each HTML file when the code changes. If a file of JavaScript code is shared by more than one page, it only needs to be downloaded once, by the first page that uses it—subsequent pages can retrieve it from the browser cache. Because the src attribute takes an arbitrary URL as its value, a JavaScript program or web page from one web server can employ code exported by other web servers. Much internet advertising relies on this fact. MODULES §10.3 documents JavaScript modules and covers their import and export directives. If you have written your JavaScript program using modules (and have not used a code-bundling tool to combine all your modules into a single nonmodular file of JavaScript), then you must load the top-level module of your program with a \u003cscript\u003e tag that has a type=“module” attribute. If you do this, then the module you specify will be loaded, and all of the modules it imports will be loaded, and (recursively) all of the modules they import will be loaded. See §1","date":"2020-11-02","objectID":"/posts/ch15/:1:1","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.1.2 The Document Object Model One of the most important objects in client-side JavaScript programming is the Document object—which represents the HTML document that is displayed in a browser window or tab. The API for working with HTML documents is known as the Document Object Model, or DOM, and it is covered in detail in §15.3. But the DOM is so central to client-side JavaScript programming that it deserves to be introduced here. HTML documents contain HTML elements nested within one another, forming a tree. Consider the following simple HTML document: \u003chtml\u003e \u003chead\u003e \u003ctitle\u003eSample Document\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003eAn HTML Document\u003c/h1\u003e \u003cp\u003eThis is a \u003ci\u003esimple\u003c/i\u003e document. \u003c/body\u003e \u003c/html\u003e The top-level \u003chtml\u003e tag contains \u003chead\u003e and \u003cbody\u003e tags. The \u003chead\u003e tag contains a \u003ctitle\u003e tag. And the \u003cbody\u003e tag contains \u003ch1\u003e and \u003cp\u003e tags. The \u003ctitle\u003e and \u003ch1\u003e tags contain strings of text, and the \u003cp\u003e tag contains two strings of text with an \u003ci\u003e tag between them. The DOM API mirrors the tree structure of an HTML document. For each HTML tag in the document, there is a corresponding JavaScript Element object, and for each run of text in the document, there is a corresponding Text object. The Element and Text classes, as well as the Document class itself, are all subclasses of the more general Node class, and Node objects are organized into a tree structure that JavaScript can query and traverse using the DOM API. The DOM representation of this document is the tree pictured in Figure 15-1. The tree representation of an HTML documentIf you are not already familiar with tree structures in computer programming, it is helpful to know that they borrow terminology from family trees. The node directly above a node is the parent of that node. The nodes one level directly below another node are the children of that node. Nodes at the same level, and with the same parent, are siblings. The set of nodes any number of levels below another node are the descendants of that node. And the parent, grandparent, and all other nodes above a node are the ancestors of that node. The DOM API includes methods for creating new Element and Text nodes, and for inserting them into the document as children of other Element objects. There are also methods for moving elements within the document and for removing them entirely. While a server-side application might produce plain-text output by writing strings with console.log(), a client-side JavaScript application can produce formatted HTML output by building or manipulating the document tree document using the DOM API. There is a JavaScript class corresponding to each HTML tag type, and each occurrence of the tag in a document is represented by an instance of the class. The \u003cbody\u003e tag, for example, is represented by an instance of HTMLBodyElement, and a \u003ctable\u003e tag is represented by an instance of HTMLTableElement. The JavaScript element objects have properties that correspond to the HTML attributes of the tags. For example, instances of HTMLImageElement, which represent \u003cimg\u003e tags, have a src property that corresponds to the src attribute of the tag. The initial value of the src property is the attribute value that appears in the HTML tag, and setting this property with JavaScript changes the value of the HTML attribute (and causes the browser to load and display a new image). Most of the JavaScript element classes just mirror the attributes of an HTML tag, but some define additional methods. The HTMLAudioElement and HTMLVideoElement classes, for example, define methods like play() and pause() for controlling playback of audio and video files. ","date":"2020-11-02","objectID":"/posts/ch15/:1:2","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.1.3 The Global Object in Web Browsers There is one global object per browser window or tab (§3.7). All of the JavaScript code (except code running in worker threads; see §15.13) running in that window shares this single global object. This is true regardless of how many scripts or modules are in the document: all the scripts and modules of a document share a single global object; if one script defines a property on that object, that property is visible to all the other scripts as well. The global object is where JavaScript’s standard library is defined—the parseInt() function, the Math object, the Set class, and so on. In web browsers, the global object also contains the main entry points of various web APIs. For example, the document property represents the currently displayed document, the fetch() method makes HTTP network requests, and the Audio() constructor allows JavaScript programs to play sounds. In web browsers, the global object does double duty: in addition to defining built-in types and functions, it also represents the current web browser window and defines properties like history (§15.10.2), which represent the window’s browsing history, and innerWidth, which holds the window’s width in pixels. One of the properties of this global object is named window, and its value is the global object itself. This means that you can simply type window to refer to the global object in your client-side code. When using window-specific features, it is often a good idea to include a window. prefix: window.innerWidth is clearer than innerWidth, for example. ","date":"2020-11-02","objectID":"/posts/ch15/:1:3","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.1.4 Scripts Share a Namespace With modules, the constants, variables, functions, and classes defined at the top level (i.e., outside of any function or class definition) of the module are private to the module unless they are explicitly exported, in which case, they can be selectively imported by other modules. (Note that this property of modules is honored by code-bundling tools as well.) With non-module scripts, however, the situation is completely different. If the top-level code in a script defines a constant, variable, function, or class, that declaration will be visible to all other scripts in the same document. If one script defines a function f() and another script defines a class c, then a third script can invoke the function and instantiate the class without having to take any action to import them. So if you are not using modules, the independent scripts in your document share a single namespace and behave as if they are all part of a single larger script. This can be convenient for small programs, but the need to avoid naming conflicts can become problematic for larger programs, especially when some of the scripts are third-party libraries. There are some historical quirks with how this shared namespace works. var and function declarations at the top level create properties in the shared global object. If one script defines a top-level function f(), then another script in the same document can invoke that function as f() or as window.f(). On the other hand, the ES6 declarations const, let, and class, when used at the top level, do not create properties in the global object. They are still defined in a shared namespace, however: if one script defines a class C, other scripts will be able to create instances of that class with new C(), but not with new window.C(). To summarize: in modules, top-level declarations are scoped to the module and can be explicitly exported. In nonmodule scripts, however, top-level declarations are scoped to the containing document, and the declarations are shared by all scripts in the document. Older var and function declarations are shared via properties of the global object. Newer const, let, and class declarations are also shared and have the same document scope, but they do not exist as properties of any object that JavaScript code has access to. ","date":"2020-11-02","objectID":"/posts/ch15/:1:4","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.1.5 Execution of JavaScript Programs There is no formal definition of a program in client-side JavaScript, but we can say that a JavaScript program consists of all the JavaScript code in, or referenced from, a document. These separate bits of code share a single global Window object, which gives them access to the same underlying Document object representing the HTML document. Scripts that are not modules additionally share a top-level namespace. If a web page includes an embedded frame (using the \u003ciframe\u003e element), the JavaScript code in the embedded document has a different global object and Document object than the code in the embedding document, and it can be considered a separate JavaScript program. Remember, though, that there is no formal definition of what the boundaries of a JavaScript program are. If the container document and the contained document are both loaded from the same server, the code in one document can interact with the code in the other, and you can treat them as two interacting parts of a single program, if you wish. §15.13.6 explains how a JavaScript program can send and receive messages to and from JavaScript code running in an \u003ciframe\u003e. You can think of JavaScript program execution as occurring in two phases. In the first phase, the document content is loaded, and the code from \u003cscript\u003e elements (both inline scripts and external scripts) is run. Scripts generally run in the order in which they appear in the document, though this default order can be modified by the async and defer attributes we’ve described. The JavaScript code within any single script is run from top to bottom, subject, of course, to JavaScript’s conditionals, loops, and other control statements. Some scripts don’t really do anything during this first phase and instead just define functions and classes for use in the second phase. Other scripts might do significant work during the first phase and then do nothing in the second. Imagine a script at the very end of a document that finds all \u003ch1\u003e and \u003ch2\u003e tags in the document and modifies the document by generating and inserting a table of contents at the beginning of the document. This could be done entirely in the first phase. (See §15.3.6 for an example that does exactly this.) Once the document is loaded and all scripts have run, JavaScript execution enters its second phase. This phase is asynchronous and event-driven. If a script is going to participate in this second phase, then one of the things it must have done during the first phase is to register at least one event handler or other callback function that will be invoked asynchronously. During this event-driven second phase, the web browser invokes event handler functions and other callbacks in response to events that occur asynchronously. Event handlers are most commonly invoked in response to user input (mouse clicks, keystrokes, etc.) but may also be triggered by network activity, document and resource loading, elapsed time, or errors in JavaScript code. Events and event handlers are described in detail in §15.2. Some of the first events to occur during the event-driven phase are the “DOMContentLoaded” and “load” events. “DOMContentLoaded” is triggered when the HTML document has been completely loaded and parsed. The “load” event is triggered when all of the document’s external resources—such as images—are also fully loaded. JavaScript programs often use one of these events as a trigger or starting signal. It is common to see programs whose scripts define functions but take no action other than registering an event handler function to be triggered by the “load” event at the beginning of the event-driven phase of execution. It is this “load” event handler that then manipulates the document and does whatever it is that the program is supposed to do. Note that it is common in JavaScript programming for an event handler function such as the “load” event handler described here to register other event handlers. The loading ph","date":"2020-11-02","objectID":"/posts/ch15/:1:5","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.1.6 Program Input and Output Like any program, client-side JavaScript programs process input data to produce output data. There are a variety of inputs available: The content of the document itself, which JavaScript code can access with the DOM API (§15.3). User input, in the form of events, such as mouse clicks (or touch-screen taps) on HTML \u003cbutton\u003e elements, or text entered into HTML \u003ctextarea\u003e elements, for example. §15.2 demonstrates how JavaScript programs can respond to user events like these. The URL of the document being displayed is available to client-side JavaScript as document.URL. If you pass this string to the URL() constructor (§11.9), you can easily access the path, query, and fragment sections of the URL. The content of the HTTP “Cookie” request header is available to client-side code as document.cookie. Cookies are usually used by server-side code for maintaining user sessions, but client-side code can also read (and write) them if necessary. See §15.12.2 for further details. The global navigator property provides access to information about the web browser, the OS it’s running on top of, and the capabilities of each. For example, navigator.userAgent is a string that identifies the web browser, navigator.language is the user’s preferred language, and navigator.hardwareConcurrency returns the number of logical CPUs available to the web browser. Similarly, the global screen property provides access to the user’s display size via the screen.width and screen.height properties. In a sense, these navigator and screen objects are to web browsers what environment variables are to Node programs. Client-side JavaScript typically produces output, when it needs to, by manipulating the HTML document with the DOM API (§15.3) or by using a higher-level framework such as React or Angular to manipulate the document. Client-side code can also use console.log() and related methods (§11.8) to produce output. But this output is only visible in the web developer console, so it is useful when debugging, but not for user-visible output. ","date":"2020-11-02","objectID":"/posts/ch15/:1:6","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.1.7 Program Errors Unlike applications (such as Node applications) that run directly on top of the OS, JavaScript programs in a web browser can’t really “crash.” If an exception occurs while your JavaScript program is running, and if you do not have a catch statement to handle it, an error message will be displayed in the developer console, but any event handlers that have been registered keep running and responding to events. If you would like to define an error handler of last resort to be invoked when this kind of uncaught exception occurs, set the onerror property of the Window object to an error handler function. When an uncaught exception propagates all the way up the call stack and an error message is about to be displayed in the developer console, the window.onerror function will be invoked with three string arguments. The first argument to window.onerror is a message describing the error. The second argument is a string that contains the URL of the JavaScript code that caused the error. The third argument is the line number within the document where the error occurred. If the onerror handler returns true, it tells the browser that the handler has handled the error and that no further action is necessary—in other words, the browser should not display its own error message. When a Promise is rejected and there is no .catch() function to handle it, that is a situation much like an unhandled exception: an unanticipated error or a logic error in your program. You can detect this by defining a window.onunhandledrejection function or by using window.addEventListener() to register a handler for “unhandledrejection” events. The event object passed to this handler will have a promise property whose value is the Promise object that rejected and a reason property whose value is what would have been passed to a .catch() function. As with the error handlers described earlier, if you call preventDefault() on the unhandled rejection event object, it will be considered handled and won’t cause an error message in the developer console. It is not often necessary to define onerror or onunhandledrejection handlers, but it can be quite useful as a telemetry mechanism if you want to report client-side errors to the server (using the fetch() function to make an HTTP POST request, for example) so that you can get information about unexpected errors that happen in your users’ browsers. ","date":"2020-11-02","objectID":"/posts/ch15/:1:7","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.1.8 The Web Security Model The fact that web pages can execute arbitrary JavaScript code on your personal device has clear security implications, and browser vendors have worked hard to balance two competing goals: Defining powerful client-side APIs to enable useful web applications Preventing malicious code from reading or altering your data, compromising your privacy, scamming you, or wasting your time The subsections that follow give a quick overview of the security restrictions and issues that you, as a JavaScript programmer, should to be aware of. WHAT JAVASCRIPT CAN’T DO Web browsers’ first line of defense against malicious code is that they simply do not support certain capabilities. For example, client-side JavaScript does not provide any way to write or delete arbitrary files or list arbitrary directories on the client computer. This means a JavaScript program cannot delete data or plant viruses. Similarly, client-side JavaScript does not have general-purpose networking capabilities. A client-side JavaScript program can make HTTP requests (§15.11.1). And another standard, known as WebSockets (§15.11.3), defines a socket-like API for communicating with specialized servers. But neither of these APIs allows unmediated access to the wider network. General-purpose internet clients and servers cannot be written in client-side JavaScript. THE SAME-ORIGIN POLICY The same-origin policy is a sweeping security restriction on what web content JavaScript code can interact with. It typically comes into play when a web page includes \u003ciframe\u003e elements. In this case, the same-origin policy governs the interactions of JavaScript code in one frame with the content of other frames. Specifically, a script can read only the properties of windows and documents that have the same origin as the document that contains the script. The origin of a document is defined as the protocol, host, and port of the URL from which the document was loaded. Documents loaded from different web servers have different origins. Documents loaded through different ports of the same host have different origins. And a document loaded with the http: protocol has a different origin than one loaded with the https: protocol, even if they come from the same web server. Browsers typically treat every file: URL as a separate origin, which means that if you’re working on a program that displays more than one document from the same server, you may not be able to test it locally using file: URLs and will have to run a static web server during development. It is important to understand that the origin of the script itself is not relevant to the same-origin policy: what matters is the origin of the document in which the script is embedded. Suppose, for example, that a script hosted by host A is included (using the src property of a \u003cscript\u003e element) in a web page served by host B. The origin of that script is host B, and the script has full access to the content of the document that contains it. If the document contains an \u003ciframe\u003e that contains a second document from host B, then the script also has full access to the content of that second document. But if the top-level document contains another \u003ciframe\u003e that displays a document from host C (or even one from host A), then the same-origin policy comes into effect and prevents the script from accessing this nested document. The same-origin policy also applies to scripted HTTP requests (see §15.11.1). JavaScript code can make arbitrary HTTP requests to the web server from which the containing document was loaded, but it does not allow scripts to communicate with other web servers (unless those web servers opt in with CORS, as we describe next). The same-origin policy poses problems for large websites that use multiple subdomains. For example, scripts with origin orders.example.com might need to read properties from documents on example.com. To support multidomain websites of this sort, scripts can alter their origin by settin","date":"2020-11-02","objectID":"/posts/ch15/:1:8","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.2 Events Client-side JavaScript programs use an asynchronous event-driven programming model. In this style of programming, the web browser generates an event whenever something interesting happens to the document or browser or to some element or object associated with it. For example, the web browser generates an event when it finishes loading a document, when the user moves the mouse over a hyperlink, or when the user strikes a key on the keyboard. If a JavaScript application cares about a particular type of event, it can register one or more functions to be invoked when events of that type occur. Note that this is not unique to web programming: all applications with graphical user interfaces are designed this way—they sit around waiting to be interacted with (i.e., they wait for events to occur), and then they respond. In client-side JavaScript, events can occur on any element within an HTML document, and this fact makes the event model of web browsers significantly more complex than Node’s event model. We begin this section with some important definitions that help to explain that event model: event type This string specifies what kind of event occurred. The type “mousemove,” for example, means that the user moved the mouse. The type “keydown” means that the user pressed a key on the keyboard down. And the type “load” means that a document (or some other resource) has finished loading from the network. Because the type of an event is just a string, it’s sometimes called an event name, and indeed, we use this name to identify the kind of event we’re talking about. event target This is the object on which the event occurred or with which the event is associated. When we speak of an event, we must specify both the type and the target. A load event on a Window, for example, or a click event on a \u003cbutton\u003e Element. Window, Document, and Element objects are the most common event targets in client-side JavaScript applications, but some events are triggered on other kinds of objects. For example, a Worker object (a kind of thread, covered §15.13) is a target for “message” events that occur when the worker thread sends a message to the main thread. event handler, or event listener This function handles or responds to an event.2 Applications register their event handler functions with the web browser, specifying an event type and an event target. When an event of the specified type occurs on the specified target, the browser invokes the handler function. When event handlers are invoked for an object, we say that the browser has “fired,” “triggered,” or “dispatched” the event. There are a number of ways to register event handlers, and the details of handler registration and invocation are explained in §15.2.2 and §15.2.3. event object This object is associated with a particular event and contains details about that event. Event objects are passed as an argument to the event handler function. All event objects have a type property that specifies the event type and a target property that specifies the event target. Each event type defines a set of properties for its associated event object. The object associated with a mouse event includes the coordinates of the mouse pointer, for example, and the object associated with a keyboard event contains details about the key that was pressed and the modifier keys that were held down. Many event types define only a few standard properties—such as type and target—and do not carry much other useful information. For those events, it is the simple occurrence of the event, not the event details, that matter. event propagation This is the process by which the browser decides which objects to trigger event handlers on. For events that are specific to a single object—such as the “load” event on the Window object or a “message” event on a Worker object—no propagation is required. But when certain kinds of events occur on elements within the HTML document, however, they propagate or “bubble” up the docu","date":"2020-11-02","objectID":"/posts/ch15/:2:0","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.2.1 Event Categories Client-side JavaScript supports such a large number of event types that there is no way this chapter can cover them all. It can be useful, though, to group events into some general categories, to illustrate the scope and wide variety of supported events: Device-dependent input events These events are directly tied to a specific input device, such as the mouse or keyboard. They include event types such as “mousedown,” “mousemove,” “mouseup,” “touchstart,” “touchmove,” “touchend,” “keydown,” and “keyup.” Device-independent input events These input events are not directly tied to a specific input device. The “click” event, for example, indicates that a link or button (or other document element) has been activated. This is often done via a mouse click, but it could also be done by keyboard or (on touch-sensitive devices) with a tap. The “input” event is a device-independent alternative to the “keydown” event and supports keyboard input as well as alternatives such as cut-and-paste and input methods used for ideographic scripts. The “pointerdown,” “pointermove,” and “pointerup” event types are device-independent alternatives to mouse and touch events. They work for mouse-type pointers, for touch screens, and for pen- or stylus-style input as well. User interface events UI events are higher-level events, often on HTML form elements that define a user interface for a web application. They include the “focus” event (when a text input field gains keyboard focus), the “change” event (when the user changes the value displayed by a form element), and the “submit” event (when the user clicks a Submit button in a form). State-change events Some events are not triggered directly by user activity, but by network or browser activity, and indicate some kind of life-cycle or state-related change. The “load” and “DOMContentLoaded” events—fired on the Window and Document objects, respectively, at the end of document loading—are probably the most commonly used of these events (see “Client-side JavaScript timeline”). Browsers fire “online” and “offline” events on the Window object when network connectivity changes. The browser’s history management mechanism (§15.10.4) fires the “popstate” event in response to the browser’s Back button. API-specific events A number of web APIs defined by HTML and related specifications include their own event types. The HTML \u003cvideo\u003e and \u003caudio\u003e elements define a long list of associated event types such as “waiting,” “playing,” “seeking,” “volumechange,” and so on, and you can use them to customize media playback. Generally speaking, web platform APIs that are asynchronous and were developed before Promises were added to JavaScript are event-based and define API-specific events. The IndexedDB API, for example (§15.12.3), fires “success” and “error” events when database requests succeed or fail. And although the new fetch() API (§15.11.1) for making HTTP requests is Promise-based, the XMLHttpRequest API that it replaces defines a number of API-specific event types. ","date":"2020-11-02","objectID":"/posts/ch15/:2:1","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.2.2 Registering Event Handlers There are two basic ways to register event handlers. The first, from the early days of the web, is to set a property on the object or document element that is the event target. The second (newer and more general) technique is to pass the handler to the addEventListener() method of the object or element. SETTING EVENT HANDLER PROPERTIES The simplest way to register an event handler is by setting a property of the event target to the desired event handler function. By convention, event handler properties have names that consist of the word “on” followed by the event name: onclick, onchange, onload, onmouseover, and so on. Note that these property names are case sensitive and are written in all lowercase,3 even when the event type (such as “mousedown”) consists of multiple words. The following code includes two event handler registrations of this kind: // Set the onload property of the Window object to a function. // The function is the event handler: it is invoked when the document loads. window.onload = function() { // Look up a \u003cform\u003e element let form = document.querySelector(\"form#shipping\"); // Register an event handler function on the form that will be invoked // before the form is submitted. Assume isFormValid() is defined elsewhere. form.onsubmit = function(event) { // When the user submits the form if (!isFormValid(this)) { // check whether form inputs are valid event.preventDefault(); // and if not, prevent form submission. } }; }; The shortcoming of event handler properties is that they are designed around the assumption that event targets will have at most one handler for each type of event. It is often better to register event handlers using addEventListener() because that technique does not overwrite any previously registered handlers. SETTING EVENT HANDLER ATTRIBUTES The event handler properties of document elements can also be defined directly in the HTML file as attributes on the corresponding HTML tag. (Handlers that would be registered on the Window element with JavaScript can be defined with attributes on the \u003cbody\u003e tag in HTML.) This technique is generally frowned upon in modern web development, but it is possible, and it’s documented here because you may still see it in existing code. When defining an event handler as an HTML attribute, the attribute value should be a string of JavaScript code. That code should be the body of the event handler function, not a complete function declaration. That is, your HTML event handler code should not be surrounded by curly braces and prefixed with the function keyword. For example: \u003cbutton onclick=\"console.log('Thank you');\"\u003ePlease Click\u003c/button\u003e If an HTML event handler attribute contains multiple JavaScript statements, you must remember to separate those statements with semicolons or break the attribute value across multiple lines. When you specify a string of JavaScript code as the value of an HTML event handler attribute, the browser converts your string into a function that works something like this one: function(event) { with(document) { with(this.form || {}) { with(this) { /* your code here */ } } } } The event argument means that your handler code can refer to the current event object as event. The with statements mean that the code of your handler can refer to the properties of the target object, the containing \u003cform\u003e (if any), and the containing Document object directly, as if they were variables in scope. The with statement is forbidden in strict mode (§5.6.3), but JavaScript code in HTML attributes is never strict. Event handlers defined in this way are executed in an environment in which unexpected variables are defined. This can be a source of confusing bugs and is a good reason to avoid writing event handlers in HTML. ADDEVENTLISTENER() Any object that can be an event target—this includes the Window and Document objects and all document Elements—defines a method named addEventListener() that you can use to register an even","date":"2020-11-02","objectID":"/posts/ch15/:2:2","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.2.3 Event Handler Invocation Once you’ve registered an event handler, the web browser will invoke it automatically when an event of the specified type occurs on the specified object. This section describes event handler invocation in detail, explaining event handler arguments, the invocation context (the this value), and the meaning of the return value of an event handler. EVENT HANDLER ARGUMENT Event handlers are invoked with an Event object as their single argument. The properties of the Event object provide details about the event: type The type of the event that occurred. target The object on which the event occurred. currentTarget For events that propagate, this property is the object on which the current event handler was registered. timeStamp A timestamp (in milliseconds) that represents when the event occurred but that does not represent an absolute time. You can determine the elapsed time between two events by subtracting the timestamp of the first event from the timestamp of the second. isTrusted This property will be true if the event was dispatched by the web browser itself and false if the event was dispatched by JavaScript code. Specific kinds of events have additional properties. Mouse and pointer events, for example, have clientX and clientY properties that specify the window coordinates at which the event occurred. EVENT HANDLER CONTEXT When you register an event handler by setting a property, it looks as if you are defining a new method on the target object: target.onclick = function() { /* handler code */ }; It isn’t surprising, therefore, that event handlers are invoked as methods of the object on which they are defined. That is, within the body of an event handler, the this keyword refers to the object on which the event handler was registered. Handlers are invoked with the target as their this value, even when registered using addEventListener(). This does not work for handlers defined as arrow functions, however: arrow functions always have the same this value as the scope in which they are defined. HANDLER RETURN VALUE In modern JavaScript, event handlers should not return anything. You may see event handlers that return values in older code, and the return value is typically a signal to the browser that it should not perform the default action associated with the event. If the onclick handler of a Submit button in a form returns false, for example, then the web browser will not submit the form (usually because the event handler determined that the user’s input fails client-side validation). The standard and preferred way to prevent the browser from performing a default action is to call the preventDefault() method (§15.2.5) on the Event object. INVOCATION ORDER An event target may have more than one event handler registered for a particular type of event. When an event of that type occurs, the browser invokes all of the handlers in the order in which they were registered. Interestingly, this is true even if you mix event handlers registered with addEventListener() with an event handler registered on an object property like onclick. ","date":"2020-11-02","objectID":"/posts/ch15/:2:3","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.2.4 Event Propagation When the target of an event is the Window object or some other standalone object, the browser responds to an event simply by invoking the appropriate handlers on that one object. When the event target is a Document or document Element, however, the situation is more complicated. After the event handlers registered on the target element are invoked, most events “bubble” up the DOM tree. The event handlers of the target’s parent are invoked. Then the handlers registered on the target’s grandparent are invoked. This continues up to the Document object, and then beyond to the Window object. Event bubbling provides an alternative to registering handlers on lots of individual document elements: instead, you can register a single handler on a common ancestor element and handle events there. You might register a “change” handler on a \u003cform\u003e element, for example, instead of registering a “change” handler for every element in the form. Most events that occur on document elements bubble. Notable exceptions are the “focus,” “blur,” and “scroll” events. The “load” event on document elements bubbles, but it stops bubbling at the Document object and does not propagate on to the Window object. (The “load” event handlers of the Window object are triggered only when the entire document has loaded.) Event bubbling is the third “phase” of event propagation. The invocation of the event handlers of the target object itself is the second phase. The first phase, which occurs even before the target handlers are invoked, is called the “capturing” phase. Recall that addEventListener() takes an optional third argument. If that argument is true, or {capture:true}, then the event handler is registered as a capturing event handler for invocation during this first phase of event propagation. The capturing phase of event propagation is like the bubbling phase in reverse. The capturing handlers of the Window object are invoked first, then the capturing handlers of the Document object, then of the body object, and so on down the DOM tree until the capturing event handlers of the parent of the event target are invoked. Capturing event handlers registered on the event target itself are not invoked. Event capturing provides an opportunity to peek at events before they are delivered to their target. A capturing event handler can be used for debugging, or it can be used along with the event cancellation technique described in the next section to filter events so that the target event handlers are never actually invoked. One common use for event capturing is handling mouse drags, where mouse motion events need to be handled by the object being dragged, not the document elements over which it is dragged. ","date":"2020-11-02","objectID":"/posts/ch15/:2:4","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.2.5 Event Cancellation Browsers respond to many user events, even if your code does not: when the user clicks the mouse on a hyperlink, the browser follows the link. If an HTML text input element has the keyboard focus and the user types a key, the browser will enter the user’s input. If the user moves their finger across a touch-screen device, the browser scrolls. If you register an event handler for events like these, you can prevent the browser from performing its default action by invoking the preventDefault() method of the event object. (Unless you registered the handler with the passive option, which makes preventDefault() ineffective.) Canceling the default action associated with an event is only one kind of event cancellation. We can also cancel the propagation of events by calling the stopPropagation() method of the event object. If there are other handlers defined on the same object, the rest of those handlers will still be invoked, but no event handlers on any other object will be invoked after stopPropagation() is called. stopPropagation() works during the capturing phase, at the event target itself, and during the bubbling phase. stopImmediatePropagation() works like stopPropagation(), but it also prevents the invocation of any subsequent event handlers registered on the same object. ","date":"2020-11-02","objectID":"/posts/ch15/:2:5","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.2.6 Dispatching Custom Events Client-side JavaScript’s event API is a relatively powerful one, and you can use it to define and dispatch your own events. Suppose, for example, that your program periodically needs to perform a long calculation or make a network request and that, while this operation is pending, other operations are not possible. You want to let the user know about this by displaying “spinners” to indicate that the application is busy. But the module that is busy should not need to know where the spinners should be displayed. Instead, that module might just dispatch an event to announce that it is busy and then dispatch another event when it is no longer busy. Then, the UI module can register event handlers for those events and take whatever UI actions are appropriate to notify the user. If a JavaScript object has an addEventListener() method, then it is an “event target,” and this means it also has a dispatchEvent() method. You can create your own event object with the CustomEvent() constructor and pass it to dispatchEvent(). The first argument to CustomEvent() is a string that specifies the type of your event, and the second argument is an object that specifies the properties of the event object. Set the detail property of this object to a string, object, or other value that represents the content of your event. If you plan to dispatch your event on a document element and want it to bubble up the document tree, add bubbles:true to the second argument: // Dispatch a custom event so the UI knows we are busy document.dispatchEvent(new CustomEvent(\"busy\", { detail: true })); // Perform a network operation fetch(url) .then(handleNetworkResponse) .catch(handleNetworkError) .finally(() =\u003e { // After the network request has succeeded or failed, dispatch // another event to let the UI know that we are no longer busy. document.dispatchEvent(new CustomEvent(\"busy\", { detail: false })); }); // Elsewhere, in your program you can register a handler for \"busy\" events // and use it to show or hide the spinner to let the user know. document.addEventListener(\"busy\", (e) =\u003e { if (e.detail) { showSpinner(); } else { hideSpinner(); } }); ","date":"2020-11-02","objectID":"/posts/ch15/:2:6","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.3 Scripting Documents Client-side JavaScript exists to turn static HTML documents into interactive web applications. So scripting the content of web pages is really the central purpose of JavaScript. Every Window object has a document property that refers to a Document object. The Document object represents the content of the window, and it is the subject of this section. The Document object does not stand alone, however. It is the central object in the DOM for representing and manipulating document content. The DOM was introduced in §15.1.2. This section explains the API in detail. It covers: How to query or select individual elements from a document. How to traverse a document, and how to find the ancestors, siblings, and descendants of any document element. How to query and set the attributes of document elements. How to query, set, and modify the content of a document. How to modify the structure of a document by creating, inserting, and deleting nodes. ","date":"2020-11-02","objectID":"/posts/ch15/:3:0","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.3.1 Selecting Document Elements Client-side JavaScript programs often need to manipulate one or more elements within the document. The global document property refers to the Document object, and the Document object has head and body properties that refer to the Element objects for the \u003chead\u003e and \u003cbody\u003e tags, respectively. But a program that wants to manipulate an element embedded more deeply in the document must somehow obtain or select the Element objects that refer to those document elements. SELECTING ELEMENTS WITH CSS SELECTORS CSS stylesheets have a very powerful syntax, known as selectors, for describing elements or sets of elements within a document. The DOM methods querySelector() and querySelectorAll() allow us to find the element or elements within a document that match a specified CSS selector. Before we cover the methods, we’ll start with a quick tutorial on CSS selector syntax. CSS selectors can describe elements by tag name, the value of their id attribute, or the words in their class attribute: div // Any \u003cdiv\u003e element #nav // The element with id=\"nav\" .warning // Any element with \"warning\" in its class attribute The # character is used to match based on the id attribute, and the . character is used to match based on the class attribute. Elements can also be selected based on more general attribute values: p[lang=\"fr\"] // A paragraph written in French: \u003cp lang=\"fr\"\u003e *[name=\"x\"] // Any element with a name=\"x\" attribute Note that these examples combine a tag name selector (or the * tag name wildcard) with an attribute selector. More complex combinations are also possible: span.fatal.error // Any \u003cspan\u003e with \"fatal\" and \"error\" in its class span[lang=\"fr\"].warning // Any \u003cspan\u003e in French with class \"warning\" Selectors can also specify document structure: #log span // Any \u003cspan\u003e descendant of the element with id=\"log\" #log\u003espan // Any \u003cspan\u003e child of the element with id=\"log\" body\u003eh1:first-child // The first \u003ch1\u003e child of the \u003cbody\u003e img + p.caption // A \u003cp\u003e with class \"caption\" immediately after an \u003cimg\u003e h2 ~ p // Any \u003cp\u003e that follows an \u003ch2\u003e and is a sibling of it If two selectors are separated by a comma, it means that we’ve selected elements that match either one of the selectors: button, input[type=\"button\"] // All \u003cbutton\u003e and \u003cinput type=\"button\"\u003e elements As you can see, CSS selectors allow us to refer to elements within a document by type, ID, class, attributes, and position within the document. The querySelector() method takes a CSS selector string as its argument and returns the first matching element in the document that it finds, or returns null if none match: // Find the document element for the HTML tag with attribute id=\"spinner\" let spinner = document.querySelector(\"#spinner\"); querySelectorAll() is similar, but it returns all matching elements in the document rather than just returning the first: // Find all Element objects for \u003ch1\u003e, \u003ch2\u003e, and \u003ch3\u003e tags let titles = document.querySelectorAll(\"h1, h2, h3\"); The return value of querySelectorAll() is not an array of Element objects. Instead, it is an array-like object known as a NodeList. NodeList objects have a length property and can be indexed like arrays, so you can loop over them with a traditional for loop. NodeLists are also iterable, so you can use them with for/of loops as well. If you want to convert a NodeList into a true array, simply pass it to Array.from(). The NodeList returned by querySelectorAll() will have a length property set to 0 if there are not any elements in the document that match the specified selector. querySelector() and querySelectorAll() are implemented by the Element class as well as by the Document class. When invoked on an element, these methods will only return elements that are descendants of that element. Note that CSS defines ::first-line and ::first-letter pseudoelements. In CSS, these match portions of text nodes rather than actual elements. They will not match if used with querySelectorAll() or querySelector(","date":"2020-11-02","objectID":"/posts/ch15/:3:1","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.3.2 Document Structure and Traversal Once you have selected an Element from a Document, you sometimes need to find structurally related portions (parent, siblings, children) of the document. When we are primarily interested in the Elements of a document instead of the text within them (and the whitespace between them, which is also text), there is a traversal API that allows us to treat a document as a tree of Element objects, ignoring Text nodes that are also part of the document. This traversal API does not involve any methods; it is simply a set of properties on Element objects that allow us to refer to the parent, children, and siblings of a given element: parentNode This property of an element refers to the parent of the element, which will be another Element or a Document object. children This NodeList contains the Element children of an element, but excludes non-Element children like Text nodes (and Comment nodes). childElementCount The number of Element children. Returns the same value as children.length. firstElementChild, lastElementChild These properties refer to the first and last Element children of an Element. They are null if the Element has no Element children. nextElementSibling, previousElementSibling These properties refer to the sibling Elements immediately before or immediately after an Element, or null if there is no such sibling. Using these Element properties, the second child Element of the first child Element of the Document can be referred to with either of these expressions: document.children[0].children[1] document.firstElementChild.firstElementChild.nextElementSibling (In a standard HTML document, both of those expressions refer to the \u003cbody\u003e tag of the document.) Here are two functions that demonstrate how you can use these properties to recursively do a depth-first traversal of a document invoking a specified function for every element in the document: // Recursively traverse the Document or Element e, invoking the function // f on e and on each of its descendants function traverse(e, f) { f(e); // Invoke f() on e for(let child of e.children) { // Iterate over the children traverse(child, f); // And recurse on each one } } function traverse2(e, f) { f(e); // Invoke f() on e let child = e.firstElementChild; // Iterate the children linked-list style while(child !== null) { traverse2(child, f); // And recurse child = child.nextElementSibling; } } DOCUMENTS AS TREES OF NODES If you want to traverse a document or some portion of a document and do not want to ignore the Text nodes, you can use a different set of properties defined on all Node objects. This will allow you to see Elements, Text nodes, and even Comment nodes (which represent HTML comments in the document). All Node objects define the following properties: parentNode The node that is the parent of this one, or null for nodes like the Document object that have no parent. childNodes A read-only NodeList that that contains all children (not just Element children) of the node. firstChild, lastChild The first and last child nodes of a node, or null if the node has no children. nextSibling, previousSibling The next and previous sibling nodes of a node. These properties connect nodes in a doubly linked list. nodeType A number that specifies what kind of node this is. Document nodes have value 9. Element nodes have value 1. Text nodes have value 3. Comment nodes have value 8. nodeValue The textual content of a Text or Comment node. nodeName The HTML tag name of an Element, converted to uppercase. Using these Node properties, the second child node of the first child of the Document can be referred to with expressions like these: document.childNodes[0].childNodes[1] document.firstChild.firstChild.nextSibling Suppose the document in question is the following: \u003chtml\u003e\u003chead\u003e\u003ctitle\u003eTest\u003c/title\u003e\u003c/head\u003e\u003cbody\u003eHello World!\u003c/body\u003e\u003c/html\u003e Then the second child of the first child is the \u003cbody\u003e element. It has a nodeType of 1 and a nodeName of “BODY”. Note, ","date":"2020-11-02","objectID":"/posts/ch15/:3:2","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.3.3 Attributes HTML elements consist of a tag name and a set of name/value pairs known as attributes. The \u003ca\u003e element that defines a hyperlink, for example, uses the value of its href attribute as the destination of the link. The Element class defines general getAttribute(), setAttribute(), hasAttribute(), and removeAttribute() methods for querying, setting, testing, and removing the attributes of an element. But the attribute values of HTML elements (for all standard attributes of standard HTML elements) are available as properties of the HTMLElement objects that represent those elements, and it is usually much easier to work with them as JavaScript properties than it is to call getAttribute() and related methods. HTML ATTRIBUTES AS ELEMENT PROPERTIES The Element objects that represent the elements of an HTML document usually define read/write properties that mirror the HTML attributes of the elements. Element defines properties for the universal HTML attributes such as id, title, lang, and dir and event handler properties like onclick. Element-specific subtypes define attributes specific to those elements. To query the URL of an image, for example, you can use the src property of the HTMLElement that represents the \u003cimg\u003e element: let image = document.querySelector(\"#main_image\"); let url = image.src; // The src attribute is the URL of the image image.id === \"main_image\" // =\u003e true; we looked up the image by id Similarly, you might set the form-submission attributes of a \u003cform\u003e element with code like this: let f = document.querySelector(\"form\"); // First \u003cform\u003e in the document f.action = \"https://www.example.com/submit\"; // Set the URL to submit it to. f.method = \"POST\"; // Set the HTTP request type. For some elements, such as the \u003cinput\u003e element, some HTML attribute names map to differently named properties. The HTML value attribute of an \u003cinput\u003e, for example, is mirrored by the JavaScript defaultValue property. The JavaScript value property of the \u003cinput\u003e element contains the user’s current input, but changes to the value property do not affect the defaultValue property nor the value attribute. HTML attributes are not case sensitive, but JavaScript property names are. To convert an attribute name to the JavaScript property, write it in lowercase. If the attribute is more than one word long, however, put the first letter of each word after the first in uppercase: defaultChecked and tabIndex, for example. Event handler properties like onclick are an exception, however, and are written in lowercase. Some HTML attribute names are reserved words in JavaScript. For these, the general rule is to prefix the property name with “html”. The HTML for attribute (of the \u003clabel\u003e element), for example, becomes the JavaScript htmlFor property. “class” is a reserved word in JavaScript, and the very important HTML class attribute is an exception to the rule: it becomes className in JavaScript code. The properties that represent HTML attributes usually have string values. But when the attribute is a boolean or numeric value (the defaultChecked and maxLength attributes of an \u003cinput\u003e element, for example), the properties are booleans or numbers instead of strings. Event handler attributes always have functions (or null) as their values. Note that this property-based API for getting and setting attribute values does not define any way to remove an attribute from an element. In particular, the delete operator cannot be used for this purpose. If you need to delete an attribute, use the removeAttribute() method. THE CLASS ATTRIBUTE The class attribute of an HTML element is a particularly important one. Its value is a space-separated list of CSS classes that apply to the element and affect how it is styled with CSS. Because class is a reserved word in JavaScript, the value of this attribute is available through the className property on Element objects. The className property can set and return the value of the class attribute as a string. But the","date":"2020-11-02","objectID":"/posts/ch15/:3:3","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.3.4 Element Content Look again at the document tree pictured in Figure 15-1, and ask yourself what the “content” of the \u003cp\u003e element is. There are two ways we might answer this question: The content is the HTML string “This is a \u003ci\u003esimple\u003c/i\u003e document”. The content is the plain-text string “This is a simple document”. Both of these are valid answers, and each answer is useful in its own way. The sections that follow explain how to work with the HTML representation and the plain-text representation of an element’s content. ELEMENT CONTENT AS HTML Reading the innerHTML property of an Element returns the content of that element as a string of markup. Setting this property on an element invokes the web browser’s parser and replaces the element’s current content with a parsed representation of the new string. You can test this out by opening the developer console and typing: document.body.innerHTML = \"\u003ch1\u003eOops\u003c/h1\u003e\"; You will see that the entire web page disappears and is replaced with the single heading, “Oops”. Web browsers are very good at parsing HTML, and setting innerHTML is usually fairly efficient. Note, however, that appending text to the innerHTML property with the += operator is not efficient because it requires both a serialization step to convert element content to a string and then a parsing step to convert the new string back into element content. WARNING When using these HTML APIs, it is very important that you never insert user input into the document. If you do this, you allow malicious users to inject their own scripts into your application. See “Cross-site scripting” for details. The outerHTML property of an Element is like innerHTML except that its value includes the element itself. When you query outerHTML, the value includes the opening and closing tags of the element. And when you set outerHTML on an element, the new content replaces the element itself. A related Element method is insertAdjacentHTML(), which allows you to insert a string of arbitrary HTML markup “adjacent” to the specified element. The markup is passed as the second argument to this method, and the precise meaning of “adjacent” depends on the value of the first argument. This first argument should be a string with one of the values “beforebegin,” “afterbegin,” “beforeend,” or “afterend.” These values correspond to insertion points that are illustrated in Figure 15-2. Insertion points for insertAdjacentHTML()ELEMENT CONTENT AS PLAIN TEXT Sometimes you want to query the content of an element as plain text or to insert plain text into a document (without having to escape the angle brackets and ampersands used in HTML markup). The standard way to do this is with the textContent property: let para = document.querySelector(\"p\"); // First \u003cp\u003e in the document let text = para.textContent; // Get the text of the paragraph para.textContent = \"Hello World!\"; // Alter the text of the paragraph The textContent property is defined by the Node class, so it works for Text nodes as well as Element nodes. For Element nodes, it finds and returns all text in all descendants of the element. The Element class defines an innerText property that is similar to textContent. innerText has some unusual and complex behaviors, such as attempting to preserve table formatting. It is not well specified nor implemented compatibly between browsers, however, and should no longer be used. TEXT IN \u003cSCRIPT\u003e ELEMENTS Inline \u003cscript\u003e elements (i.e., those that do not have a src attribute) have a text property that you can use to retrieve their text. The content of a \u003cscript\u003e element is never displayed by the browser, and the HTML parser ignores angle brackets and ampersands within a script. This makes a \u003cscript\u003e element an ideal place to embed arbitrary textual data for use by your application. Simply set the type attribute of the element to some value (such as “text/x-custom-data”) that makes it clear that the script is not executable JavaScript code. If you do this, the JavaScri","date":"2020-11-02","objectID":"/posts/ch15/:3:4","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.3.5 Creating, Inserting, and Deleting Nodes We’ve seen how to query and alter document content using strings of HTML and of plain text. And we’ve also seen that we can traverse a Document to examine the individual Element and Text nodes that it is made of. It is also possible to alter a document at the level of individual nodes. The Document class defines methods for creating Element objects, and Element and Text objects have methods for inserting, deleting, and replacing nodes in the tree. Create a new element with the createElement() method of the Document class and append strings of text or other elements to it with its append() and prepend() methods: let paragraph = document.createElement(\"p\"); // Create an empty \u003cp\u003e element let emphasis = document.createElement(\"em\"); // Create an empty \u003cem\u003e element emphasis.append(\"World\"); // Add text to the \u003cem\u003e element paragraph.append(\"Hello \", emphasis, \"!\"); // Add text and \u003cem\u003e to \u003cp\u003e paragraph.prepend(\"¡\"); // Add more text at start of \u003cp\u003e paragraph.innerHTML // =\u003e \"¡Hello \u003cem\u003eWorld\u003c/em\u003e!\" append() and prepend() take any number of arguments, which can be Node objects or strings. String arguments are automatically converted to Text nodes. (You can create Text nodes explicitly with document.createTextNode(), but there is rarely any reason to do so.) append() adds the arguments to the element at the end of the child list. prepend() adds the arguments at the start of the child list. If you want to insert an Element or Text node into the middle of the containing element’s child list, then neither append() or prepend() will work for you. In this case, you should obtain a reference to a sibling node and call before() to insert the new content before that sibling or after() to insert it after that sibling. For example: // Find the heading element with class=\"greetings\" let greetings = document.querySelector(\"h2.greetings\"); // Now insert the new paragraph and a horizontal rule after that heading greetings.after(paragraph, document.createElement(\"hr\")); Like append() and prepend(), after() and before() take any number of string and element arguments and insert them all into the document after converting strings to Text nodes. append() and prepend() are only defined on Element objects, but after() and before() work on both Element and Text nodes: you can use them to insert content relative to a Text node. Note that elements can only be inserted at one spot in the document. If an element is already in the document and you insert it somewhere else, it will be moved to the new location, not copied: // We inserted the paragraph after this element, but now we // move it so it appears before the element instead greetings.before(paragraph); If you do want to make a copy of an element, use the cloneNode() method, passing true to copy all of its content: // Make a copy of the paragraph and insert it after the greetings element greetings.after(paragraph.cloneNode(true)); You can remove an Element or Text node from the document by calling its remove() method, or you can replace it by calling replaceWith() instead. remove() takes no arguments, and replaceWith() takes any number of strings and elements just like before() and after() do: // Remove the greetings element from the document and replace it with // the paragraph element (moving the paragraph from its current location // if it is already inserted into the document). greetings.replaceWith(paragraph); // And now remove the paragraph. paragraph.remove(); The DOM API also defines an older generation of methods for inserting and removing content. appendChild(), insertBefore(), replaceChild(), and removeChild() are harder to use than the methods shown here and should never be needed. ","date":"2020-11-02","objectID":"/posts/ch15/:3:5","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.3.6 Example: Generating a Table of Contents Example 15-1 shows how to dynamically create a table of contents for a document. It demonstrates many of the document scripting techniques described in the previous sections. The example is well commented, and you should have no trouble following the code. Example 15-1. Generating a table of contents with the DOM API /** * TOC.js: create a table of contents for a document. * * This script runs when the DOMContentLoaded event is fired and * automatically generates a table of contents for the document. * It does not define any global symbols so it should not conflict * with other scripts. * * When this script runs, it first looks for a document element with * an id of \"TOC\". If there is no such element it creates one at the * start of the document. Next, the function finds all \u003ch2\u003e through * \u003ch6\u003e tags, treats them as section titles, and creates a table of * contents within the TOC element. The function adds section numbers * to each section heading and wraps the headings in named anchors so * that the TOC can link to them. The generated anchors have names * that begin with \"TOC\", so you should avoid this prefix in your own * HTML. * * The entries in the generated TOC can be styled with CSS. All * entries have a class \"TOCEntry\". Entries also have a class that * corresponds to the level of the section heading. \u003ch1\u003e tags generate * entries of class \"TOCLevel1\", \u003ch2\u003e tags generate entries of class * \"TOCLevel2\", and so on. Section numbers inserted into headings have * class \"TOCSectNum\". * * You might use this script with a stylesheet like this: * * #TOC { border: solid black 1px; margin: 10px; padding: 10px; } * .TOCEntry { margin: 5px 0px; } * .TOCEntry a { text-decoration: none; } * .TOCLevel1 { font-size: 16pt; font-weight: bold; } * .TOCLevel2 { font-size: 14pt; margin-left: .25in; } * .TOCLevel3 { font-size: 12pt; margin-left: .5in; } * .TOCSectNum:after { content: \": \"; } * * To hide the section numbers, use this: * * .TOCSectNum { display: none } **/ document.addEventListener(\"DOMContentLoaded\", () =\u003e { // Find the TOC container element. // If there isn't one, create one at the start of the document. let toc = document.querySelector(\"#TOC\"); if (!toc) { toc = document.createElement(\"div\"); toc.id = \"TOC\"; document.body.prepend(toc); } // Find all section heading elements. We're assuming here that the // document title uses \u003ch1\u003e and that sections within the document are // marked with \u003ch2\u003e through \u003ch6\u003e. let headings = document.querySelectorAll(\"h2,h3,h4,h5,h6\"); // Initialize an array that keeps track of section numbers. let sectionNumbers = [0,0,0,0,0]; // Now loop through the section header elements we found. for(let heading of headings) { // Skip the heading if it is inside the TOC container. if (heading.parentNode === toc) { continue; } // Figure out what level heading it is. // Subtract 1 because \u003ch2\u003e is a level-1 heading. let level = parseInt(heading.tagName.charAt(1)) - 1; // Increment the section number for this heading level // and reset all lower heading level numbers to zero. sectionNumbers[level-1]++; for(let i = level; i \u003c sectionNumbers.length; i++) { sectionNumbers[i] = 0; } // Now combine section numbers for all heading levels // to produce a section number like 2.3.1. let sectionNumber = sectionNumbers.slice(0, level).join(\".\"); // Add the section number to the section header title. // We place the number in a \u003cspan\u003e to make it styleable. let span = document.createElement(\"span\"); span.className = \"TOCSectNum\"; span.textContent = sectionNumber; heading.prepend(span); // Wrap the heading in a named anchor so we can link to it. let anchor = document.createElement(\"a\"); let fragmentName = `TOC${sectionNumber}`; anchor.name = fragmentName; heading.before(anchor); // Insert anchor before heading anchor.append(heading); // and move heading inside anchor // Now create a link to this section. let link = document.createElement(\"a\"); link.href = `#${fragmentName}`; // Lin","date":"2020-11-02","objectID":"/posts/ch15/:3:6","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.4 Scripting CSS We’ve seen that JavaScript can control the logical structure and content of HTML documents. It can also control the visual appearance and layout of those documents by scripting CSS. The following subsections explain a few different techniques that JavaScript code can use to work with CSS. This is a book about JavaScript, not about CSS, and this section assumes that you already have a working knowledge of how CSS is used to style HTML content. But it’s worth mentioning some of the CSS styles that are commonly scripted from JavaScript: Setting the display style to “none” hides an element. You can later show the element by setting display to some other value. You can dynamically position elements by setting the position style to “absolute,” “relative,” or “fixed” and then setting the top and left styles to the desired coordinates. This is important when using JavaScript to display dynamic content like modal dialogues and tooltips. You can shift, scale, and rotate elements with the transform style. You can animate changes to other CSS styles with the transition style. These animations are handled automatically by the web browser and do not require JavaScript, but you can use JavaScript to initiate the animations. ","date":"2020-11-02","objectID":"/posts/ch15/:4:0","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.4.1 CSS Classes The simplest way to use JavaScript to affect the styling of document content is to add and remove CSS class names from the class attribute of HTML tags. This is easy to do with the classList property of Element objects, as explained in “The class attribute”. Suppose, for example, that your document’s stylesheet includes a definition for a “hidden” class: .hidden { display:none; } With this style defined, you can hide (and then show) an element with code like this: // Assume that this \"tooltip\" element has class=\"hidden\" in the HTML file. // We can make it visible like this: document.querySelector(\"#tooltip\").classList.remove(\"hidden\"); // And we can hide it again like this: document.querySelector(\"#tooltip\").classList.add(\"hidden\"); ","date":"2020-11-02","objectID":"/posts/ch15/:4:1","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.4.2 Inline Styles To continue with the preceding tooltip example, suppose that the document is structured with only a single tooltip element, and we want to dynamically position it before displaying it. In general, we can’t create a different stylesheet class for each possible position of the tooltip, so the classList property won’t help us with positioning. In this case, we need to script the style attribute of the tooltip element to set inline styles that are specific to that one element. The DOM defines a style property on all Element objects that correspond to the style attribute. Unlike most such properties, however, the style property is not a string. Instead, it is a CSSStyleDeclaration object: a parsed representation of the CSS styles that appear in textual form in the style attribute. To display and set the position of our hypothetical tooltip with JavaScript, we might use code like this: function displayAt(tooltip, x, y) { tooltip.style.display = \"block\"; tooltip.style.position = \"absolute\"; tooltip.style.left = `${x}px`; tooltip.style.top = `${y}px`; } NAMING CONVENTIONS: CSS PROPERTIES IN JAVASCRIPT Many CSS style properties, such as font-size, contain hyphens in their names. In JavaScript, a hyphen is interpreted as a minus sign and is not allowed in property names or other identifiers. Therefore, the names of the properties of the CSSStyleDeclaration object are slightly different from the names of actual CSS properties. If a CSS property name contains one or more hyphens, the CSSStyleDeclaration property name is formed by removing the hyphens and capitalizing the letter immediately following each hyphen. The CSS property border-left-width is accessed through the JavaScript borderLeftWidth property, for example, and the CSS font-family property is written as fontFamily in JavaScript. When working with the style properties of the CSSStyleDeclaration object, remember that all values must be specified as strings. In a stylesheet or style attribute, you can write: display: block; font-family: sans-serif; background-color: #ffffff; To accomplish the same thing for an element e with JavaScript, you have to quote all of the values: e.style.display = \"block\"; e.style.fontFamily = \"sans-serif\"; e.style.backgroundColor = \"#ffffff\"; Note that the semicolons go outside the strings. These are just normal JavaScript semicolons; the semicolons you use in CSS stylesheets are not required as part of the string values you set with JavaScript. Furthermore, remember that many CSS properties require units such as “px” for pixels or “pt” for points. Thus, it is not correct to set the marginLeft property like this: e.style.marginLeft = 300; // Incorrect: this is a number, not a string e.style.marginLeft = \"300\"; // Incorrect: the units are missing Units are required when setting style properties in JavaScript, just as they are when setting style properties in stylesheets. The correct way to set the value of the marginLeft property of an element e to 300 pixels is: e.style.marginLeft = \"300px\"; If you want to set a CSS property to a computed value, be sure to append the units at the end of the computation: e.style.left = `${x0 + left_border + left_padding}px`; Recall that some CSS properties, such as margin, are shortcuts for other properties, such as margin-top, margin-right, margin-bottom, and margin-left. The CSSStyleDeclaration object has properties that correspond to these shortcut properties. For example, you might set the margin property like this: e.style.margin = `${top}px ${right}px ${bottom}px ${left}px`; Sometimes, you may find it easier to set or query the inline style of an element as a single string value rather than as a CSSStyleDeclaration object. To do that, you can use the Element getAttribute() and setAttribute() methods, or you can use the cssText property of the CSSStyleDeclaration object: // Copy the inline styles of element e to element f: f.setAttribute(\"style\", e.getAttribute(\"style\")); // Or do it like this:","date":"2020-11-02","objectID":"/posts/ch15/:4:2","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.4.3 Computed Styles The computed style for an element is the set of property values that the browser derives (or computes) from the element’s inline style plus all applicable style rules in all stylesheets: it is the set of properties actually used to display the element. Like inline styles, computed styles are represented with a CSSStyleDeclaration object. Unlike inline styles, however, computed styles are read-only. You can’t set these styles, but the computed CSSStyleDeclaration object for an element lets you determine what style property values the browser used when rendering that element. Obtain the computed style for an element with the getComputedStyle() method of the Window object. The first argument to this method is the element whose computed style is desired. The optional second argument is used to specify a CSS pseudoelement, such as “::before” or “::after”: let title = document.querySelector(\"#section1title\"); let styles = window.getComputedStyle(title); let beforeStyles = window.getComputedStyle(title, \"::before\"); The return value of getComputedStyle() is a CSSStyleDeclaration object that represents all the styles that apply to the specified element (or pseudoelement). There are a number of important differences between a CSSStyleDeclaration object that represents inline styles and one that represents computed styles: Computed style properties are read-only. Computed style properties are absolute: relative units like percentages and points are converted to absolute values. Any property that specifies a size (such as a margin size or a font size) will have a value measured in pixels. This value will be a string with a “px” suffix, so you’ll still need to parse it, but you won’t have to worry about parsing or converting other units. Properties whose values are colors will be returned in “rgb()” or “rgba()” format. Shortcut properties are not computed—only the fundamental properties that they are based on are. Don’t query the margin property, for example, but use marginLeft, marginTop, and so on. Similarly, don’t query border or even borderWidth. Instead, use borderLeftWidth, borderTopWidth, and so on. The cssText property of the computed style is undefined. A CSSStyleDeclaration object returned by getComputedStyle() generally contains much more information about an element than the CSSStyleDeclaration obtained from the inline style property of that element. But computed styles can be tricky, and querying them does not always provide the information you might expect. Consider the font-family attribute: it accepts a comma-separated list of desired font families for cross-platform portability. When you query the fontFamily property of a computed style, you’re simply getting the value of the most specific font-family style that applies to the element. This may return a value such as “arial,helvetica,sans-serif,” which does not tell you which typeface is actually in use. Similarly, if an element is not absolutely positioned, attempting to query its position and size through the top and left properties of its computed style often returns the value auto. This is a perfectly legal CSS value, but it is probably not what you were looking for. Although CSS can be used to precisely specify the position and size of document elements, querying the computed style of an element is not the preferred way to determine the element’s size and position. See §15.5.2 for a simpler, portable alternative. ","date":"2020-11-02","objectID":"/posts/ch15/:4:3","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.4.4 Scripting Stylesheets In addition to scripting class attributes and inline styles, JavaScript can also manipulate stylesheets themselves. Stylesheets are associated with an HTML document with a \u003cstyle\u003e tag or with a \u003clink rel=\"stylesheet\"\u003e tag. Both of these are regular HTML tags, so you can give them both id attributes and then look them up with document.querySelector(). The Element objects for both \u003cstyle\u003e and \u003clink\u003e tags have a disabled property that you can use to disable the entire stylesheet. You might use it with code like this: // This function switches between the \"light\" and \"dark\" themes function toggleTheme() { let lightTheme = document.querySelector(\"#light-theme\"); let darkTheme = document.querySelector(\"#dark-theme\"); if (darkTheme.disabled) { // Currently light, switch to dark lightTheme.disabled = true; darkTheme.disabled = false; } else { // Currently dark, switch to light lightTheme.disabled = false; darkTheme.disabled = true; } } Another simple way to script stylesheets is to insert new ones into the document using DOM manipulation techniques we’ve already seen. For example: function setTheme(name) { // Create a new \u003clink rel=\"stylesheet\"\u003e element to load the named stylesheet let link = document.createElement(\"link\"); link.id = \"theme\"; link.rel = \"stylesheet\"; link.href = `themes/${name}.css`; // Look for an existing link with id \"theme\" let currentTheme = document.querySelector(\"#theme\"); if (currentTheme) { // If there is an existing theme, replace it with the new one. currentTheme.replaceWith(link); } else { // Otherwise, just insert the link to the theme stylesheet. document.head.append(link); } } Less subtly, you can also just insert a string of HTML containing a \u003cstyle\u003e tag into your document. This is a fun trick, for example: document.head.insertAdjacentHTML( \"beforeend\", \"\u003cstyle\u003ebody{transform:rotate(180deg)}\u003c/style\u003e\" ); Browsers define an API that allows JavaScript to look inside stylesheets to query, modify, insert, and delete style rules in that stylesheet. This API is so specialized that it is not documented here. You can read about it on MDN by searching for “CSSStyleSheet” and “CSS Object Model.” ","date":"2020-11-02","objectID":"/posts/ch15/:4:4","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.4.5 CSS Animations and Events Suppose you have the following two CSS classes defined in a stylesheet: .transparent { opacity: 0; } .fadeable { transition: opacity .5s ease-in } If you apply the first style to an element, it will be fully transparent and therefore invisible. But if you apply the second style that tells the browser that when the opacity of the element changes, that change should be animated over a period of 0.5 seconds, “ease-in” specifies that the opacity change animation should start off slow and then accelerate. Now suppose that your HTML document contains an element with the “fadeable” class: \u003cdiv id=\"subscribe\" class=\"fadeable notification\"\u003e...\u003c/div\u003e In JavaScript, you can add the “transparent” class: document.querySelector(\"#subscribe\").classList.add(\"transparent\"); This element is configured to animate opacity changes. Adding the “transparent” class changes the opacity and triggers an animate: the browser “fades out” the element so that it becomes fully transparent over the period of half a second. This works in reverse as well: if you remove the “transparent” class of a “fadeable” element, that is also an opacity change, and the element fades back in and becomes visible again. JavaScript does not have to do any work to make these animations happen: they are a pure CSS effect. But JavaScript can be used to trigger them. JavaScript can also be used to monitor the progress of a CSS transition because the web browser fires events at the start and end of a transition. The “transitionrun” event is dispatched when the transition is first triggered. This may happen before any visual changes begin, when the transition-delay style has been specified. Once the visual changes begin a “transitionstart” event is dispatched, and when the animation is complete, a “transitionend” event is dispatched. The target of all these events is the element being animated, of course. The event object passed to handlers for these events is a TransitionEvent object. It has a propertyName property that specifies the CSS property being animated and an elapsedTime property that for “transitionend” events specifies how many seconds have passed since the “transitionstart” event. In addition to transitions, CSS also supports a more complex form of animation known simply as “CSS Animations.” These use CSS properties such as animation-name and animation-duration and a special @keyframes rule to define animation details. Details of how CSS animations work are beyond the scope of this book, but once again, if you define all of the animation properties on a CSS class, then you can use JavaScript to trigger the animation simply by adding the class to the element that is to be animated. And like CSS transitions, CSS animations also trigger events that your JavaScript code can listen form. “animationstart” is dispatched when the animation starts, and “animationend” is dispatched when it is complete. If the animation repeats more than once, then an “animationiteration” event is dispatched after each repetition except the last. The event target is the animated element, and the event object passed to handler functions is an AnimationEvent object. These events include an animationName property that specifies the animation-name property that defines the animation and an elapsedTime property that specifies how many seconds have passed since the animation started. ","date":"2020-11-02","objectID":"/posts/ch15/:4:5","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.5 Document Geometry and Scrolling In this chapter so far, we have thought about documents as abstract trees of elements and text nodes. But when a browser renders a document within a window, it creates a visual representation of the document in which each element has a position and a size. Often, web applications can treat documents as trees of elements and never have to think about how those elements are rendered on screen. Sometimes, however, it is necessary to determine the precise geometry of an element. If, for example, you want to use CSS to dynamically position an element (such as a tooltip) next to some ordinary browser-positioned element, you need to be able to determine the location of that element. The following subsections explain how you can go back and forth between the abstract, tree-based model of a document and the geometrical, coordinate-based view of the document as it is laid out in a browser window. ","date":"2020-11-02","objectID":"/posts/ch15/:5:0","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.5.1 Document Coordinates and Viewport Coordinates The position of a document element is measured in CSS pixels, with the x coordinate increasing to the right and the y coordinate increasing as we go down. There are two different points we can use as the coordinate system origin, however: the x and y coordinates of an element can be relative to the top-left corner of the document or relative to the top-left corner of the viewport in which the document is displayed. In top-level windows and tabs, the “viewport” is the portion of the browser that actually displays document content: it excludes browser “chrome” such as menus, toolbars, and tabs. For documents displayed in \u003ciframe\u003e tags, it is the iframe element in the DOM that defines the viewport for the nested document. In either case, when we talk about the position of an element, we must be clear whether we are using document coordinates or viewport coordinates. (Note that viewport coordinates are sometimes called “window coordinates.”) If the document is smaller than the viewport, or if it has not been scrolled, the upper-left corner of the document is in the upper-left corner of the viewport and the document and viewport coordinate systems are the same. In general, however, to convert between the two coordinate systems, we must add or subtract the scroll offsets. If an element has a y coordinate of 200 pixels in document coordinates, for example, and if the user has scrolled down by 75 pixels, then that element has a y coordinate of 125 pixels in viewport coordinates. Similarly, if an element has an x coordinate of 400 in viewport coordinates after the user has scrolled the viewport 200 pixels horizontally, then the element’s x coordinate in document coordinates is 600. If we use the mental model of printed paper documents, it is logical to assume that every element in a document must have a unique position in document coordinates, regardless of how much the user has scrolled the document. That is an appealing property of paper documents, and it applies for simple web documents, but in general, document coordinates don’t really work on the web. The problem is that the CSS overflow property allows elements within a document to contain more content than it can display. Elements can have their own scrollbars and serve as viewports for the content they contain. The fact that the web allows scrolling elements within a scrolling document means that it is simply not possible to describe the position of an element within the document using a single (x,y) point. Because document coordinates don’t really work, client-side JavaScript tends to use viewport coordinates. The getBoundingClientRect() and elementFromPoint() methods described next use viewport coordinates, for example, and the clientX and clientY properties of mouse and pointer event objects also use this coordinate system. When you explicitly position an element using CSS position:fixed, the top and left properties are interpreted in viewport coordinates. If you use position:relative, the element is positioned relative to where it would have been if it didn’t have the position property set. If you use position:absolute, then top and left are relative to the document or to the nearest containing positioned element. This means, for example, that an absolutely positioned element inside a relatively positioned element is positioned relative to the container element, not relative to the overall document. It is sometimes very useful to create a relatively positioned container with top and left set to 0 (so the container is laid out normally) in order to establish a new coordinate system origin for the absolutely positioned elements it contains. We might refer to this new coordinate system as “container coordinates” to distinguish it from document coordinates and viewport coordinates. CSS PIXELS If, like me, you are old enough to remember computer monitors with resolutions of 1024 × 768 and touch-screen phones with resolutions o","date":"2020-11-02","objectID":"/posts/ch15/:5:1","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.5.2 Querying the Geometry of an Element You can determine the size (including CSS border and padding, but not the margin) and position (in viewport coordinates) of an element by calling its getBoundingClientRect() method. It takes no arguments and returns an object with properties left, right, top, bottom, width, and height. The left and top properties give the x and y coordinates of the upper-left corner of the element, and the right and bottom properties give the coordinates of the lower-right corner. The differences between these values are the width and height properties. Block elements, such as images, paragraphs, and \u003cdiv\u003e elements are always rectangular when laid out by the browser. Inline elements, such as \u003cspan\u003e, \u003ccode\u003e, and \u003cb\u003e elements, however, may span multiple lines and may therefore consist of multiple rectangles. Imagine, for example, some text within \u003cem\u003e and \u003c/em\u003e tags that happens to be displayed so that it wraps across two lines. Its rectangles consist of the end of the first line and beginning of the second line. If you call getBoundingClientRect() on this element, the bounding rectangle would include the entire width of both lines. If you want to query the individual rectangles of inline elements, call the getClientRects() method to obtain a read-only, array-like object whose elements are rectangle objects like those returned by getBoundingClientRect(). ","date":"2020-11-02","objectID":"/posts/ch15/:5:2","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.5.3 Determining the Element at a Point The getBoundingClientRect() method allows us to determine the current position of an element in a viewport. Sometimes we want to go in the other direction and determine which element is at a given location in the viewport. You can determine this with the elementFromPoint() method of the Document object. Call this method with the x and y coordinates of a point (using viewport coordinates, not document coordinates: the clientX and clientY coordinates of a mouse event work, for example). elementFromPoint() returns an Element object that is at the specified position. The hit detection algorithm for selecting the element is not precisely specified, but the intent of this method is that it returns the innermost (most deeply nested) and uppermost (highest CSS z-index attribute) element at that point. ","date":"2020-11-02","objectID":"/posts/ch15/:5:3","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.5.4 Scrolling The scrollTo() method of the Window object takes the x and y coordinates of a point (in document coordinates) and sets these as the scrollbar offsets. That is, it scrolls the window so that the specified point is in the upper-left corner of the viewport. If you specify a point that is too close to the bottom or too close to the right edge of the document, the browser will move it as close as possible to the upper-left corner but won’t be able to get it all the way there. The following code scrolls the browser so that the bottom-most page of the document is visible: // Get the heights of the document and viewport. let documentHeight = document.documentElement.offsetHeight; let viewportHeight = window.innerHeight; // And scroll so the last \"page\" shows in the viewport window.scrollTo(0, documentHeight - viewportHeight); The scrollBy() method of the Window is similar to scrollTo(), but its arguments are relative and are added to the current scroll position: // Scroll 50 pixels down every 500 ms. Note there is no way to turn this off! setInterval(() =\u003e { scrollBy(0,50)}, 500); If you want to scroll smoothly with scrollTo() or scrollBy(), pass a single object argument instead of two numbers, like this: window.scrollTo({ left: 0, top: documentHeight - viewportHeight, behavior: \"smooth\" }); Often, instead of scrolling to a numeric location in a document, we just want to scroll so that a certain element in the document is visible. You can do this with the scrollIntoView() method on the desired HTML element. This method ensures that the element on which it is invoked is visible in the viewport. By default, it tries to put the top edge of the element at or near the top of the viewport. If false is passed as the only argument, it tries to put the bottom edge of the element at the bottom of the viewport. The browser will also scroll the viewport horizontally as needed to make the element visible. You can also pass an object to scrollIntoView(), setting the behavior:“smooth” property for smooth scrolling. You can set the block property to specify where the element should be positioned vertically and the inline property to specify how it should be positioned horizontally if horizontal scrolling is needed. Legal values for both of these properties are start, end, nearest, and center. ","date":"2020-11-02","objectID":"/posts/ch15/:5:4","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.5.5 Viewport Size, Content Size, and Scroll Position As we’ve discussed, browser windows and other HTML elements can display scrolling content. When this is the case, we sometimes need to know the size of the viewport, the size of the content, and the scroll offsets of the content within the viewport. This section covers these details. For browser windows, the viewport size is given by the window.innerWidth and window.innerHeight properties. (Web pages optimized for mobile devices often use a \u003cmeta name=\"viewport\"\u003e tag in their \u003chead\u003e to set the desired viewport width for the page.) The total size of the document is the same as the size of the \u003chtml\u003e element, document.documentElement. You can call getBoundingClientRect() on document.documentElement to get the width and height of the document, or you can use the offsetWidth and offsetHeight properties of document.documentElement. The scroll offsets of the document within its viewport are available as window.scrollX and window.scrollY. These are read-only properties, so you can’t set them to scroll the document: use window.scrollTo() instead. Things are a little more complicated for elements. Every Element object defines the following three groups of properties: offsetWidth clientWidth scrollWidth offsetHeight clientHeight scrollHeight offsetLeft clientLeft scrollLeft offsetTop clientTop scrollTop offsetParent The offsetWidth and offsetHeight properties of an element return its on-screen size in CSS pixels. The returned sizes include the element border and padding but not margins. The offsetLeft and offsetTop properties return the x and y coordinates of the element. For many elements, these values are document coordinates. But for descendants of positioned elements and for some other elements, such as table cells, these properties return coordinates that are relative to an ancestor element rather than the document itself. The offsetParent property specifies which element the properties are relative to. These offset properties are all read-only. clientWidth and clientHeight are like offsetWidth and offsetHeight except that they do not include the border size—only the content area and its padding. The clientLeft and clientTop properties are not very useful: they return the horizontal and vertical distance between the outside of an element’s padding and the outside of its border. Usually, these values are just the width of the left and top borders. These client properties are all read-only. For inline elements like \u003ci\u003e, \u003ccode\u003e, and \u003cspan\u003e, they all return 0. scrollWidth and scrollHeight return the size of an element’s content area plus its padding plus any overflowing content. When the content fits within the content area without overflow, these properties are the same as clientWidth and clientHeight. But when there is overflow, they include the overflowing content and return values larger than clientWidth and clientHeight. scrollLeft and scrollTop give the scroll offset of the element content within the element’s viewport. Unlike all the other properties described here, scrollLeft and scrollTop are writable properties, and you can set them to scroll the content within an element. (In most browsers, Element objects also have scrollTo() and scrollBy() methods like the Window object does, but these are not yet universally supported.) ","date":"2020-11-02","objectID":"/posts/ch15/:5:5","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.6 Web Components HTML is a language for document markup and defines a rich set of tags for that purpose. Over the last three decades, it has become a language that is used to describe the user interfaces of web applications, but basic HTML tags such as \u003cinput\u003e and \u003cbutton\u003e are inadequate for modern UI designs. Web developers are able to make it work, but only by using CSS and JavaScript to augment the appearance and behavior of basic HTML tags. Consider a typical user interface component, such as the search box shown in Figure 15-3. A search box user interface componentThe HTML \u003cinput\u003e element can be used to accept a single line of input from the user, but it doesn’t have any way to display icons like the magnifying glass on the left and the cancel X on the right. In order to implement a modern user interface element like this for the web, we need to use at least four HTML elements: an \u003cinput\u003e element to accept and display the user’s input, two \u003cimg\u003e elements (or in this case, two \u003cspan\u003e elements displaying Unicode glyphs), and a container \u003cdiv\u003e element to hold those three children. Furthermore, we have to use CSS to hide the default border of the \u003cinput\u003e element and define a border for the container. And we need to use JavaScript to make all the HTML elements work together. When the user clicks on the X icon, we need an event handler to clear the input from the \u003cinput\u003e element, for example. That is a lot of work to do every time you want to display a search box in a web application, and most web applications today are not written using “raw” HTML. Instead, many web developers use frameworks like React and Angular that support the creation of reusable user interface components like the search box shown here. Web components is a browser-native alternative to those frameworks based on three relatively recent additions to web standards that allow JavaScript to extend HTML with new tags that work as self-contained, reusable UI components. The subsections that follow explain how to use web components defined by other developers in your own web pages, then explain each of the three technologies that web components are based on, and finally tie all three together in an example that implements the search box element pictured in Figure 15-3. ","date":"2020-11-02","objectID":"/posts/ch15/:6:0","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.6.1 Using Web Components Web components are defined in JavaScript, so in order to use a web component in your HTML file, you need to include the JavaScript file that defines the component. Because web components are a relatively new technology, they are often written as JavaScript modules, so you might include one in your HTML like this: \u003cscript type=\"module\" src=\"components/search-box.js\"\u003e Web components define their own HTML tag names, with the important restriction that those tag names must include a hyphen. (This means that future versions of HTML can introduce new tags without hyphens, and there is no chance that the tags will conflict with anyone’s web component.) To use a web component, just use its tag in your HTML file: \u003csearch-box placeholder=\"Search...\"\u003e\u003c/search-box\u003e Web components can have attributes just like regular HTML tags can; the documentation for the component you are using should tell you which attributes are supported. Web components cannot be defined with self-closing tags. You cannot write \u003csearch-box/\u003e, for example. Your HTML file must include both the opening tag and the closing tag. Like regular HTML elements, some web components are written to expect children and others are written in such a way that they do not expect (and will not display) children. Some web components are written so that they can optionally accept specially labeled children that will appear in named “slots.” The \u003csearch-box\u003e component pictured in Figure 15-3 and implemented in Example 15-3 uses “slots” for the two icons it displays. If you want to to use a \u003csearch-box\u003e with different icons, you can use HTML like this: \u003csearch-box\u003e \u003cimg src=\"images/search-icon.png\" slot=\"left\"/\u003e \u003cimg src=\"images/cancel-icon.png\" slot=\"right\"/\u003e \u003c/search-box\u003e The slot attribute is an extension to HTML that it is used to specify which children should go where. The slot names—“left” and “right” in this example—are defined by the web component. If the component you are using supports slots, that fact should be included in its documentation. I previously noted that web components are often implemented as JavaScript modules and can be loaded into HTML files with a \u003cscript type=\"module\"\u003e tag. You may remember from the beginning of this chapter that modules are loaded after document content is parsed, as if they had a deferred tag. So this means that a web browser will typically parse and render tags like \u003csearch-box\u003e before it has run the code that will tell it what a \u003csearch-box\u003e is. This is normal when using web components. HTML parsers in web browsers are flexible and very forgiving about input that they do not understand. When they encounter a web component tag before that component has been defined, they add a generic HTMLElement to the DOM tree even though they do not know what to do with it. Later, when the custom element is defined, the generic element is “upgraded” so that it looks and behaves as desired. If a web component has children, then those children will probably be displayed incorrectly before the component is defined. You can use this CSS to keep web components hidden until they are defined: /* * Make the \u003csearch-box\u003e component invisible before it is defined. * And try to duplicate its eventual layout and size so that nearby * content does not move when it becomes defined. */ search-box:not(:defined) { opacity:0; display: inline-block; width: 300px; height: 50px; } Like regular HTML elements, web components can be used in JavaScript. If you include a \u003csearch-box\u003e tag in your web page, then you can obtain a reference to it with querySelector() and an appropriate CSS selector, just as you would for any other HTML tag. Generally, it only makes sense to do this after the module that defines the component has run, so be careful when querying web components that you do not do so too early. Web component implementations typically (but this is not a requirement) define a JavaScript property for each HTML attribute they support. And, like HTM","date":"2020-11-02","objectID":"/posts/ch15/:6:1","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.6.2 HTML Templates The HTML \u003ctemplate\u003e tag is only loosely related to web components, but it does enable a useful optimization for components that appear frequently in web pages. \u003ctemplate\u003e tags and their children are never rendered by a web browser and are only useful on web pages that use JavaScript. The idea behind this tag is that when a web page contains multiple repetitions of the same basic HTML structure (such as rows in a table or the internal implementation of a web component), then we can use a \u003ctemplate\u003e to define that element structure once, then use JavaScript to duplicate the structure as many times as needed. In JavaScript, a \u003ctemplate\u003e tag is represented by an HTMLTemplateElement object. This object defines a single content property, and the value of this property is a DocumentFragment of all the child nodes of the \u003ctemplate\u003e. You can clone this DocumentFragment and then insert the cloned copy into your document as needed. The fragment itself will not be inserted, but its children will be. Suppose you’re working with a document that includes a \u003ctable\u003e and \u003ctemplate id=\"row\"\u003e tag and that the template defines the structure of rows for that table. You might use the template like this: let tableBody = document.querySelector(\"tbody\"); let template = document.querySelector(\"#row\"); let clone = template.content.cloneNode(true); // deep clone // ...Use the DOM to insert content into the \u003ctd\u003e elements of the clone... // Now add the cloned and initialized row into the table tableBody.append(clone); Template elements do not have to appear literally in an HTML document in order to be useful. You can create a template in your JavaScript code, create its children with innerHTML, and then make as many clones as needed without the parsing overhead of innerHTML. This is how HTML templates are typically used in web components, and Example 15-3 demonstrates this technique. ","date":"2020-11-02","objectID":"/posts/ch15/:6:2","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.6.3 Custom Elements The second web browser feature that enables web components is “custom elements”: the ability to associate a JavaScript class with an HTML tag name so that any such tags in the document are automatically turned into instances of the class in the DOM tree. The customElements.define() method takes a web component tag name as its first argument (remember that the tag name must include a hyphen) and a subclass of HTMLElement as its second argument. Any existing elements in the document with that tag name are “upgraded” to newly created instances of the class. And if the browser parses any HTML in the future, it will automatically create an instance of the class for each of the tags it encounters. The class passed to customElements.define() should extend HTMLElement and not a more specific type like HTMLButtonElement.4 Recall from Chapter 9 that when a JavaScript class extends another class, the constructor function must call super() before it uses the this keyword, so if the custom element class has a constructor, it should call super() (with no arguments) before doing anything else. The browser will automatically invoke certain “lifecycle methods” of a custom element class. The connectedCallback() method is invoked when an instance of the custom element is inserted into the document, and many elements use this method to perform initialization. There is also a disconnectedCallback() method invoked when (and if) the element is removed from the document, though this is less often used. If a custom element class defines a static observedAttributes property whose value is an array of attribute names, and if any of the named attributes are set (or changed) on an instance of the custom element, the browser will invoke the attributeChangedCallback() method, passing the attribute name, its old value, and its new value. This callback can take whatever steps are necessary to update the component based on its attribute values. Custom element classes can also define whatever other properties and methods they want to. Commonly, they will define getter and setter methods that make the element’s attributes available as JavaScript properties. As an example of a custom element, suppose we want to be able to display circles within paragraphs of regular text. We’d like to be able to write HTML like this in order to render mathematical story problems like the one shown in Figure 15-4: \u003cp\u003e The document has one marble: \u003cinline-circle\u003e\u003c/inline-circle\u003e. The HTML parser instantiates two more marbles: \u003cinline-circle diameter=\"1.2em\" color=\"blue\"\u003e\u003c/inline-circle\u003e \u003cinline-circle diameter=\".6em\" color=\"gold\"\u003e\u003c/inline-circle\u003e. How many marbles does the document contain now? \u003c/p\u003e An inline circle custom elementWe can implement this \u003cinline-circle\u003e custom element with the code shown in Example 15-2: Example 15-2. The \u003cinline-circle\u003e custom element customElements.define(\"inline-circle\", class InlineCircle extends HTMLElement { // The browser calls this method when an \u003cinline-circle\u003e element // is inserted into the document. There is also a disconnectedCallback() // that we don't need in this example. connectedCallback() { // Set the styles needed to create circles this.style.display = \"inline-block\"; this.style.borderRadius = \"50%\"; this.style.border = \"solid black 1px\"; this.style.transform = \"translateY(10%)\"; // If there is not already a size defined, set a default size // that is based on the current font size. if (!this.style.width) { this.style.width = \"0.8em\"; this.style.height = \"0.8em\"; } } // The static observedAttributes property specifies which attributes // we want to be notified about changes to. (We use a getter here since // we can only use \"static\" with methods.) static get observedAttributes() { return [\"diameter\", \"color\"]; } // This callback is invoked when one of the attributes listed above // changes, either when the custom element is first parsed, or later. attributeChangedCallback(name, oldValue, newValue) { switch(na","date":"2020-11-02","objectID":"/posts/ch15/:6:3","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.6.4 Shadow DOM The custom element demonstrated in Example 15-2 is not well encapsulated. When you set its diameter or color attributes, it responds by altering its own style attribute, which is not behavior we would ever expect from a real HTML element. To turn a custom element into a true web component, it should use the powerful encapsulation mechanism known as shadow DOM. Shadow DOM allows a “shadow root” to be attached to a custom element (and also to a \u003cdiv\u003e, \u003cspan\u003e, \u003cbody\u003e, \u003carticle\u003e, \u003cmain\u003e, \u003cnav\u003e, \u003cheader\u003e, \u003cfooter\u003e, \u003csection\u003e, \u003cp\u003e, \u003cblockquote\u003e, \u003caside\u003e, or \u003ch1\u003e through \u003ch6\u003e element) known as a “shadow host.” Shadow host elements, like all HTML elements, are already the root of a normal DOM tree of descendant elements and text nodes. A shadow root is the root of another, more private, tree of descendant elements that sprouts from the shadow host and can be thought of as a distinct minidocument. The word “shadow” in “shadow DOM” refers to the fact that elements that descend from a shadow root are “hiding in the shadows”: they are not part of the normal DOM tree, do not appear in the children array of their host element, and are not visited by normal DOM traversal methods such as querySelector(). For contrast, the normal, regular DOM children of a shadow host are sometimes referred to as the “light DOM.” To understand the purpose of the shadow DOM, picture the HTML \u003caudio\u003e and \u003cvideo\u003e elements: they display a nontrivial user interface for controlling media playback, but the play and pause buttons and other UI elements are not part of the DOM tree and cannot be manipulated by JavaScript. Given that web browsers are designed to display HTML, it is only natural that browser vendors would want to display internal UIs like these using HTML. In fact, most browsers have been doing something like that for a long time, and the shadow DOM makes it a standard part of the web platform. SHADOW DOM ENCAPSULATION The key feature of shadow DOM is the encapsulation it provides. The descendants of a shadow root are hidden from—and independent from—the regular DOM tree, almost as if they were in an independent document. There are three very important kinds of encapsulation provided by the shadow DOM: As already mentioned, elements in the shadow DOM are hidden from regular DOM methods like querySelectorAll(). When a shadow root is created and attached to its shadow host, it can be created in “open” or “closed” mode. A closed shadow root is completely sealed away and inaccessible. More commonly, though, shadow roots are created in “open” mode, which means that the shadow host has a shadowRoot property that JavaScript can use to gain access to the elements of the shadow root, if it has some reason to do so. Styles defined beneath a shadow root are private to that tree and will never affect the light DOM elements on the outside. (A shadow root can define default styles for its host element, but these will be overridden by light DOM styles.) Similarly, the light DOM styles that apply to the shadow host element have no effect on the descendants of the shadow root. Elements in the shadow DOM will inherit things like font size and background color from the light DOM, and styles in the shadow DOM can choose to use CSS variables defined in the light DOM. For the most part, however, the styles of the light DOM and the styles of the shadow DOM are completely independent: the author of a web component and the user of a web component do not have to worry about collisions or conflicts between their stylesheets. Being able to “scope” CSS in this way is perhaps the most important feature of the shadow DOM. Some events (like “load”) that occur within the shadow DOM are confined to the shadow DOM. Others, including focus, mouse, and keyboard events bubble up and out. When an event that originates in the shadow DOM crosses the boundary and begins to propagate in the light DOM, its target property is changed to the shadow host element, so it appears to hav","date":"2020-11-02","objectID":"/posts/ch15/:6:4","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.6.5 Example: a \u003csearch-box\u003e Web Component Figure 15-3 illustrated a \u003csearch-box\u003e web component. Example 15-3 demonstrates the three enabling technologies that define web components: it implements the \u003csearch-box\u003e component as a custom element that uses a \u003ctemplate\u003e tag for efficiency and a shadow root for encapsulation. This example shows how to use the low-level web component APIs directly. In practice, many web components developed today create them using higher-level libraries such as “lit-element.” One of the reasons to use a library is that creating reusable and customizable components is actually quite hard to do well, and there are many details to get right. Example 15-3 demonstrates web components and does some basic keyboard focus handling, but otherwise ignores accessibility and makes no attempt to use proper ARIA attributes to make the component work with screen readers and other assistive technology. Example 15-3. Implementing a web component /** * This class defines a custom HTML \u003csearch-box\u003e element that displays an * \u003cinput\u003e text input field plus two icons or emoji. By default, it displays a * magnifying glass emoji (indicating search) to the left of the text field * and an X emoji (indicating cancel) to the right of the text field. It * hides the border on the input field and displays a border around itself, * creating the appearance that the two emoji are inside the input * field. Similarly, when the internal input field is focused, the focus ring * is displayed around the \u003csearch-box\u003e. * * You can override the default icons by including \u003cspan\u003e or \u003cimg\u003e children * of \u003csearch-box\u003e with slot=\"left\" and slot=\"right\" attributes. * * \u003csearch-box\u003e supports the normal HTML disabled and hidden attributes and * also size and placeholder attributes, which have the same meaning for this * element as they do for the \u003cinput\u003e element. * * Input events from the internal \u003cinput\u003e element bubble up and appear with * their target field set to the \u003csearch-box\u003e element. * * The element fires a \"search\" event with the detail property set to the * current input string when the user clicks on the left emoji (the magnifying * glass). The \"search\" event is also dispatched when the internal text field * generates a \"change\" event (when the text has changed and the user types * Return or Tab). * * The element fires a \"clear\" event when the user clicks on the right emoji * (the X). If no handler calls preventDefault() on the event then the element * clears the user's input once event dispatch is complete. * * Note that there are no onsearch and onclear properties or attributes: * handlers for the \"search\" and \"clear\" events can only be registered with * addEventListener(). */ class SearchBox extends HTMLElement { constructor() { super(); // Invoke the superclass constructor; must be first. // Create a shadow DOM tree and attach it to this element, setting // the value of this.shadowRoot. this.attachShadow({mode: \"open\"}); // Clone the template that defines the descendants and stylesheet for // this custom component, and append that content to the shadow root. this.shadowRoot.append(SearchBox.template.content.cloneNode(true)); // Get references to the important elements in the shadow DOM this.input = this.shadowRoot.querySelector(\"#input\"); let leftSlot = this.shadowRoot.querySelector('slot[name=\"left\"]'); let rightSlot = this.shadowRoot.querySelector('slot[name=\"right\"]'); // When the internal input field gets or loses focus, set or remove // the \"focused\" attribute which will cause our internal stylesheet // to display or hide a fake focus ring on the entire component. Note // that the \"blur\" and \"focus\" events bubble and appear to originate // from the \u003csearch-box\u003e. this.input.onfocus = () =\u003e { this.setAttribute(\"focused\", \"\"); }; this.input.onblur = () =\u003e { this.removeAttribute(\"focused\");}; // If the user clicks on the magnifying glass, trigger a \"search\" // event. Also trigger it if the input field fires a \"change\" // event. (The ","date":"2020-11-02","objectID":"/posts/ch15/:6:5","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.7 SVG: Scalable Vector Graphics SVG (scalable vector graphics) is an image format. The word “vector” in its name indicates that it is fundamentally different from raster image formats, such as GIF, JPEG, and PNG, that specify a matrix of pixel values. Instead, an SVG “image” is a precise, resolution-independent (hence “scalable”) description of the steps necessary to draw the desired graphic. SVG images are described by text files using the XML markup language, which is quite similar to HTML. There are three ways you can use SVG in web browsers: You can use .svg image files with regular HTML \u003cimg\u003e tags, just as you would use a .png or .jpeg image. Because the XML-based SVG format is so similar to HTML, you can actually embed SVG tags directly into your HTML documents. If you do this, the browser’s HTML parser allows you to omit XML namespaces and treat SVG tags as if they were HTML tags. You can use the DOM API to dynamically create SVG elements to generate images on demand. The subsections that follow demonstrate the second and third uses of SVG. Note, however, that SVG has a large and moderately complex grammar. In addition to simple shape-drawing primitives, it includes support for arbitrary curves, text, and animation. SVG graphics can even incorporate JavaScript scripts and CSS stylesheets to add behavior and presentation information. A full description of SVG is well beyond the scope of this book. The goal of this section is just to show you how you can use SVG in your HTML documents and script it with JavaScript. ","date":"2020-11-02","objectID":"/posts/ch15/:7:0","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.7.1 SVG in HTML SVG images can, of course, be displayed using HTML \u003cimg\u003e tags. But you can also embed SVG directly in HTML. And if you do this, you can even use CSS stylesheets to specify things like fonts, colors, and line widths. Here, for example, is an HTML file that uses SVG to display an analog clock face: \u003chtml\u003e \u003chead\u003e \u003ctitle\u003eAnalog Clock\u003c/title\u003e \u003cstyle\u003e /* These CSS styles all apply to the SVG elements defined below */ #clock { /* Styles for everything in the clock:*/ stroke: black; /* black lines */ stroke-linecap: round; /* with rounded ends */ fill: #ffe; /* on an off-white background */ } #clock .face { stroke-width: 3; } /* Clock face outline */ #clock .ticks { stroke-width: 2; } /* Lines that mark each hour */ #clock .hands { stroke-width: 3; } /* How to draw the clock hands */ #clock .numbers { /* How to draw the numbers */ font-family: sans-serif; font-size: 10; font-weight: bold; text-anchor: middle; stroke: none; fill: black; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003csvg id=\"clock\" viewBox=\"0 0 100 100\" width=\"250\" height=\"250\"\u003e \u003c!-- The width and height attributes are the screen size of the graphic --\u003e \u003c!-- The viewBox attribute gives the internal coordinate system --\u003e \u003ccircle class=\"face\" cx=\"50\" cy=\"50\" r=\"45\"/\u003e \u003c!-- the clock face --\u003e \u003cg class=\"ticks\"\u003e \u003c!-- tick marks for each of the 12 hours --\u003e \u003cline x1='50' y1='5.000' x2='50.00' y2='10.00'/\u003e \u003cline x1='72.50' y1='11.03' x2='70.00' y2='15.36'/\u003e \u003cline x1='88.97' y1='27.50' x2='84.64' y2='30.00'/\u003e \u003cline x1='95.00' y1='50.00' x2='90.00' y2='50.00'/\u003e \u003cline x1='88.97' y1='72.50' x2='84.64' y2='70.00'/\u003e \u003cline x1='72.50' y1='88.97' x2='70.00' y2='84.64'/\u003e \u003cline x1='50.00' y1='95.00' x2='50.00' y2='90.00'/\u003e \u003cline x1='27.50' y1='88.97' x2='30.00' y2='84.64'/\u003e \u003cline x1='11.03' y1='72.50' x2='15.36' y2='70.00'/\u003e \u003cline x1='5.000' y1='50.00' x2='10.00' y2='50.00'/\u003e \u003cline x1='11.03' y1='27.50' x2='15.36' y2='30.00'/\u003e \u003cline x1='27.50' y1='11.03' x2='30.00' y2='15.36'/\u003e \u003c/g\u003e \u003cg class=\"numbers\"\u003e \u003c!-- Number the cardinal directions--\u003e \u003ctext x=\"50\" y=\"18\"\u003e12\u003c/text\u003e\u003ctext x=\"85\" y=\"53\"\u003e3\u003c/text\u003e \u003ctext x=\"50\" y=\"88\"\u003e6\u003c/text\u003e\u003ctext x=\"15\" y=\"53\"\u003e9\u003c/text\u003e \u003c/g\u003e \u003cg class=\"hands\"\u003e \u003c!-- Draw hands pointing straight up. --\u003e \u003cline class=\"hourhand\" x1=\"50\" y1=\"50\" x2=\"50\" y2=\"25\"/\u003e \u003cline class=\"minutehand\" x1=\"50\" y1=\"50\" x2=\"50\" y2=\"20\"/\u003e \u003c/g\u003e \u003c/svg\u003e \u003cscript src=\"clock.js\"\u003e\u003c/script\u003e \u003c/body\u003e \u003c/html\u003e You’ll notice that the descendants of the \u003csvg\u003e tag are not normal HTML tags. \u003ccircle\u003e, \u003cline\u003e, and \u003ctext\u003e tags have obvious purposes, though, and it should be clear how this SVG graphic works. There are many other SVG tags, however, and you’ll need to consult an SVG reference to learn more. You may also notice that the stylesheet is odd. Styles like fill, stroke-width, and text-anchor are not normal CSS style properties. In this case, CSS is essentially being used to set attributes of SVG tags that appear in the document. Note also that the CSS font shorthand property does not work for SVG tags, and you must explicitly set font-family, font-size, and font-weight as separate style properties. ","date":"2020-11-02","objectID":"/posts/ch15/:7:1","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.7.2 Scripting SVG One reason to embed SVG directly into your HTML files (instead of just using static \u003cimg\u003e tags) is that if you do this, then you can use the DOM API to manipulate the SVG image. Suppose you use SVG to display icons in your web application. You could embed SVG within a \u003ctemplate\u003e tag (§15.6.2) and then clone the template content whenever you need to insert a copy of that icon into your UI. And if you want the icon to respond to user activity—by changing color when the user hovers the pointer over it, for example—you can often achieve this with CSS. It is also possible to dynamically manipulate SVG graphics that are directly embedded in HTML. The clock face example in the previous section displays a static clock with hour and minute hands facing straight up displaying the time noon or midnight. But you may have noticed that the HTML file includes a \u003cscript\u003e tag. That script runs a function periodically to check the time and transform the hour and minute hands by rotating them the appropriate number of degrees so that the clock actually displays the current time, as shown in Figure 15-5. A scripted SVG analog clockThe code to manipulate the clock is straightforward. It determines the proper angle of the hour and minute hands based on the current time, then uses querySelector() to look up the SVG elements that display those hands, then sets a transform attribute on them to rotate them around the center of the clock face. The function uses setTimeout() to ensure that it runs once a minute: (function updateClock() { // Update the SVG clock graphic to show current time let now = new Date(); // Current time let sec = now.getSeconds(); // Seconds let min = now.getMinutes() + sec/60; // Fractional minutes let hour = (now.getHours() % 12) + min/60; // Fractional hours let minangle = min * 6; // 6 degrees per minute let hourangle = hour * 30; // 30 degrees per hour // Get SVG elements for the hands of the clock let minhand = document.querySelector(\"#clock .minutehand\"); let hourhand = document.querySelector(\"#clock .hourhand\"); // Set an SVG attribute on them to move them around the clock face minhand.setAttribute(\"transform\", `rotate(${minangle},50,50)`); hourhand.setAttribute(\"transform\", `rotate(${hourangle},50,50)`); // Run this function again in 10 seconds setTimeout(updateClock, 10000); }()); // Note immediate invocation of the function here. ","date":"2020-11-02","objectID":"/posts/ch15/:7:2","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.7.3 Creating SVG Images with JavaScript In addition to simply scripting SVG images embedded in your HTML documents, you can also build SVG images from scratch, which can be useful to create visualizations of dynamically loaded data, for example. Example 15-4 demonstrates how you can use JavaScript to create SVG pie charts, like the one shown in Figure 15-6. Even though SVG tags can be included within HTML documents, they are technically XML tags, not HTML tags, and if you want to create SVG elements with the JavaScript DOM API, you can’t use the normal createElement() function that was introduced in §15.3.5. Instead you must use createElementNS(), which takes an XML namespace string as its first argument. For SVG, that namespace is the literal string “http://www.w3.org/2000/svg.” An SVG pie chart built with JavaScript (data from Stack Overflow’s 2018 Developer Survey of Most Popular Technologies)Other than the use of createElementNS(), the pie chart–drawing code in Example 15-4 is relatively straightforward. There is a little math to convert the data being charted into pie-slice angles. The bulk of the example, however, is DOM code that creates SVG elements and sets attributes on those elements. The most opaque part of this example is the code that draws the actual pie slices. The element used to display each slice is \u003cpath\u003e. This SVG element describes arbitrary shapes comprised of lines and curves. The shape description is specified by the d attribute of the \u003cpath\u003e element. The value of this attribute uses a compact grammar of letter codes and numbers that specify coordinates, angles, and other values. The letter M, for example, means “move to” and is followed by x and y coordinates. The letter L means “line to” and draws a line from the current point to the coordinates that follow it. This example also uses the letter A to draw an arc. This letter is followed by seven numbers describing the arc, and you can look up the syntax online if you want to know more. Example 15-4. Drawing a pie chart with JavaScript and SVG /** * Create an \u003csvg\u003e element and draw a pie chart into it. * * This function expects an object argument with the following properties: * * width, height: the size of the SVG graphic, in pixels * cx, cy, r: the center and radius of the pie * lx, ly: the upper-left corner of the chart legend * data: an object whose property names are data labels and whose * property values are the values associated with each label * * The function returns an \u003csvg\u003e element. The caller must insert it into * the document in order to make it visible. */ function pieChart(options) { let {width, height, cx, cy, r, lx, ly, data} = options; // This is the XML namespace for svg elements let svg = \"http://www.w3.org/2000/svg\"; // Create the \u003csvg\u003e element, and specify pixel size and user coordinates let chart = document.createElementNS(svg, \"svg\"); chart.setAttribute(\"width\", width); chart.setAttribute(\"height\", height); chart.setAttribute(\"viewBox\", `0 0 ${width}${height}`); // Define the text styles we'll use for the chart. If we leave these // values unset here, they can be set with CSS instead. chart.setAttribute(\"font-family\", \"sans-serif\"); chart.setAttribute(\"font-size\", \"18\"); // Get labels and values as arrays and add up the values so we know how // big the pie is. let labels = Object.keys(data); let values = Object.values(data); let total = values.reduce((x,y) =\u003e x+y); // Figure out the angles for all the slices. Slice i starts at angles[i] // and ends at angles[i+1]. The angles are measured in radians. let angles = [0]; values.forEach((x, i) =\u003e angles.push(angles[i] + x/total * 2 * Math.PI)); // Now loop through the slices of the pie values.forEach((value, i) =\u003e { // Compute the two points where our slice intersects the circle // These formulas are chosen so that an angle of 0 is at 12 o'clock // and positive angles increase clockwise. let x1 = cx + r * Math.sin(angles[i]); let y1 = cy - r * Math.cos(angles[i]); let x2 = cx + r ","date":"2020-11-02","objectID":"/posts/ch15/:7:3","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.8 Graphics in a \u003ccanvas\u003e The \u003ccanvas\u003e element has no appearance of its own but creates a drawing surface within the document and exposes a powerful drawing API to client-side JavaScript. The main difference between the \u003ccanvas\u003e API and SVG is that with the canvas you create drawings by calling methods, and with SVG you create drawings by building a tree of XML elements. These two approaches are equivalently powerful: either one can be simulated with the other. On the surface, they are quite different, however, and each has its strengths and weaknesses. An SVG drawing, for example, is easily edited by removing elements from its description. To remove an element from the same graphic in a \u003ccanvas\u003e, it is often necessary to erase the drawing and redraw it from scratch. Since the Canvas drawing API is JavaScript-based and relatively compact (unlike the SVG grammar), it is documented in more detail in this book. 3D GRAPHICS IN A CANVAS You can also call getContext() with the string “webgl” to obtain a context object that allows you to draw 3D graphics using the WebGL API. WebGL is a large, complicated, and low-level API that allows JavaScript programmers to access the GPU, write custom shaders, and perform other very powerful graphics operations. WebGL is not documented in this book, however: web developers are more likely to use utility libraries built on top of WebGL than to use the WebGL API directly. Most of the Canvas drawing API is defined not on the \u003ccanvas\u003e element itself, but instead on a “drawing context” object obtained with the getContext() method of the canvas. Call getContext() with the argument “2d” to obtain a CanvasRenderingContext2D object that you can use to draw two-dimensional graphics into the canvas. As a simple example of the Canvas API, the following HTML document uses \u003ccanvas\u003e elements and some JavaScript to display two simple shapes: \u003cp\u003eThis is a red square: \u003ccanvas id=\"square\" width=10 height=10\u003e\u003c/canvas\u003e. \u003cp\u003eThis is a blue circle: \u003ccanvas id=\"circle\" width=10 height=10\u003e\u003c/canvas\u003e. \u003cscript\u003e let canvas = document.querySelector(\"#square\"); // Get first canvas element let context = canvas.getContext(\"2d\"); // Get 2D drawing context context.fillStyle = \"#f00\"; // Set fill color to red context.fillRect(0,0,10,10); // Fill a square canvas = document.querySelector(\"#circle\"); // Second canvas element context = canvas.getContext(\"2d\"); // Get its context context.beginPath(); // Begin a new \"path\" context.arc(5, 5, 5, 0, 2*Math.PI, true); // Add a circle to the path context.fillStyle = \"#00f\"; // Set blue fill color context.fill(); // Fill the path \u003c/script\u003e We’ve seen that SVG describes complex shapes as a “path” of lines and curves that can be drawn or filled. The Canvas API also uses the notion of a path. Instead of describing a path as a string of letters and numbers, a path is defined by a series of method calls, such as the beginPath() and arc() invocations in the preceding code. Once a path is defined, other methods, such as fill(), operate on that path. Various properties of the context object, such as fillStyle, specify how these operations are performed. The subsections that follow demonstrate the methods and properties of the 2D Canvas API. Much of the example code that follows operates on a variable c. This variable holds the CanvasRenderingContext2D object of the canvas, but the code to initialize that variable is sometimes not shown. In order to make these examples run, you would need to add HTML markup to define a canvas with appropriate width and height attributes, and then add code like this to initialize the variable c: let canvas = document.querySelector(\"#my_canvas_id\"); let c = canvas.getContext('2d'); ","date":"2020-11-02","objectID":"/posts/ch15/:8:0","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.8.1 Paths and Polygons To draw lines on a canvas and to fill the areas enclosed by those lines, you begin by defining a path. A path is a sequence of one or more subpaths. A subpath is a sequence of two or more points connected by line segments (or, as we’ll see later, by curve segments). Begin a new path with the beginPath() method. Begin a new subpath with the moveTo() method. Once you have established the starting point of a subpath with moveTo(), you can connect that point to a new point with a straight line by calling lineTo(). The following code defines a path that includes two line segments: c.beginPath(); // Start a new path c.moveTo(100, 100); // Begin a subpath at (100,100) c.lineTo(200, 200); // Add a line from (100,100) to (200,200) c.lineTo(100, 200); // Add a line from (200,200) to (100,200) This code simply defines a path; it does not draw anything on the canvas. To draw (or “stroke”) the two line segments in the path, call the stroke() method, and to fill the area defined by those line segments, call fill(): c.fill(); // Fill a triangular area c.stroke(); // Stroke two sides of the triangle This code (along with some additional code to set line widths and fill colors) produced the drawing shown in Figure 15-7. A simple path, filled and strokedNotice that the subpath defined in Figure 15-7 is “open.” It consists of just two line segments, and the end point is not connected back to the starting point. This means that it does not enclose a region. The fill() method fills open subpaths by acting as if a straight line connected the last point in the subpath to the first point in the subpath. That is why this code fills a triangle, but strokes only two sides of the triangle. If you wanted to stroke all three sides of the triangle just shown, you would call the closePath() method to connect the end point of the subpath to the start point. (You could also call lineTo(100,100), but then you end up with three line segments that share a start and end point but are not truly closed. When drawing with wide lines, the visual results are better if you use closePath().) There are two other important points to notice about stroke() and fill(). First, both methods operate on all subpaths in the current path. Suppose we had added another subpath in the preceding code: c.moveTo(300,100); // Begin a new subpath at (300,100); c.lineTo(300,200); // Draw a vertical line down to (300,200); If we then called stroke(), we would draw two connected edges of a triangle and a disconnected vertical line. The second point to note about stroke() and fill() is that neither one alters the current path: you can call fill() and the path will still be there when you call stroke(). When you are done with a path and want to begin another, you must remember to call beginPath(). If you don’t, you’ll end up adding new subpaths to the existing path, and you may end up drawing those old subpaths over and over again. Example 15-5 defines a function for drawing regular polygons and demonstrates the use of moveTo(), lineTo(), and closePath() for defining subpaths and of fill() and stroke() for drawing those paths. It produces the drawing shown in Figure 15-8. Regular polygonsExample 15-5. Regular polygons with moveTo(), lineTo(), and closePath() // Define a regular polygon with n sides, centered at (x,y) with radius r. // The vertices are equally spaced along the circumference of a circle. // Put the first vertex straight up or at the specified angle. // Rotate clockwise, unless the last argument is true. function polygon(c, n, x, y, r, angle=0, counterclockwise=false) { c.moveTo(x + r*Math.sin(angle), // Begin a new subpath at the first vertex y - r*Math.cos(angle)); // Use trigonometry to compute position let delta = 2*Math.PI/n; // Angular distance between vertices for(let i = 1; i \u003c n; i++) { // For each of the remaining vertices angle += counterclockwise?-delta:delta; // Adjust angle c.lineTo(x + r*Math.sin(angle), // Add line to next vertex y - r*Mat","date":"2020-11-02","objectID":"/posts/ch15/:8:1","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.8.2 Canvas Dimensions and Coordinates The width and height attributes of the \u003ccanvas\u003e element and the corresponding width and height properties of the Canvas object specify the dimensions of the canvas. The default canvas coordinate system places the origin (0,0) at the upper-left corner of the canvas. The x coordinates increase to the right and the y coordinates increase as you go down the screen. Points on the canvas can be specified using floating-point values. The dimensions of a canvas cannot be altered without completely resetting the canvas. Setting either the width or height properties of a Canvas (even setting them to their current value) clears the canvas, erases the current path, and resets all graphics attributes (including current transformation and clipping region) to their original state. The width and height attributes of a canvas specify the actual number of pixels that the canvas can draw into. Four bytes of memory are allocated for each pixel, so if width and height are both set to 100, the canvas allocates 40,000 bytes to represent 10,000 pixels. The width and height attributes also specify the default size (in CSS pixels) at which the canvas will be displayed on the screen. If window.devicePixelRatio is 2, then 100 × 100 CSS pixels is actually 40,000 hardware pixels. When the contents of the canvas are drawn onto the screen, the 10,000 pixels in memory will need to be enlarged to cover 40,000 physical pixels on the screen, and this means that your graphics will not be as crisp as they could be. For optimum image quality, you should not use the width and height attributes to set the on-screen size of the canvas. Instead, set the desired on-screen size CSS pixel size of the canvas with CSS width and height style attributes. Then, before you begin drawing in your JavaScript code, set the width and height properties of the canvas object to the number of CSS pixels times window.devicePixelRatio. Continuing with the preceding example, this technique would result in the canvas being displayed at 100 × 100 CSS pixels but allocating memory for 200 × 200 pixels. (Even with this technique, the user can zoom in on the canvas and may see fuzzy or pixelated graphics if they do. This is in contrast to SVG graphics, which remain crisp no matter the on-screen size or zoom level.) ","date":"2020-11-02","objectID":"/posts/ch15/:8:2","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.8.3 Graphics Attributes Example 15-5 set the properties fillStyle, strokeStyle, and lineWidth on the context object of the canvas. These properties are graphics attributes that specify the color to be used by fill() and by stroke(), and the width of the lines to be drawn by stroke(). Notice that these parameters are not passed to the fill() and stroke() methods, but are instead part of the general graphics state of the canvas. If you define a method that draws a shape and do not set these properties yourself, the caller of your method can define the color of the shape by setting the strokeStyle and fillStyle properties before calling your method. This separation of graphics state from drawing commands is fundamental to the Canvas API and is akin to the separation of presentation from content achieved by applying CSS stylesheets to HTML documents. There are a number of properties (and also some methods) on the context object that affect the graphics state of the canvas. They are detailed below. LINE STYLES The lineWidth property specifies how wide (in CSS pixels) the lines drawn by stroke() will be. The default value is 1. It is important to understand that line width is determined by the lineWidth property at the time stroke() is called, not at the time that lineTo() and other path-building methods are called. To fully understand the lineWidth property, it is important to visualize paths as infinitely thin one-dimensional lines. The lines and curves drawn by the stroke() method are centered over the path, with half of the lineWidth on either side. If you’re stroking a closed path and only want the line to appear outside the path, stroke the path first, then fill with an opaque color to hide the portion of the stroke that appears inside the path. Or if you only want the line to appear inside a closed path, call the save() and clip() methods first, then call stroke() and restore(). (The save(), restore(), and clip() methods are described later.) When drawing lines that are more than about two pixels wide, the lineCap and lineJoin properties can have a significant impact on the visual appearance of the ends of a path and the vertices at which two path segments meet. Figure 15-9 illustrates the values and resulting graphical appearance of lineCap and lineJoin. The lineCap and lineJoin attributesThe default value for lineCap is “butt.” The default value for lineJoin is “miter.” Note, however, that if two lines meet at a very narrow angle, then the resulting miter can become quite long and visually distracting. If the miter at a given vertex would be longer than half of the line width times the miterLimit property, that vertex will be drawn with a beveled join instead of a mitered join. The default value for miterLimit is 10. The stroke() method can draw dashed and dotted lines as well as solid lines, and a canvas’s graphics state includes an array of numbers that serves as a “dash pattern” by specifying how many pixels to draw, then how many to omit. Unlike other line-drawing properties, the dash pattern is set and queried with the methods setLineDash() and getLineDash() instead of with a property. To specify a dotted dash pattern, you might use setLineDash() like this: c.setLineDash([18, 3, 3, 3]); // 18px dash, 3px space, 3px dot, 3px space Finally, the lineDashOffset property specifies how far into the dash pattern drawing should begin. The default is 0. Paths stroked with the dash pattern shown here begin with an 18-pixel dash, but if lineDashOffset is set to 21, then that same path would begin with a dot followed by a space and a dash. COLORS, PATTERNS, AND GRADIENTS The fillStyle and strokeStyle properties specify how paths are filled and stroked. The word “style” often means color, but these properties can also be used to specify a color gradient or an image to be used for filling and stroking. (Note that drawing a line is basically the same as filling a narrow region on both sides of the line, and filling and stroking ar","date":"2020-11-02","objectID":"/posts/ch15/:8:3","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.8.4 Canvas Drawing Operations We’ve already seen some basic canvas methods—beginPath(), moveTo(), lineTo(), closePath(), fill(), and stroke()—for defining, filling, and drawing lines and polygons. But the Canvas API includes other drawing methods as well. RECTANGLES CanvasRenderingContext2D defines four methods for drawing rectangles. All four of these rectangle methods expect two arguments that specify one corner of the rectangle followed by the rectangle width and height. Normally, you specify the upper-left corner and then pass a positive width and positive height, but you may also specify other corners and pass negative dimensions. fillRect() fills the specified rectangle with the current fillStyle. strokeRect() strokes the outline of the specified rectangle using the current strokeStyle and other line attributes. clearRect() is like fillRect(), but it ignores the current fill style and fills the rectangle with transparent black pixels (the default color of all blank canvases). The important thing about these three methods is that they do not affect the current path or the current point within that path. The final rectangle method is named rect(), and it does affect the current path: it adds the specified rectangle, in a subpath of its own, to the path. Like other path-definition methods, it does not fill or stroke anything itself. CURVES A path is a sequence of subpaths, and a subpath is a sequence of connected points. In the paths we defined in §15.8.1, those points were connected with straight line segments, but that need not always be the case. The CanvasRenderingContext2D object defines a number of methods that add a new point to the subpath and connect the current point to that new point with a curve: arc() This method adds a circle, or a portion of a circle (an arc), to the path. The arc to be drawn is specified with six parameters: the x and y coordinates of the center of a circle, the radius of the circle, the start and end angles of the arc, and the direction (clockwise or counterclockwise) of the arc between those two angles. If there is a current point in the path, then this method connects the current point to the beginning of the arc with a straight line (which is useful when drawing wedges or pie slices), then connects the beginning of the arc to the end of the arc with a portion of a circle, leaving the end of the arc as the new current point. If there is no current point when this method is called, then it only adds the circular arc to the path. ellipse() This method is much like arc() except that it adds an ellipse or a portion of an ellipse to the path. Instead of one radius, it has two: an x-axis radius and a y-axis radius. Also, because ellipses are not radially symmetrical, this method takes another argument that specifies the number of radians by which the ellipse is rotated clockwise about its center. arcTo() This method draws a straight line and a circular arc just like the arc() method does, but it specifies the arc to be drawn using different parameters. The arguments to arcTo() specify points P1 and P2 and a radius. The arc that is added to the path has the specified radius. It begins at the tangent point with the (imaginary) line from the current point to P1 and ends at the tangent point with the (imaginary) line between P1 and P2. This unusual-seeming method of specifying arcs is actually quite useful for drawing shapes with rounded corners. If you specify a radius of 0, this method just draws a straight line from the current point to P1. With a nonzero radius, however, it draws a straight line from the current point in the direction of P1, then curves that line around in a circle until it is heading in the direction of P2. bezierCurveTo() This method adds a new point P to the subpath and connects it to the current point with a cubic Bezier curve. The shape of the curve is specified by two “control points,” C1 and C2. At the start of the curve (at the current point), the curve heads in the ","date":"2020-11-02","objectID":"/posts/ch15/:8:4","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.8.5 Coordinate System Transforms As we’ve noted, the default coordinate system of a canvas places the origin in the upper-left corner, has x coordinates increasing to the right, and has y coordinates increasing downward. In this default system, the coordinates of a point map directly to a CSS pixel (which then maps directly to one or more device pixels). Certain canvas operations and attributes (such as extracting raw pixel values and setting shadow offsets) always use this default coordinate system. In addition to the default coordinate system, however, every canvas has a “current transformation matrix” as part of its graphics state. This matrix defines the current coordinate system of the canvas. In most canvas operations, when you specify the coordinates of a point, it is taken to be a point in the current coordinate system, not in the default coordinate system. The current transformation matrix is used to convert the coordinates you specified to the equivalent coordinates in the default coordinate system. The setTransform() method allows you to set a canvas’s transformation matrix directly, but coordinate system transformations are usually easier to specify as a sequence of translations, rotations, and scaling operations. Figure 15-11 illustrates these operations and their effect on the canvas coordinate system. The program that produced the figure drew the same set of axes seven times in a row. The only thing that changed each time was the current transform. Notice that the transforms affect the text as well as the lines that are drawn. Coordinate system transformationsThe translate() method simply moves the origin of the coordinate system left, right, up, or down. The rotate() method rotates the axes clockwise by the specified angle. (The Canvas API always specifies angles in radians. To convert degrees to radians, divide by 180 and multiply by Math.PI.) The scale() method stretches or contracts distances along the x or y axes. Passing a negative scale factor to the scale() method flips that axis across the origin, as if it were reflected in a mirror. This is what was done in the lower left of Figure 15-11: translate() was used to move the origin to the bottom-left corner of the canvas, then scale() was used to flip the y axis around so that y coordinates increase as we go up the page. A flipped coordinate system like this is familiar from algebra class and may be useful for plotting data points on charts. Note, however, that it makes text difficult to read! UNDERSTANDING TRANSFORMATIONS MATHEMATICALLY I find it easiest to understand transforms geometrically, thinking about translate(), rotate(), and scale() as transforming the axes of the coordinate system as illustrated in Figure 15-11. It is also possible to understand transforms algebraically as equations that map the coordinates of a point (x,y) in the transformed coordinate system back to the coordinates (x',y') of the same point in the previous coordinate system. The method call c.translate(dx,dy) can be described with these equations: x' = x + dx; // An X coordinate of 0 in the new system is dx in the old y' = y + dy; Scaling operations have similarly simple equations. A call c.scale(sx,sy) can be described like this: x' = sx * x; y' = sy * y; Rotations are more complicated. The call c.rotate(a) is described by these trigonometric equations: x' = x * cos(a) - y * sin(a); y' = y * cos(a) + x * sin(a); Notice that the order of transformations matters. Suppose we start with the default coordinate system of a canvas, then translate it, and then scale it. In order to map the point (x,y) in the current coordinate system back to the point (x'',y'') in the default coordinate system, we must first apply the scaling equations to map the point to an intermediate point (x',y') in the translated but unscaled coordinate system, then use the translation equations to map from this intermediate point to (x'',y''). The result is this: x'' = sx*x + dx; y'' = sy*y + dy; If, on th","date":"2020-11-02","objectID":"/posts/ch15/:8:5","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.8.6 Clipping After defining a path, you usually call stroke() or fill() (or both). You can also call the clip() method to define a clipping region. Once a clipping region is defined, nothing will be drawn outside of it. Figure 15-13 shows a complex drawing produced using clipping regions. The vertical stripe running down the middle and the text along the bottom of the figure were stroked with no clipping region and then filled after the triangular clipping region was defined. Unclipped strokes and clipped fillsFigure 15-13 was generated using the polygon() method of Example 15-5 and the following code: // Define some drawing attributes c.font = \"bold 60pt sans-serif\"; // Big font c.lineWidth = 2; // Narrow lines c.strokeStyle = \"#000\"; // Black lines // Outline a rectangle and some text c.strokeRect(175, 25, 50, 325); // A vertical stripe down the middle c.strokeText(\"\u003ccanvas\u003e\", 15, 330); // Note strokeText() instead of fillText() // Define a complex path with an interior that is outside. polygon(c,3,200,225,200); // Large triangle polygon(c,3,200,225,100,0,true); // Smaller reverse triangle inside // Make that path the clipping region. c.clip(); // Stroke the path with a 5 pixel line, entirely inside the clipping region. c.lineWidth = 10; // Half of this 10 pixel line will be clipped away c.stroke(); // Fill the parts of the rectangle and text that are inside the clipping region c.fillStyle = \"#aaa\"; // Light gray c.fillRect(175, 25, 50, 325); // Fill the vertical stripe c.fillStyle = \"#888\"; // Darker gray c.fillText(\"\u003ccanvas\u003e\", 15, 330); // Fill the text It is important to note that when you call clip(), the current path is itself clipped to the current clipping region, then that clipped path becomes the new clipping region. This means that the clip() method can shrink the clipping region but can never enlarge it. There is no method to reset the clipping region, so before calling clip(), you should typically call save() so that you can later restore() the unclipped region. ","date":"2020-11-02","objectID":"/posts/ch15/:8:6","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.8.7 Pixel Manipulation The getImageData() method returns an ImageData object that represents the raw pixels (as R, G, B, and A components) from a rectangular region of your canvas. You can create empty ImageData objects with createImageData(). The pixels in an ImageData object are writable, so you can set them any way you want, then copy those pixels back onto the canvas with putImageData(). These pixel manipulation methods provide very low-level access to the canvas. The rectangle you pass to getImageData() is in the default coordinate system: its dimensions are measured in CSS pixels, and it is not affected by the current transformation. When you call putImageData(), the position you specify is also measured in the default coordinate system. Furthermore, putImageData() ignores all graphics attributes. It does not perform any compositing, it does not multiply pixels by globalAlpha, and it does not draw shadows. Pixel manipulation methods are useful for implementing image processing. Example 15-8 shows how to create a simple motion blur or “smear” effect like that shown in Figure 15-14. A motion blur effect created by image processingThe following code demonstrates getImageData() and putImageData() and shows how to iterate through and modify the pixel values in an ImageData object. Example 15-8. Motion blur with ImageData // Smear the pixels of the rectangle to the right, producing a // sort of motion blur as if objects are moving from right to left. // n must be 2 or larger. Larger values produce bigger smears. // The rectangle is specified in the default coordinate system. function smear(c, n, x, y, w, h) { // Get the ImageData object that represents the rectangle of pixels to smear let pixels = c.getImageData(x, y, w, h); // This smear is done in-place and requires only the source ImageData. // Some image processing algorithms require an additional ImageData to // store transformed pixel values. If we needed an output buffer, we could // create a new ImageData with the same dimensions like this: // let output_pixels = c.createImageData(pixels); // Get the dimensions of the grid of pixels in the ImageData object let width = pixels.width, height = pixels.height; // This is the byte array that holds the raw pixel data, left-to-right and // top-to-bottom. Each pixel occupies 4 consecutive bytes in R,G,B,A order. let data = pixels.data; // Each pixel after the first in each row is smeared by replacing it with // 1/nth of its own value plus m/nths of the previous pixel's value let m = n-1; for(let row = 0; row \u003c height; row++) { // For each row let i = row*width*4 + 4; // The offset of the second pixel of the row for(let col = 1; col \u003c width; col++, i += 4) { // For each column data[i] = (data[i] + data[i-4]*m)/n; // Red pixel component data[i+1] = (data[i+1] + data[i-3]*m)/n; // Green data[i+2] = (data[i+2] + data[i-2]*m)/n; // Blue data[i+3] = (data[i+3] + data[i-1]*m)/n; // Alpha component } } // Now copy the smeared image data back to the same position on the canvas c.putImageData(pixels, x, y); } ","date":"2020-11-02","objectID":"/posts/ch15/:8:7","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.9 Audio APIs The HTML \u003caudio\u003e and \u003cvideo\u003e tags allow you to easily include sound and videos in your web pages. These are complex elements with significant APIs and nontrivial user interfaces. You can control media playback with the play() and pause() methods. You can set the volume and playbackRate properties to control the audio volume and speed of playback. And you can skip to a particular time within the media by setting the currentTime property. We will not cover \u003caudio\u003e and \u003cvideo\u003e tags in any further detail here, however. The following subsections demonstrate two ways to add scripted sound effects to your web pages. ","date":"2020-11-02","objectID":"/posts/ch15/:9:0","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.9.1 The Audio() Constructor You don’t have to include an \u003caudio\u003e tag in your HTML document in order to include sound effects in your web pages. You can dynamically create \u003caudio\u003e elements with the normal DOM document.createElement() method, or, as a shortcut, you can simply use the Audio() constructor. You do not have to add the created element to your document in order to play it. You can simply call its play() method: // Load the sound effect in advance so it is ready for use let soundeffect = new Audio(\"soundeffect.mp3\"); // Play the sound effect whenever the user clicks the mouse button document.addEventListener(\"click\", () =\u003e { soundeffect.cloneNode().play(); // Load and play the sound }); Note the use of cloneNode() here. If the user clicks the mouse rapidly, we want to be able to have multiple overlapping copies of the sound effect playing at the same time. To do that, we need multiple Audio elements. Because the Audio elements are not added to the document, they will be garbage collected when they are done playing. ","date":"2020-11-02","objectID":"/posts/ch15/:9:1","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.9.2 The WebAudio API In addition to playback of recorded sounds with Audio elements, web browsers also allow the generation and playback of synthesized sounds with the WebAudio API. Using the WebAudio API is like hooking up an old-style electronic synthesizer with patch cords. With WebAudio, you create a set of AudioNode objects, which represents sources, transformations, or destinations of waveforms, and then connect these nodes together into a network to produce sounds. The API is not particularly complex, but a full explanation requires an understanding of electronic music and signal processing concepts that are beyond the scope of this book. The following code below uses the WebAudio API to synthesize a short chord that fades out over about a second. This example demonstrates the basics of the WebAudio API. If this is interesting to you, you can find much more about this API online: // Begin by creating an audioContext object. Safari still requires // us to use webkitAudioContext instead of AudioContext. let audioContext = new (this.AudioContext||this.webkitAudioContext)(); // Define the base sound as a combination of three pure sine waves let notes = [ 293.7, 370.0, 440.0 ]; // D major chord: D, F# and A // Create oscillator nodes for each of the notes we want to play let oscillators = notes.map(note =\u003e { let o = audioContext.createOscillator(); o.frequency.value = note; return o; }); // Shape the sound by controlling its volume over time. // Starting at time 0 quickly ramp up to full volume. // Then starting at time 0.1 slowly ramp down to 0. let volumeControl = audioContext.createGain(); volumeControl.gain.setTargetAtTime(1, 0.0, 0.02); volumeControl.gain.setTargetAtTime(0, 0.1, 0.2); // We're going to send the sound to the default destination: // the user's speakers let speakers = audioContext.destination; // Connect each of the source notes to the volume control oscillators.forEach(o =\u003e o.connect(volumeControl)); // And connect the output of the volume control to the speakers. volumeControl.connect(speakers); // Now start playing the sounds and let them run for 1.25 seconds. let startTime = audioContext.currentTime; let stopTime = startTime + 1.25; oscillators.forEach(o =\u003e { o.start(startTime); o.stop(stopTime); }); // If we want to create a sequence of sounds we can use event handlers oscillators[0].addEventListener(\"ended\", () =\u003e { // This event handler is invoked when the note stops playing }); ","date":"2020-11-02","objectID":"/posts/ch15/:9:2","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.10 Location, Navigation, and History The location property of both the Window and Document objects refers to the Location object, which represents the current URL of the document displayed in the window, and which also provides an API for loading new documents into the window. The Location object is very much like a URL object (§11.9), and you can use properties like protocol, hostname, port, and path to access the various parts of the URL of the current document. The href property returns the entire URL as a string, as does the toString() method. The hash and search properties of the Location object are interesting ones. The hash property returns the “fragment identifier” portion of the URL, if there is one: a hash mark (#) followed by an element ID. The search property is similar. It returns the portion of the URL that starts with a question mark: often some sort of query string. In general, this portion of a URL is used to parameterize the URL and provides a way to embed arguments in it. While these arguments are usually intended for scripts run on a server, there is no reason why they cannot also be used in JavaScript-enabled pages. URL objects have a searchParams property that is a parsed representation of the search property. The Location object does not have a searchParams property, but if you want to parse window.location.search, you can simply create a URL object from the Location object and then use the URL’s searchParams: let url = new URL(window.location); let query = url.searchParams.get(\"q\"); let numResults = parseInt(url.searchParams.get(\"n\") || \"10\"); In addition to the Location object that you can refer to as window.location or document.location, and the URL() constructor that we used earlier, browsers also define a document.URL property. Surprisingly, the value of this property is not a URL object, but just a string. The string holds the URL of the current document. ","date":"2020-11-02","objectID":"/posts/ch15/:10:0","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.10.1 Loading New Documents If you assign a string to window.location or to document.location, that string is interpreted as a URL and the browser loads it, replacing the current document with a new one: window.location = \"http://www.oreilly.com\"; // Go buy some books! You can also assign relative URLs to location. They are resolved relative to the current URL: document.location = \"page2.html\"; // Load the next page A bare fragment identifier is a special kind of relative URL that does not cause the browser to load a new document but simply to scroll so that the document element with id or name that matches the fragment is visible at the top of the browser window. As a special case, the fragment identifier #top makes the browser jump to the start of the document (assuming no element has an id=“top” attribute): location = \"#top\"; // Jump to the top of the document The individual properties of the Location object are writable, and setting them changes the location URL and also causes the browser to load a new document (or, in the case of the hash property, to navigate within the current document): document.location.path = \"pages/3.html\"; // Load a new page document.location.hash = \"TOC\"; // Scroll to the table of contents location.search = \"?page=\" + (page+1); // Reload with new query string You can also load a new page by passing a new string to the assign() method of the Location object. This is the same as assigning the string to the location property, however, so it’s not particularly interesting. The replace() method of the Location object, on the other hand, is quite useful. When you pass a string to replace(), it is interpreted as a URL and causes the browser to load a new page, just as assign() does. The difference is that replace() replaces the current document in the browser’s history. If a script in document A sets the location property or calls assign() to load document B and then the user clicks the Back button, the browser will go back to document A. If you use replace() instead, then document A is erased from the browser’s history, and when the user clicks the Back button, the browser returns to whatever document was displayed before document A. When a script unconditionally loads a new document, the replace() method is a better choice than assign(). Otherwise, the Back button would take the browser back to the original document, and the same script would again load the new document. Suppose you have a JavaScript-enhanced version of your page and a static version that does not use JavaScript. If you determine that the user’s browser does not support the web platform APIs that you want to use, you could use location.replace() to load the static version: // If the browser does not support the JavaScript APIs we need, // redirect to a static page that does not use JavaScript. if (!isBrowserSupported()) location.replace(\"staticpage.html\"); Notice that the URL passed to replace() is a relative one. Relative URLs are interpreted relative to the page in which they appear, just as they would be if they were used in a hyperlink. In addition to the assign() and replace() methods, the Location object also defines reload(), which simply makes the browser reload the document. ","date":"2020-11-02","objectID":"/posts/ch15/:10:1","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.10.2 Browsing History The history property of the Window object refers to the History object for the window. The History object models the browsing history of a window as a list of documents and document states. The length property of the History object specifies the number of elements in the browsing history list, but for security reasons, scripts are not allowed to access the stored URLs. (If they could, any scripts could snoop through your browsing history.) The History object has back() and forward() methods that behave like the browser’s Back and Forward buttons do: they make the browser go backward or forward one step in its browsing history. A third method, go(), takes an integer argument and can skip any number of pages forward (for positive arguments) or backward (for negative arguments) in the history list: history.go(-2); // Go back 2, like clicking the Back button twice history.go(0); // Another way to reload the current page If a window contains child windows (such as \u003ciframe\u003e elements), the browsing histories of the child windows are chronologically interleaved with the history of the main window. This means that calling history.back() (for example) on the main window may cause one of the child windows to navigate back to a previously displayed document but leaves the main window in its current state. The History object described here dates back to the early days of the web when documents were passive and all computation was performed on the server. Today, web applications often generate or load content dynamically and display new application states without actually loading new documents. Applications like these must perform their own history management if they want the user to be able to use the Back and Forward buttons (or the equivalent gestures) to navigate from one application state to another in an intuitive way. There are two ways to accomplish this, described in the next two sections. ","date":"2020-11-02","objectID":"/posts/ch15/:10:2","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.10.3 History Management with hashchange Events One history management technique involves location.hash and the “hashchange” event. Here are the key facts you need to know to understand this technique: The location.hash property sets the fragment identifier of the URL and is traditionally used to specify the ID of a document section to scroll to. But location.hash does not have to be an element ID: you can set it to any string. As long as no element happens to have that string as its ID, the browser won’t scroll when you set the hash property like this. Setting the location.hash property updates the URL displayed in the location bar and, very importantly, adds an entry to the browser’s history. Whenever the fragment identifier of the document changes, the browser fires a “hashchange” event on the Window object. If you set location.hash explictly, a “hashchange” event is fired. And, as we’ve mentioned, this change to the Location object creates a new entry in the browser’s browsing history. So if the user now clicks the Back button, the browser will return to its previous URL before you set location.hash. But this means that the fragment identifier has changed again, so another “hashchange” event is fired in this case. This means that as long as you can create a unique fragment identifier for each possible state of your application, “hashchange” events will notify you if the user moves backward and forward though their browsing history. To use this history management mechanism, you’ll need to be able to encode the state information necessary to render a “page” of your application into a relatively short string of text that is suitable for use as a fragment identifier. And you’ll need to write a function to convert page state into a string and another function to parse the string and re-create the page state it represents. Once you have written those functions, the rest is easy. Define a window.onhashchange function (or register a “hashchange” listener with addEventListener()) that reads location.hash, converts that string into a representation of your application state, and then takes whatever actions are necessary to display that new application state. When the user interacts with your application (such as by clicking a link) in a way that would cause the application to enter a new state, don’t render the new state directly. Instead, encode the desired new state as a string and set location.hash to that string. This will trigger a “hashchange” event, and your handler for that event will display the new state. Using this roundabout technique ensures that the new state is inserted into the browsing history so that the Back and Forward buttons continue to work. ","date":"2020-11-02","objectID":"/posts/ch15/:10:3","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.10.4 History Management with pushState() The second technique for managing history is somewhat more complex but is less of a hack than the “hashchange” event. This more robust history-management technique is based on the history.pushState() method and the “popstate” event. When a web app enters a new state, it calls history.pushState() to add an object representing the state to the browser’s history. If the user then clicks the Back button, the browser fires a “popstate” event with a copy of that saved state object, and the app uses that object to re-create its previous state. In addition to the saved state object, applications can also save a URL with each state, which is important if you want users to be able to bookmark and share links to the internal states of the app. The first argument to pushState() is an object that contains all the state information necessary to restore the current state of the document. This object is saved using HTML’s structured clone algorithm, which is more versatile than JSON.stringify() and can support Map, Set, and Date objects as well as typed arrays and ArrayBuffers. The second argument was intended to be a title string for the state, but most browsers do not support it, and you should just pass an empty string. The third argument is an optional URL that will be displayed in the location bar immediately and also if the user returns to this state via Back and Forward buttons. Relative URLs are resolved against the current location of the document. Associating a URL with each state allows the user to bookmark internal states of your application. Remember, though, that if the user saves a bookmark and then visits it a day later, you won’t get a “popstate” event about that visit: you’ll have to restore your application state by parsing the URL. THE STRUCTURED CLONE ALGORITHM The history.pushState() method does not use JSON.stringify() (§11.6) to serialize state data. Instead, it (and other browser APIs we’ll learn about later) uses a more robust serialization technique known as the structured clone algorithm, defined by the HTML standard. The structured clone algorithm can serialize anything that JSON.stringify() can, but in addition, it enables serialization of most other JavaScript types, including Map, Set, Date, RegExp, and typed arrays, and it can handle data structures that include circular references. The structured clone algorithm cannot serialize functions or classes, however. When cloning objects it does not copy the prototype object, getters and setters, or non-enumerable properties. While the structured clone algorithm can clone most built-in JavaScript types, it cannot copy types defined by the host environment, such as document Element objects. This means that the state object you pass to history.pushState() need not be limited to the objects, arrays, and primitive values that JSON.stringify() supports. Note, however, that if you pass an instance of a class that you have defined, that instance will be serialized as an ordinary JavaScript object and will lose its prototype. In addition to the pushState() method, the History object also defines replaceState(), which takes the same arguments but replaces the current history state instead of adding a new state to the browsing history. When an application that uses pushState() is first loaded, it is often a good idea to call replaceState() to define a state object for this initial state of the application. When the user navigates to saved history states using the Back or Forward buttons, the browser fires a “popstate” event on the Window object. The event object associated with the event has a property named state, which contains a copy (another structured clone) of the state object you passed to pushState(). Example 15-9 is a simple web application—the number-guessing game pictured in Figure 15-15—that uses pushState() to save its history, allowing the user to “go back” to review or redo their guesses. A number-guessing gameExample ","date":"2020-11-02","objectID":"/posts/ch15/:10:4","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.11 Networking Every time you load a web page, the browser makes network requests—using the HTTP and HTTPS protocols—for an HTML file as well as the images, fonts, scripts, and stylesheets that the file depends on. But in addition to being able to make network requests in response to user actions, web browsers also expose JavaScript APIs for networking as well. This section covers three network APIs: The fetch() method defines a Promise-based API for making HTTP and HTTPS requests. The fetch() API makes basic GET requests simple but has a comprehensive feature set that also supports just about any possible HTTP use case. The Server-Sent Events (or SSE) API is a convenient, event-based interface to HTTP “long polling” techniques where the web server holds the network connection open so that it can send data to the client whenever it wants. WebSockets is a networking protocol that is not HTTP but is designed to interoperate with HTTP. It defines an asynchronous message-passing API where clients and servers can send and receive messages from each other in a way that is similar to TCP network sockets. ","date":"2020-11-02","objectID":"/posts/ch15/:11:0","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.11.1 fetch() For basic HTTP requests, using fetch() is a three-step process: Call fetch(), passing the URL whose content you want to retrieve. Get the response object that is asynchronously returned by step 1 when the HTTP response begins to arrive and call a method of this response object to ask for the body of the response. Get the body object that is asynchronously returned by step 2 and process it however you want. The fetch() API is completely Promise-based, and there are two asynchronous steps here, so you typically expect two then() calls or two await expressions when using fetch(). (And if you’ve forgotten what those are, you may want to reread Chapter 13 before continuing with this section.) Here’s what a fetch() request looks like if you are using then() and expect the server’s response to your request to be JSON-formatted: fetch(\"/api/users/current\") // Make an HTTP (or HTTPS) GET request .then(response =\u003e response.json()) // Parse its body as a JSON object .then(currentUser =\u003e { // Then process that parsed object displayUserInfo(currentUser); }); Here’s a similar request made using the async and await keywords to an API that returns a plain string rather than a JSON object: async function isServiceReady() { let response = await fetch(\"/api/service/status\"); let body = await response.text(); return body === \"ready\"; } If you understand these two code examples, then you know 80% of what you need to know to use the fetch() API. The subsections that follow will demonstrate how to make requests and receive responses that are somewhat more complicated than those shown here. GOODBYE XMLHTTPREQUEST The fetch() API replaces the baroque and misleadingly named XMLHttpRequest API (which has nothing to do with XML). You may still see XHR (as it is often abbreviated) in existing code, but there is no reason today to use it in new code, and it is not documented in this chapter. There is one example of XMLHttpRequest in this book, however, and you can refer to §13.1.3 if you’d like to see an example of old-style JavaScript networking. HTTP STATUS CODES, RESPONSE HEADERS, AND NETWORK ERRORS The three-step fetch() process shown in §15.11.1 elides all error-handling code. Here’s a more realistic version: fetch(\"/api/users/current\") // Make an HTTP (or HTTPS) GET request. .then(response =\u003e { // When we get a response, first check it if (response.ok \u0026\u0026 // for a success code and the expected type. response.headers.get(\"Content-Type\") === \"application/json\") { return response.json(); // Return a Promise for the body. } else { throw new Error( // Or throw an error. `Unexpected response status ${response.status}or content type` ); } }) .then(currentUser =\u003e { // When the response.json() Promise resolves displayUserInfo(currentUser); // do something with the parsed body. }) .catch(error =\u003e { // Or if anything went wrong, just log the error. // If the user's browser is offline, fetch() itself will reject. // If the server returns a bad response then we throw an error above. console.log(\"Error while fetching current user:\", error); }); The Promise returned by fetch() resolves to a Response object. The status property of this object is the HTTP status code, such as 200 for successful requests or 404 for “Not Found” responses. (statusText gives the standard English text that goes along with the numeric status code.) Conveniently, the ok property of a Response is true if status is 200 or any code between 200 and 299 and is false for any other code. fetch() resolves its Promise when the server’s response starts to arrive, as soon as the HTTP status and response headers are available, but typically before the full response body has arrived. Even though the body is not available yet, you can examine the headers in this second step of the fetch process. The headers property of a Response object is a Headers object. Use its has() method to test for the presence of a header, or use its get() method to get the value of a header. HTTP header names are","date":"2020-11-02","objectID":"/posts/ch15/:11:1","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.11.2 Server-Sent Events A fundamental feature of the HTTP protocol upon which the web is built is that clients initiate requests and servers respond to those requests. Some web apps find it useful, however, to have their server send them notifications when events occur. This does not come naturally to HTTP, but the technique that has been devised is for the client to make a request to the server, and then neither the client nor the server close the connection. When the server has something to tell the client about, it writes data to the connection but keeps it open. The effect is as if the client makes a network request and the server responds in a slow and bursty way with significant pauses between bursts of activity. Network connections like this don’t usually stay open forever, but if the client detects that the connection has closed, it can simply make another request to reopen the connection. This technique for allowing servers to send messages to clients is surprisingly effective (though it can be expensive on the server side because the server must maintain an active connection to all of its clients). Because it is a useful programming pattern, client-side JavaScript supports it with the EventSource API. To create this kind of long-lived request connection to a web server, simply pass a URL to the EventSource() constructor. When the server writes (properly formatted) data to the connection, the EventSource object translates those into events that you can listen for: let ticker = new EventSource(\"stockprices.php\"); ticker.addEventListener(\"bid\", (event) =\u003e { displayNewBid(event.data); } The event object associated with a message event has a data property that holds whatever string the server sent as the payload for this event. The event object also has a type property, like all event objects do, that specifies the name of the event. The server determines the type of the events that are generated. If the server omits an event name in the data it writes, then the event type defaults to “message.” The Server-Sent Event protocol is straightforward. The client initiates a connection to the server (when it creates the EventSource object), and the server keeps this connection open. When an event occurs, the server writes lines of text to the connection. An event going over the wire might look like this, if the comments were omitted: event: bid // sets the type of the event object data: GOOG // sets the data property data: 999 // appends a newline and more data // a blank line marks the end of the event There are some additional details to the protocol that allow events to be given IDs and allow a reconnecting client to tell the server what the ID of the last event it received was, so that a server can resend any events it missed. Those details are invisible on the client side, however, and are not discussed here. One obvious application for Server-Sent Events is for multiuser collaborations like online chat. A chat client might use fetch() to post messages to the chat room and subscribe to the stream of chatter with an EventSource object. Example 15-11 demonstrates how easy it is to write a chat client like this with EventSource. Example 15-11. A simple chat client using EventSource \u003chtml\u003e \u003chead\u003e\u003ctitle\u003eSSE Chat\u003c/title\u003e\u003c/head\u003e \u003cbody\u003e \u003c!-- The chat UI is just a single text input field --\u003e \u003c!-- New chat messages will be inserted before this input field --\u003e \u003cinput id=\"input\" style=\"width:100%; padding:10px; border:solid black 2px\"/\u003e \u003cscript\u003e // Take care of some UI details let nick = prompt(\"Enter your nickname\"); // Get user's nickname let input = document.getElementById(\"input\"); // Find the input field input.focus(); // Set keyboard focus // Register for notification of new messages using EventSource let chat = new EventSource(\"/chat\"); chat.addEventListener(\"chat\", event =\u003e { // When a chat message arrives let div = document.createElement(\"div\"); // Create a \u003cdiv\u003e div.append(event.data); // Add text from the message input.be","date":"2020-11-02","objectID":"/posts/ch15/:11:2","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.11.3 WebSockets The WebSocket API is a simple interface to a complex and powerful network protocol. WebSockets allow JavaScript code in the browser to easily exchange text and binary messages with a server. As with Server-Sent Events, the client must establish the connection, but once the connection is established, the server can asynchronously send messages to the client. Unlike SSE, binary messages are supported, and messages can be sent in both directions, not just from server to client. The network protocol that enables WebSockets is a kind of extension to HTTP. Although the WebSocket API is reminiscent of low-level network sockets, connection endpoints are not identified by IP address and port. Instead, when you want to connect to a service using the WebSocket protocol, you specify the service with a URL, just as you would for a web service. WebSocket URLs begin with wss:// instead of https://, however. (Browsers typically restrict WebSockets to only work in pages loaded over secure https:// connections). To establish a WebSocket connection, the browser first establishes an HTTP connection and sends the server an Upgrade: websocket header requesting that the connection be switched from the HTTP protocol to the WebSocket protocol. What this means is that in order to use WebSockets in your client-side JavaScript, you will need to be working with a web server that also speaks the WebSocket protocol, and you will need to have server-side code written to send and receive data using that protocol. If your server is set up that way, then this section will explain everything you need to know to handle the client-side end of the connection. If your server does not support the WebSocket protocol, consider using Server-Sent Events (§15.11.2) instead. CREATING, CONNECTING, AND DISCONNECTING WEBSOCKETS If you want to communicate with a WebSocket-enabled server, create a WebSocket object, specifying the wss:// URL that identifies the server and service you want to use: let socket = new WebSocket(\"wss://example.com/stockticker\"); When you create a WebSocket, the connection process begins automatically. But a newly created WebSocket will not be connected when it is first returned. The readyState property of the socket specifies what state the connection is in. This property can have the following values: WebSocket.CONNECTING This WebSocket is connecting. WebSocket.OPEN This WebSocket is connected and ready for communication. WebSocket.CLOSING This WebSocket connection is being closed. WebSocket.CLOSED This WebSocket has been closed; no further communication is possible. This state can also occur when the initial connection attempt fails. When a WebSocket transitions from the CONNECTING to the OPEN state, it fires an “open” event, and you can listen for this event by setting the onopen property of the WebSocket or by calling addEventListener() on that object. If a protocol or other error occurs for a WebSocket connection, the WebSocket object fires an “error” event. You can set onerror to define a handler, or, alternatively, use addEventListener(). When you are done with a WebSocket, you can close the connection by calling the close() method of the WebSocket object. When a WebSocket changes to the CLOSED state, it fires a “close” event, and you can set the onclose property to listen for this event. SENDING MESSAGES OVER A WEBSOCKET To send a message to the server on the other end of a WebSocket connection, simply invoke the send() method of the WebSocket object. send() expects a single message argument, which can be a string, Blob, ArrayBuffer, typed array, or DataView object. The send() method buffers the specified message to be transmitted and returns before the message is actually sent. The bufferedAmount property of the WebSocket object specifies the number of bytes that are buffered but not yet sent. (Surprisingly, WebSockets do not fire any event when this value reaches 0.) RECEIVING MESSAGES FROM A WEBSOCKET To receive messages ","date":"2020-11-02","objectID":"/posts/ch15/:11:3","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.12 Storage Web applications can use browser APIs to store data locally on the user’s computer. This client-side storage serves to give the web browser a memory. Web apps can store user preferences, for example, or even store their complete state, so that they can resume exactly where you left off at the end of your last visit. Client-side storage is segregated by origin, so pages from one site can’t read the data stored by pages from another site. But two pages from the same site can share storage and use it as a communication mechanism. Data input in a form on one page can be displayed in a table on another page, for example. Web applications can choose the lifetime of the data they store: data can be stored temporarily so that it is retained only until the window closes or the browser exits, or it can be saved on the user’s computer and stored permanently so that it is available months or years later. There are a number of forms of client-side storage: Web Storage The Web Storage API consists of the localStorage and sessionStorage objects, which are essentially persistent objects that map string keys to string values. Web Storage is very easy to use and is suitable for storing large (but not huge) amounts of data. Cookies Cookies are an old client-side storage mechanism that was designed for use by server-side scripts. An awkward JavaScript API makes cookies scriptable on the client side, but they’re hard to use and suitable only for storing small amounts of textual data. Also, any data stored as cookies is always transmitted to the server with every HTTP request, even if the data is only of interest to the client. IndexedDB IndexedDB is an asynchronous API to an object database that supports indexing. STORAGE, SECURITY, AND PRIVACY Web browsers often offer to remember web passwords for you, and they store them safely in encrypted form on the device. But none of the forms of client-side data storage described in this chapter involve encryption: you should assume that anything your web applications save resides on the user’s device in unencrypted form. Stored data is therefore accessible to curious users who share access to the device and to malicious software (such as spyware) that exists on the device. For this reason, no form of client-side storage should ever be used for passwords, financial account numbers, or other similarly sensitive information. ","date":"2020-11-02","objectID":"/posts/ch15/:12:0","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.12.1 localStorage and sessionStorage The localStorage and sessionStorage properties of the Window object refer to Storage objects. A Storage object behaves much like a regular JavaScript object, except that: The property values of Storage objects must be strings. The properties stored in a Storage object persist. If you set a property of the localStorage object and then the user reloads the page, the value you saved in that property is still available to your program. You can use the localStorage object like this, for example: let name = localStorage.username; // Query a stored value. if (!name) { name = prompt(\"What is your name?\"); // Ask the user a question. localStorage.username = name; // Store the user's response. } You can use the delete operator to remove properties from localStorage and sessionStorage, and you can use a for/in loop or Object.keys() to enumerate the properties of a Storage object. If you want to remove all properties of a storage object, call the clear() method: localStorage.clear(); Storage objects also define getItem(), setItem(), and deleteItem() methods, which you can use instead of direct property access and the delete operator if you want to. Keep in mind that the properties of Storage objects can only store strings. If you want to store and retrieve other kinds of data, you’ll have to encode and decode it yourself. For example: // If you store a number, it is automatically converted to a string. // Don't forget to parse it when retrieving it from storage. localStorage.x = 10; let x = parseInt(localStorage.x); // Convert a Date to a string when setting, and parse it when getting localStorage.lastRead = (new Date()).toUTCString(); let lastRead = new Date(Date.parse(localStorage.lastRead)); // JSON makes a convenient encoding for any primitive or data structure localStorage.data = JSON.stringify(data); // Encode and store let data = JSON.parse(localStorage.data); // Retrieve and decode. STORAGE LIFETIME AND SCOPE The difference between localStorage and sessionStorage involves the lifetime and scope of the storage. Data stored through localStorage is permanent: it does not expire and remains stored on the user’s device until a web app deletes it or the user asks the browser (through some browser-specific UI) to delete it. localStorage is scoped to the document origin. As explained in “The same-origin policy”, the origin of a document is defined by its protocol, hostname, and port. All documents with the same origin share the same localStorage data (regardless of the origin of the scripts that actually access localStorage). They can read each other’s data, and they can overwrite each other’s data. But documents with different origins can never read or overwrite each other’s data (even if they’re both running a script from the same third-party server). Note that localStorage is also scoped by browser implementation. If you visit a site using Firefox and then visit again using Chrome (for example), any data stored during the first visit will not be accessible during the second visit. Data stored through sessionStorage has a different lifetime than data stored through localStorage: it has the same lifetime as the top-level window or browser tab in which the script that stored it is running. When the window or tab is permanently closed, any data stored through sessionStorage is deleted. (Note, however, that modern browsers have the ability to reopen recently closed tabs and restore the last browsing session, so the lifetime of these tabs and their associated sessionStorage may be longer than it seems.) Like localStorage, sessionStorage is scoped to the document origin so that documents with different origins will never share sessionStorage. But sessionStorage is also scoped on a per-window basis. If a user has two browser tabs displaying documents from the same origin, those two tabs have separate sessionStorage data: the scripts running in one tab cannot read or overwrite the data written by scripts ","date":"2020-11-02","objectID":"/posts/ch15/:12:1","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.12.2 Cookies A cookie is a small amount of named data stored by the web browser and associated with a particular web page or website. Cookies were designed for server-side programming, and at the lowest level, they are implemented as an extension to the HTTP protocol. Cookie data is automatically transmitted between the web browser and web server, so server-side scripts can read and write cookie values that are stored on the client. This section demonstrates how client-side scripts can also manipulate cookies using the cookie property of the Document object. WHY “COOKIE”? The name “cookie” does not have a lot of significance, but it is not used without precedent. In the annals of computing history, the term “cookie” or “magic cookie” has been used to refer to a small chunk of data, particularly a chunk of privileged or secret data, akin to a password, that proves identity or permits access. In JavaScript, cookies are used to save state and can establish a kind of identity for a web browser. Cookies in JavaScript do not use any kind of cryptography, however, and are not secure in any way (although transmitting them across an https: connection helps). The API for manipulating cookies is an old and cryptic one. There are no methods involved: cookies are queried, set, and deleted by reading and writing the cookie property of the Document object using specially formatted strings. The lifetime and scope of each cookie can be individually specified with cookie attributes. These attributes are also specified with specially formatted strings set on the same cookie property. The subsections that follow explain how to query and set cookie values and attributes. READING COOKIES When you read the document.cookie property, it returns a string that contains all the cookies that apply to the current document. The string is a list of name/value pairs separated from each other by a semicolon and a space. The cookie value is just the value itself and does not include any of the attributes that may be associated with that cookie. (We’ll talk about attributes next.) In order to make use of the document.cookie property, you must typically call the split() method to break it into individual name/value pairs. Once you have extracted the value of a cookie from the cookie property, you must interpret that value based on whatever format or encoding was used by the cookie’s creator. You might, for example, pass the cookie value to decodeURIComponent() and then to JSON.parse(). The code that follows defines a getCookie() function that parses the document.cookie property and returns an object whose properties specify the names and values of the document’s cookies: // Return the document's cookies as a Map object. // Assume that cookie values are encoded with encodeURIComponent(). function getCookies() { let cookies = new Map(); // The object we will return let all = document.cookie; // Get all cookies in one big string let list = all.split(\"; \"); // Split into individual name/value pairs for(let cookie of list) { // For each cookie in that list if (!cookie.includes(\"=\")) continue; // Skip if there is no = sign let p = cookie.indexOf(\"=\"); // Find the first = sign let name = cookie.substring(0, p); // Get cookie name let value = cookie.substring(p+1); // Get cookie value value = decodeURIComponent(value); // Decode the value cookies.set(name, value); // Remember cookie name and value } return cookies; } COOKIE ATTRIBUTES: LIFETIME AND SCOPE In addition to a name and a value, each cookie has optional attributes that control its lifetime and scope. Before we can describe how to set cookies with JavaScript, we need to explain cookie attributes. Cookies are transient by default; the values they store last for the duration of the web browser session but are lost when the user exits the browser. If you want a cookie to last beyond a single browsing session, you must tell the browser how long (in seconds) you would like it to retain the cookie by specifying a m","date":"2020-11-02","objectID":"/posts/ch15/:12:2","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.12.3 IndexedDB Web application architecture has traditionally featured HTML, CSS, and JavaScript on the client and a database on the server. You may find it surprising, therefore, to learn that the web platform includes a simple object database with a JavaScript API for persistently storing JavaScript objects on the user’s computer and retrieving them as needed. IndexedDB is an object database, not a relational database, and it is much simpler than databases that support SQL queries. It is more powerful, efficient, and robust than the key/value storage provided by the localStorage, however. Like the localStorage, IndexedDB databases are scoped to the origin of the containing document: two web pages with the same origin can access each other’s data, but web pages from different origins cannot. Each origin can have any number of IndexedDB databases. Each one has a name that must be unique within the origin. In the IndexedDB API, a database is simply a collection of named object stores. As the name implies, an object store stores objects. Objects are serialized into the object store using the structured clone algorithm (see “The Structured Clone Algorithm”), which means that the objects you store can have properties whose values are Maps, Sets, or typed arrays. Each object must have a key by which it can be sorted and retrieved from the store. Keys must be unique—two objects in the same store may not have the same key—and they must have a natural ordering so that they can be sorted. JavaScript strings, numbers, and Date objects are valid keys. An IndexedDB database can automatically generate a unique key for each object you insert into the database. Often, though, the objects you insert into an object store will already have a property that is suitable for use as a key. In this case, you specify a “key path” for that property when you create the object store. Conceptually, a key path is a value that tells the database how to extract an object’s key from the object. In addition to retrieving objects from an object store by their primary key value, you may want to be able to search based on the value of other properties in the object. In order to be able to do this, you can define any number of indexes on the object store. (The ability to index an object store explains the name “IndexedDB.”) Each index defines a secondary key for the stored objects. These indexes are not generally unique, and multiple objects may match a single key value. IndexedDB provides atomicity guarantees: queries and updates to the database are grouped within a transaction so that they all succeed together or all fail together and never leave the database in an undefined, partially updated state. Transactions in IndexedDB are simpler than in many database APIs; we’ll mention them again later. Conceptually, the IndexedDB API is quite simple. To query or update a database, you first open the database you want (specifying it by name). Next, you create a transaction object and use that object to look up the desired object store within the database, also by name. Finally, you look up an object by calling the get() method of the object store or store a new object by calling put() (or by calling add(), if you want to avoid overwriting existing objects). If you want to look up the objects for a range of keys, you create an IDBRange object that specifies the upper and lower bounds of the range and pass it to the getAll() or openCursor() methods of the object store. If you want to make a query using a secondary key, you look up the named index of the object store, then call the get(), getAll(), or openCursor() methods of the index object, passing either a single key or an IDBRange object. This conceptual simplicity of the IndexedDB API is complicated, however, by the fact that the API is asynchronous (so that web apps can use it without blocking the browser’s main UI thread). IndexedDB was defined before Promises were widely supported, so the API is event-based rat","date":"2020-11-02","objectID":"/posts/ch15/:12:3","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.13 Worker Threads and Messaging One of the fundamental features of JavaScript is that it is single-threaded: a browser will never run two event handlers at the same time, and it will never trigger a timer while an event handler is running, for example. Concurrent updates to application state or to the document are simply not possible, and client-side programmers do not need to think about, or even understand, concurrent programming. A corollary is that client-side JavaScript functions must not run too long; otherwise, they will tie up the event loop and the web browser will become unresponsive to user input. This is the reason that fetch() is an asynchronous function, for example. Web browsers very carefully relax the single-thread requirement with the Worker class: instances of this class represent threads that run concurrently with the main thread and the event loop. Workers live in a self-contained execution environment with a completely independent global object and no access to the Window or Document objects. Workers can communicate with the main thread only through asynchronous message passing. This means that concurrent modifications of the DOM remain impossible, but it also means that you can write long-running functions that do not stall the event loop and hang the browser. Creating a new worker is not a heavyweight operation like opening a new browser window, but workers are not flyweight “fibers” either, and it does not make sense to create new workers to perform trivial operations. Complex web applications may find it useful to create tens of workers, but it is unlikely that an application with hundreds or thousands of workers would be practical. Workers are useful when your application needs to perform computationally intensive tasks, such as image processing. Using a worker moves tasks like this off the main thread so that the browser does not become unresponsive. And workers also offer the possibility of dividing the work among multiple threads. But workers are also useful when you have to perform frequent moderately intensive computations. Suppose, for example, that you’re implementing a simple in-browser code editor, and want to include syntax highlighting. To get the highlighting right, you need to parse the code on every keystroke. But if you do that on the main thread, it is likely that the parsing code will prevent the event handlers that respond to the user’s key strokes from running promptly and the user’s typing experience will be sluggish. As with any threading API, there are two parts to the Worker API. The first is the Worker object: this is what a worker looks like from the outside, to the thread that creates it. The second is the WorkerGlobalScope: this is the global object for a new worker, and it is what a worker thread looks like, on the inside, to itself. The following sections cover Worker and WorkerGlobalScope and also explain the message-passing API that allows workers to communicate with the main thread and each other. The same communication API is used to exchange messages between a document and \u003ciframe\u003e elements contained in the document, and this is covered in the following sections as well. ","date":"2020-11-02","objectID":"/posts/ch15/:13:0","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.13.1 Worker Objects To create a new worker, call the Worker() constructor, passing a URL that specifies the JavaScript code that the worker is to run: let dataCruncher = new Worker(“utils/cruncher.js”); If you specify a relative URL, it is resolved relative to the URL of the document that contains the script that called the Worker() constructor. If you specify an absolute URL, it must have the same origin (same protocol, host, and port) as that containing document. Once you have a Worker object, you can send data to it with postMessage(). The value you pass to postMessage() will be copied using the structured clone algorithm (see “The Structured Clone Algorithm”), and the resulting copy will be delivered to the worker via a message event: dataCruncher.postMessage(\"/api/data/to/crunch\"); Here we’re just passing a single string message, but you can also use objects, arrays, typed arrays, Maps, Sets, and so on. You can receive messages from a worker by listening for “message” events on the Worker object: dataCruncher.onmessage = function(e) { let stats = e.data; // The message is the data property of the event console.log(`Average: ${stats.mean}`); } Like all event targets, Worker objects define the standard addEventListener() and removeEventListener() methods, and you can use these in place of the onmessage. In addition to postMessage(), Worker objects have just one other method, terminate(), which forces a worker thread to stop running. ","date":"2020-11-02","objectID":"/posts/ch15/:13:1","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.13.2 The Global Object in Workers When you create a new worker with the Worker() constructor, you specify the URL of a file of JavaScript code. That code is executed in a new, pristine JavaScript execution environment, isolated from the script that created the worker. The global object for that new execution environment is a WorkerGlobalScope object. A WorkerGlobalScope is something more than the core JavaScript global object, but less than a full-blown client-side Window object. The WorkerGlobalScope object has a postMessage() method and an onmessage event handler property that are just like those of the Worker object but work in the opposite direction: calling postMessage() inside a worker generates a message event outside the worker, and messages sent from outside the worker are turned into events and delivered to the onmessage handler. Because the WorkerGlobalScope is the global object for a worker, postMessage() and onmessage look like a global function and global variable to worker code. If you pass an object as the second argument to the Worker() constructor, and if that object has a name property, then the value of that property becomes the value of the name property in the worker’s global object. A worker might include this name in any messages it prints with console.warn() or console.error(). The close() function allows a worker to terminate itself, and it is similar in effect to the terminate() method of a Worker object. Since WorkerGlobalScope is the global object for workers, it has all of the properties of the core JavaScript global object, such as the JSON object, the isNaN() function, and the Date() constructor. In addition, however, WorkerGlobalScope also has the following properties of the client-side Window object: self is a reference to the global object itself. WorkerGlobalScope is not a Window object and does not define a window property. The timer methods setTimeout(), clearTimeout(), setInterval(), and clearInterval(). A location property that describes the URL that was passed to the Worker() constructor. This property refers to a Location object, just as the location property of a Window does. The Location object has properties href, protocol, host, hostname, port, pathname, search, and hash. In a worker, these properties are read-only, however. A navigator property that refers to an object with properties like those of the Navigator object of a window. A worker’s Navigator object has the properties appName, appVersion, platform, userAgent, and onLine. The usual event target methods addEventListener() and removeEventListener(). Finally, the WorkerGlobalScope object includes important client-side JavaScript APIs including the Console object, the fetch() function, and the IndexedDB API. WorkerGlobalScope also includes the Worker() constructor, which means that worker threads can create their own workers. ","date":"2020-11-02","objectID":"/posts/ch15/:13:2","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.13.3 Importing Code into a Worker Workers were defined in web browsers before JavaScript had a module system, so workers have a unique system for including additional code. WorkerGlobalScope defines importScripts() as a global function that all workers have access to: // Before we start working, load the classes and utilities we'll need importScripts(\"utils/Histogram.js\", \"utils/BitSet.js\"); importScripts() takes one or more URL arguments, each of which should refer to a file of JavaScript code. Relative URLs are resolved relative to the URL that was passed to the Worker() constructor (not relative to the containing document). importScripts() synchronously loads and executes these files one after the other, in the order in which they were specified. If loading a script causes a network error, or if executing throws an error of any sort, none of the subsequent scripts are loaded or executed. A script loaded with importScripts() can itself call importScripts() to load the files it depends on. Note, however, that importScripts() does not try to keep track of what scripts have already loaded and does nothing to prevent dependency cycles. importScripts() is a synchronous function: it does not return until all of the scripts have loaded and executed. You can start using the scripts you loaded as soon as importScripts() returns: there is no need for a callback, event handler, then() method or await. Once you have internalized the asynchronous nature of client-side JavaScript, it feels strange to go back to simple, synchronous programming again. But that is the beauty of threads: you can use a blocking function call in a worker without blocking the event loop in the main thread, and without blocking the computations being concurrently performed in other workers. MODULES IN WORKERS In order to use modules in workers, you must pass a second argument to the Worker() constructor. This second argument must be an object with a type property set to the string “module.” Passing a type:“module” option to the Worker() constructor is much like using the type=“module” attribute on an HTML \u003cscript\u003e tag: it means that the code should be interpreted as a module and that import declarations are allowed. When a worker loads a module instead of a traditional script, the WorkerGlobalScope does not define the importScripts() function. Note that as of early 2020, Chrome is the only browser that supports true modules and import declarations in workers. ","date":"2020-11-02","objectID":"/posts/ch15/:13:3","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.13.4 Worker Execution Model Worker threads run their code (and all imported scripts or modules) synchronously from top to bottom, and then enter an asynchronous phase in which they respond to events and timers. If a worker registers a “message” event handler, it will never exit as long as there is a possibility that message events will still arrive. But if a worker doesn’t listen for messages, it will run until there are no further pending tasks (such as fetch() promises and timers) and all task-related callbacks have been called. Once all registered callbacks have been called, there is no way a worker can begin a new task, so it is safe for the thread to exit, which it will do automatically. A worker can also explicitly shut itself down by calling the global close() function. Note that there are no properties or methods on the Worker object that specify whether a worker thread is still running or not, so workers should not close themselves without somehow coordinating this with their parent thread. ERRORS IN WORKERS If an exception occurs in a worker and is not caught by any catch clause, then an “error” event is triggered on the global object of the worker. If this event is handled and the handler calls the preventDefault() method of the event object, the error propagation ends. Otherwise, the “error” event is fired on the Worker object. If preventDefault() is called there, then propagation ends. Otherwise, an error message is printed in the developer console and the onerror handler (§15.1.7) of the Window object is invoked. // Handle uncaught worker errors with a handler inside the worker. self.onerror = function(e) { console.log(`Error in worker at ${e.filename}:${e.lineno}: ${e.message}`); e.preventDefault(); }; // Or, handle uncaught worker errors with a handler outside the worker. worker.onerror = function(e) { console.log(`Error in worker at ${e.filename}:${e.lineno}: ${e.message}`); e.preventDefault(); }; Like windows, workers can register a handler to be invoked when a Promise is rejected and there is no .catch() function to handle it. Within a worker you can detect this by defining a self.onunhandledrejection function or by using addEventListener() to register a global handler for “unhandledrejection” events. The event object passed to this handler will have a promise property whose value is the Promise object that rejected and a reason property whose value is what would have been passed to a .catch() function. ","date":"2020-11-02","objectID":"/posts/ch15/:13:4","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.13.5 postMessage(), MessagePorts, and MessageChannels The postMessage() method of the Worker object and the global postMesage() function defined inside a worker both work by invoking the postMessage() methods of a pair of MessagePort objects that are automatically created along with the worker. Client-side JavaScript can’t directly access these automatically created MessagePort objects, but it can create new pairs of connected ports with the MessageChannel() constructor: let channel = new MessageChannel; // Create a new channel. let myPort = channel.port1; // It has two ports let yourPort = channel.port2; // connected to each other. myPort.postMessage(\"Can you hear me?\"); // A message posted to one will yourPort.onmessage = (e) =\u003e console.log(e.data); // be received on the other. A MessageChannel is an object with port1 and port2 properties that refer to a pair of connected MessagePort objects. A MessagePort is an object with a postMessage() method and an onmessage event handler property. When postMessage() is called on one port of a connected pair, a “message” event is fired on the other port in the pair. You can receive these “message” events by setting the onmessage property or by using addEventListener() to register a listener for “message” events. Messages sent to a port are queued until the onmessage property is defined or until the start() method is called on the port. This prevents messages sent by one end of the channel from being missed by the other end. If you use addEventListener() with a MessagePort, don’t forget to call start() or you may never see a message delivered. All the postMessage() calls we’ve seen so far have taken a single message argument. But the method also accepts an optional second argument. This second argument is an array of items that are to be transferred to the other end of the channel instead of having a copy sent across the channel. Values that can be transferred instead of copied are MessagePorts and ArrayBuffers. (Some browsers also implement other transferable types, such as ImageBitmap and OffscreenCanvas. These are not universally supported, however, and are not covered in this book.) If the first argument to postMessage() includes a MessagePort (nested anywhere within the message object), then that MessagePort must also appear in the second argument. If you do this, then the MessagePort will become available to the other end of the channel and will immediately become nonfunctional on your end. Suppose you have created a worker and want to have two channels for communicating with it: one channel for ordinary data exchange and one channel for high-priority messages. In the main thread, you might create a MessageChannel, then call postMessage() on the worker to pass one of the MessagePorts to it: let worker = new Worker(\"worker.js\"); let urgentChannel = new MessageChannel(); let urgentPort = urgentChannel.port1; worker.postMessage({ command: \"setUrgentPort\", value: urgentChannel.port2 }, [ urgentChannel.port2 ]); // Now we can receive urgent messages from the worker like this urgentPort.addEventListener(\"message\", handleUrgentMessage); urgentPort.start(); // Start receiving messages // And send urgent messages like this urgentPort.postMessage(\"test\"); MessageChannels are also useful if you create two workers and want to allow them to communicate directly with each other rather than requiring code on the main thread to relay messages between them. The other use of the second argument to postMessage() is to transfer ArrayBuffers between workers without having to copy them. This is an important performance enhancement for large ArrayBuffers like those used to hold image data. When an ArrayBuffer is transferred over a MessagePort, the ArrayBuffer becomes unusable in the original thread so that there is no possibility of concurrent access to its contents. If the first argument to postMessage() includes an ArrayBuffer, or any value (such as a typed array) that has an ArrayBuffer, then that ","date":"2020-11-02","objectID":"/posts/ch15/:13:5","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.13.6 Cross-Origin Messaging with postMessage() There is another use case for the postMessage() method in client-side JavaScript. It involves windows instead of workers, but there are enough similarities between the two cases that we will describe the postMessage() method of the Window object here. When a document contains an \u003ciframe\u003e element, that element acts as an embedded but independent window. The Element object that represents the \u003ciframe\u003e has a contentWindow property that is the Window object for the embedded document. And for scripts running within that nested iframe, the window.parent property refers to the containing Window object. When two windows display documents with the same origin, then scripts in each of those windows have access to the contents of the other window. But when the documents have different origins, the browser’s same-origin policy prevents JavaScript in one window from accessing the content of another window. For workers, postMessage() provides a safe way for two independent threads to communicate without sharing memory. For windows, postMessage() provides a controlled way for two independent origins to safely exchange messages. Even if the same-origin policy prevents your script from seeing the content of another window, you can still call postMessage() on that window, and doing so will cause a “message” event to be triggered on that window, where it can be seen by the event handlers in that window’s scripts. The postMessage() method of a Window is a little different than the postMessage() method of a Worker, however. The first argument is still an arbitrary message that will be copied by the structured clone algorithm. But the optional second argument listing objects to be transferred instead of copied becomes an optional third argument. The postMessage() method of a window takes a string as its required second argument. This second argument should be an origin (a protocol, hostname, and optional port) that specifies who you expect to be receiving the message. If you pass the string “https://good.example.com” as the second argument, but the window you are posting the message to actually contains content from “https://malware.example.com,” then the message you posted will not be delivered. If you are willing to send your message to content from any origin, then you can pass the wildcard “*” as the second argument. JavaScript code running inside a window or \u003ciframe\u003e can receive messages posted to that window or frame by defining the onmessage property of that window or by calling addEventListener() for “message” events. As with workers, when you receive a “message” event for a window, the data property of the event object is the message that was sent. In addition, however, “message” events delivered to windows also define source and origin properties. The source property specifies the Window object that sent the event, and you can use event.source.postMessage() to send a reply. The origin property specifies the origin of the content in the source window. This is not something the sender of the message can forge, and when you receive a “message” event, you will typically want to verify that it is from an origin you expect. ","date":"2020-11-02","objectID":"/posts/ch15/:13:6","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.14 Example: The Mandelbrot Set This chapter on client-side JavaScript culminates with a long example that demonstrates using workers and messaging to parallelize computationally intensive tasks. But it is written to be an engaging, real-world web application and also demonstrates a number of the other APIs demonstrated in this chapter, including history management; use of the ImageData class with a \u003ccanvas\u003e; and the use of keyboard, pointer, and resize events. It also demonstrates important core JavaScript features, including generators and a sophisticated use of Promises. The example is a program for displaying and exploring the Mandelbrot set, a complex fractal that includes beautiful images like the one shown in Figure 15-16. A portion of the Mandelbrot setThe Mandelbrot set is defined as the set of points on the complex plane, which, when put through a repeated process of complex multiplication and addition, produce a value whose magnitude remains bounded. The contours of the set are surprisingly complex, and computing which points are members of the set and which are not is computationally intensive: to produce a 500×500 image of the Mandelbrot set, you must individually compute the membership of each of the 250,000 pixels in your image. And to verify that the value associated with each pixel remains bounded, you may have to repeat the process of complex multiplication 1,000 times or more. (More iterations give more sharply defined boundaries for the set; fewer iterations produce fuzzier boundaries.) With up to 250 million steps of complex arithmetic required to produce a high-quality image of the Mandelbrot set, you can understand why using workers is a valuable technique. Example 15-14 shows the worker code we will use. This file is relatively compact: it is just the raw computational muscle for the larger program. Two things are worth noting about it, however: The worker creates an ImageData object to represent the rectangular grid of pixels for which it is computing Mandelbrot set membership. But instead of storing actual pixel values in the ImageData, it uses a custom-typed array to treat each pixel as a 32-bit integer. It stores the number of iterations required for each pixel in this array. If the magnitude of the complex number computed for each pixel becomes greater than four, then it is mathematically guaranteed to grow without bounds from then on, and we say it has “escaped.” So the value this worker returns for each pixel is the number of iterations before the value escaped. We tell the worker the maximum number of iterations it should try for each value, and pixels that reach this maximum number are considered to be in the set. The worker transfers the ArrayBuffer associated with the ImageData back to the main thread so the memory associated with it does not need to be copied. Example 15-14. Worker code for computing regions of the Mandelbrot set // This is a simple worker that receives a message from its parent thread, // performs the computation described by that message and then posts the // result of that computation back to the parent thread. onmessage = function(message) { // First, we unpack the message we received: // - tile is an object with width and height properties. It specifies the // size of the rectangle of pixels for which we will be computing // Mandelbrot set membership. // - (x0, y0) is the point in the complex plane that corresponds to the // upper-left pixel in the tile. // - perPixel is the pixel size in both the real and imaginary dimensions. // - maxIterations specifies the maximum number of iterations we will // perform before deciding that a pixel is in the set. const {tile, x0, y0, perPixel, maxIterations} = message.data; const {width, height} = tile; // Next, we create an ImageData object to represent the rectangular array // of pixels, get its internal ArrayBuffer, and create a typed array view // of that buffer so we can treat each pixel as a single integer instead of // four","date":"2020-11-02","objectID":"/posts/ch15/:14:0","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.15 Summary and Suggestions for Further Reading This long chapter has covered the fundamentals of client-side JavaScript programming: How scripts and JavaScript modules are included in web pages and how and when they are executed. Client-side JavaScript’s asynchronous, event-driven programming model. The Document Object Model (DOM) that allows JavaScript code to inspect and modify the HTML content of the document it is embedded within. This DOM API is the heart of all client-side JavaScript programming. How JavaScript code can manipulate the CSS styles that are applied to content within the document. How JavaScript code can obtain the coordinates of document elements in the browser window and within the document itself. How to create reusable UI “Web Components” with JavaScript, HTML, and CSS using the Custom Elements and Shadow DOM APIs. How to display and dynamically generate graphics with SVG and the HTML \u003ccanvas\u003e element. How to add scripted sound effects (both recorded and synthesized) to your web pages. How JavaScript can make the browser load new pages, go backward and forward in the user’s browsing history, and even add new entries to the browsing history. How JavaScript programs can exchange data with web servers using the HTTP and WebSocket protocols. How JavaScript programs can store data in the user’s browser. How JavaScript programs can use worker threads to achieve a safe form of concurrency. This has been the longest chapter of the book, by far. But it cannot come close to covering all the APIs available to web browsers. The web platform is sprawling and ever-evolving, and my goal for this chapter was to introduce the most important core APIs. With the knowledge you have from this book, you are well equipped to learn and use new APIs as you need them. But you can’t learn about a new API if you don’t know that it exists, so the short sections that follow end the chapter with a quick list of web platform features that you might want to investigate in the future. ","date":"2020-11-02","objectID":"/posts/ch15/:15:0","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.15.1 HTML and CSS The web is built upon three key technologies: HTML, CSS, and JavaScript, and knowledge of JavaScript can take you only so far as a web developer unless you also develop your expertise with HTML and CSS. It is important to know how to use JavaScript to manipulate HTML elements and CSS styles, but that knowledge is is much more useful if you also know which HTML elements and which CSS styles to use. So before you start exploring more JavaScript APIs, I would encourage you to invest some time in mastering the other tools in a web developer’s toolkit. HTML form and input elements, for example, have sophisticated behavior that is important to understand, and the flexbox and grid layout modes in CSS are incredibly powerful. Two topics worth paying particular attention to in this area are accessibility (including ARIA attributes) and internationalization (including support for right-to-left writing directions). ","date":"2020-11-02","objectID":"/posts/ch15/:15:1","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.15.2 Performance Once you have written a web application and released it to the world, the never-ending quest to make it fast begins. It is hard to optimize things that you can’t measure, however, so it is worth familiarizing yourself with the Performance APIs. The performance property of the window object is the main entry point to this API. It includes a high-resolution time source performance.now(), and methods performance.mark() and performance.measure() for marking critical points in your code and measuring the elapsed time between them. Calling these methods creates PerformanceEntry objects that you can access with performance.getEntries(). Browsers add their own PerformanceEntry objects any time the browser loads a new page or fetches a file over the network, and these automatically created PerformanceEntry objects include granular timing details of your application’s network performance. The related PerformanceObserver class allows you to specify a function to be invoked when new PerformanceEntry objects are created. ","date":"2020-11-02","objectID":"/posts/ch15/:15:2","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.15.3 Security This chapter introduced the general idea of how to defend against cross-site scripting (XSS) security vulnerabilities in your websites, but we did not go into much detail. The topic of web security is an important one, and you may want to spend some time learning more about it. In addition to XSS, it is worth learning about the Content-Security-Policy HTTP header and understanding how CSP allows you to ask the web browser to restrict the capabilities it grants to JavaScript code. Understanding CORS (Cross-Origin Resource Sharing) is also important. ","date":"2020-11-02","objectID":"/posts/ch15/:15:3","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.15.4 WebAssembly WebAssembly (or “wasm”) is a low-level virtual machine bytecode format that is designed to integrate well with JavaScript interpreters in web browsers. There are compilers that allow you to compile C, C++, and Rust programs to WebAssembly bytecode and to run those programs in web browsers at close to native speed, without breaking the browser sandbox or security model. WebAssembly can export functions that can be called by JavaScript programs. A typical use case for WebAssembly would be to compile the standard C-language zlib compression library so that JavaScript code has access to high-speed compression and decompression algorithms. Learn more at https://webassembly.org. ","date":"2020-11-02","objectID":"/posts/ch15/:15:4","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.15.5 More Document and Window Features The Window and Document objects have a number of features that were not covered in this chapter: The Window object defines alert(), confirm(), and prompt() methods that display simple modal dialogues to the user. These methods block the main thread. The confirm() method synchronously returns a boolean value, and prompt() synchronously returns a string of user input. These are not suitable for production use but can be useful for simple projects and prototypes. The navigator and screen properties of the Window object were mentioned in passing at the start of this chapter, but the Navigator and Screen objects that they reference have some features that were not described here that you may find useful. The requestFullscreen() method of any Element object requests that that element (a \u003cvideo\u003e or \u003ccanvas\u003e element, for example) be displayed in fullscreen mode. The exitFullscreen() method of the Document returns to normal display mode. The requestAnimationFrame() method of the Window object takes a function as its argument and will execute that function when the browser is preparing to render the next frame. When you are making visual changes (especially repeated or animated ones), wrapping your code within a call to requestAnimationFrame() can help to ensure that the changes are rendered smoothly and in a way that is optimized by the browser. If the user selects text within your document, you can obtain details of that selection with the Window method getSelection() and get the selected text with getSelection().toString(). In some browsers, navigator.clipboard is an object with an async API for reading and setting the content of the system clipboard to enable copy-and-paste interactions with applications outside of the browser. A little-known feature of web browsers is that HTML elements with a contenteditable=“true” attribute allow their content to be edited. The document.execCommand() method enables rich-text editing features for editable content. A MutationObserver allows JavaScript to monitor changes to, or beneath, a specified element in the document. Create a MutationObserver with the MutationObserver() constructor, passing the callback function that should be called when changes are made. Then call the observe() method of the MutationObserver to specify which parts of which element are to be monitored. An IntersectionObserver allows JavaScript to determine which document elements are on the screen and which are close to being on the screen. It is particularly useful for applications that want to dynamically load content on demand as the user scrolls. ","date":"2020-11-02","objectID":"/posts/ch15/:15:5","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.15.6 Events The sheer number and diversity of events supported by the web platform can be daunting. This chapter has discussed a variety of event types, but here are some more that you may find useful: Browsers fire “online” and “offline” events at the Window object when the browser gains or loses an internet connection. Browsers fire a “visiblitychange” event at the Document object when a document becomes visible or invisible (usually because a user has switched tabs). JavaScript can check document.visibilityState to determine whether its document is currently “visible” or “hidden.” Browsers support a complicated API to support drag-and-drop UIs and to support data exchange with applications outside the browser. This API involves a number of events, including “dragstart,” “dragover,” “dragend,” and “drop.” This API is tricky to use correctly but useful when you need it. It is an important API to know about if you want to enable users to drag files from their desktop into your web application. The Pointer Lock API enables JavaScript to hide the mouse pointer and get raw mouse events as relative movement amounts rather than absolute positions on the screen. This is typically useful for games. Call requestPointerLock() on the element you want all mouse events directed to. After you do this, “mousemove” events delivered to that element will have movementX and movementY properties. The Gamepad API adds support for game controllers. Use navigator.getGamepads() to get connected Gamepad objects, and listen for “gamepadconnected” events on the Window object to be notified when a new controller is plugged in. The Gamepad object defines an API for querying the current state of the buttons on the controller. ","date":"2020-11-02","objectID":"/posts/ch15/:15:6","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.15.7 Progressive Web Apps and Service Workers The term Progressive Web Apps, or PWAs, is a buzzword that describes web applications that are built using a few key technologies. Careful documentation of these key technologies would require a book of its own, and I have not covered them in this chapter, but you should be aware of all of these APIs. It is worth noting that powerful modern APIs like these are typically designed to work only on secure HTTPS connections. Websites that are still using http:// URLs will not be able to take advantage of these: A ServiceWorker is a kind of worker thread with the ability to intercept, inspect, and respond to network requests from the web application that it “services.” When a web application registers a service worker, that worker’s code becomes persistent in the browser’s local storage, and when the user visits the associated website again, the service worker is reactivated. Service workers can cache network responses (including files of JavaScript code), which means that web applications that use service workers can effectively install themselves onto the user’s computer for rapid startup and offline use. The Service Worker Cookbook at https://serviceworke.rs is a valuable resource for learning about service workers and their related technologies. The Cache API is designed for use by service workers (but is also available to regular JavaScript code outside of workers). It works with the Request and Response objects defined by the fetch() API and implements a cache of Request/Response pairs. The Cache API enables a service worker to cache the scripts and other assets of the web app it serves and can also help to enable offline use of the web app (which is particularly important for mobile devices). A Web Manifest is a JSON-formatted file that describes a web application including a name, a URL, and links to icons in various sizes. If your web app uses a service worker and includes a \u003clink rel=\"manifest\"\u003e tag that references a .webmanifest file, then browsers (particularly browsers on mobile devices) may give you the option to add an icon for the web app to your desktop or home screen. The Notifications API allows web apps to display notifications using the native OS notification system on both mobile and desktop devices. Notifications can include an image and text, and your code can receive an event if the user clicks on the notification. Using this API is complicated by the fact that you must first request the user’s permission to display notifications. The Push API allows web applications that have a service worker (and that have the user’s permission) to subscribe to notifications from a server, and to display those notifications even when the application itself is not running. Push notifications are common on mobile devices, and the Push API brings web apps closer to feature parity with native apps on mobile. ","date":"2020-11-02","objectID":"/posts/ch15/:15:7","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.15.8 Mobile Device APIs There are a number of web APIs that are primarily useful for web apps running on mobile devices. (Unfortunately, a number of these APIs only work on Android devices and not iOS devices.) The Geolocation API allows JavaScript (with the user’s permission) to determine the user’s physical location. It is well supported on desktop and mobile devices, including iOS devices. Use navigator.geolocation.getCurrentPosition() to request the user’s current position and use navigator.geolocation.watchPosition() to register a callback to be called when the user’s position changes. The navigator.vibrate() method causes a mobile device (but not iOS) to vibrate. Often this is only allowed in response to a user gesture, but calling this method will allow your app to provide silent feedback that a gesture has been recognized. The ScreenOrientation API enables a web application to query the current orientation of a mobile device screen and also to lock themselves to landscape or portrait orientation. The “devicemotion” and “deviceorientation” events on the window object report accelerometer and magnetometer data for the device, enabling you to determine how the device is accelerating and how the user is orienting it in space. (These events do work on iOS.) The Sensor API is not yet widely supported beyond Chrome on Android devices, but it enables JavaScript access to the full suite of mobile device sensors, including accelerometer, gyroscope, magnetometer, and ambient light sensor. These sensors enable JavaScript to determine which direction a user is facing or to detect when the user shakes their phone, for example. ","date":"2020-11-02","objectID":"/posts/ch15/:15:8","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.15.9 Binary APIs Typed arrays, ArrayBuffers, and the DataView class (all covered in §11.2) enable JavaScript to work with binary data. As described earlier in this chapter, the fetch() API enables JavaScript programs to load binary data over the network. Another source of binary data is files from the user’s local filesystem. For security reasons, JavaScript can’t just read local files. But if the user selects a file for upload (using an \u003cinput type=\"file\u003e form element) or uses drag-and-drop to drop a file into your web application, then JavaScript can access that file as a File object. File is a subclass of Blob, and as such, it is an opaque representation of a chunk of data. You can use a FileReader class to asynchronously get the content of a file as an ArrayBuffer or string. (In some browsers, you can skip the FileReader and instead use the Promise-based text() and arrayBuffer() methods defined by the Blob class, or the stream() method for streaming access to the file contents.) When working with binary data, especially streaming binary data, you may need to decode bytes into text or encode text as bytes. The TextEncoder and TextDecoder classes help with this task. ","date":"2020-11-02","objectID":"/posts/ch15/:15:9","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.15.10 Media APIs The navigator.mediaDevices.getUserMedia() function allows JavaScript to request access to the user’s microphone and/or video camera. A successful request results in a MediaStream object. Video streams can be displayed in a \u003cvideo\u003e tag (by setting the srcObject property to the stream). Still frames of the video can be captured into an offscreen \u003ccanvas\u003e with the canvas drawImage() function resulting in a relatively low-resolution photograph. Audio and video streams returned by getUserMedia() can be recorded and encoded to a Blob with a MediaRecorder object. The more complex WebRTC API enables the transmission and reception of MediaStreams over the network, enabling peer-to-peer video conferencing, for example. ","date":"2020-11-02","objectID":"/posts/ch15/:15:10","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"15.15.11 Cryptography and Related APIs The crypto property of the Window object exposes a getRandomValues() method for cryptographically secure pseudorandom numbers. Other methods for encryption, decryption, key generation, digital signatures, and so on are available through crypto.subtle. The name of this property is a warning to everyone who uses these methods that properly using cryptographic algorithms is difficult and that you should not use those methods unless you really know what you are doing. Also, the methods of crypto.subtle are only available to JavaScript code running within documents that were loaded over a secure HTTPS connection. The Credential Management API and the Web Authentication API allow JavaScript to generate, store, and retrieve public key (and other types of) credentials and enables account creation and login without passwords. The JavaScript API consists primarily of the functions navigator.credentials.create() and navigator.credentials.get(), but substantial infrastructure is required on the server side to make these methods work. These APIs are not universally supported yet, but have the potential to revolutionize the way we log in to websites. The Payment Request API adds browser support for making credit card payments on the web. It allows users to store their payment details securely in the browser so that they don’t have to type their credit card number each time they make a purchase. Web applications that want to request a payment create a PaymentRequest object and call its show() method to display the request to the user. 1 Previous editions of this book had an extensive reference section covering the JavaScript standard library and web APIs. It was removed in the seventh edition because MDN has made it obsolete: today, it is quicker to look something up on MDN than it is to flip through a book, and my former colleagues at MDN do a better job at keeping their online documentation up to date than this book ever could. 2 Some sources, including the HTML specification, make a technical distinction between handlers and listeners, based on the way in which they are registered. In this book, we treat the two terms as synonyms. 3 If you have used the React framework to create client-side user interfaces, this may surprise you. React makes a number of minor changes to the client-side event model, and one of them is that in React, event handler property names are written in camelCase: onClick, onMouseOver, and so on. When working with the web platform natively, however, the event handler properties are written entirely in lowercase. 4 The custom element specification allows subclassing of \u003cbutton\u003e and other specific element classes, but this is not supported in Safari and a different syntax is required to use a custom element that extends anything other than HTMLElement. ","date":"2020-11-02","objectID":"/posts/ch15/:15:11","tags":null,"title":"第 15 章 Web 浏览器中的 JavaScript","uri":"/posts/ch15/"},{"categories":null,"content":"Node is JavaScript with bindings to the underlying operating system, making it possible to write JavaScript programs that read and write files, execute child processes, and communicate over the network. This makes Node useful as a: Node是绑定到底层操作系统的JavaScript，使编写JavaScript程序能够读写文件、执行子进程和通过网络通信。这使得Node可以用作: Modern alternative to shell scripts that does not suffer from the arcane syntax of bash and other Unix shells. General-purpose programming language for running trusted programs, not subject to the security constraints imposed by web browsers on untrusted code. Popular environment for writing efficient and highly concurrent web servers. 不受bash和其他Unix shell的神秘语法影响的shell脚本的现代替代方案。 通用程式设计语言，用以运行受信任的程式，而不受网页浏览器对不受信任的程式所施加的保安限制。 编写高效和高并发web服务器的流行环境。 The defining feature of Node is its single-threaded event-based concurrency enabled by an asynchronous-by-default API. If you have programmed in other languages but have not done much JavaScript coding, or if you’re an experienced client-side JavaScript programmer used to writing code for web browers, using Node will be a bit of an adjustment, as is any new programming language or environment. This chapter begins by explaining the Node programming model, with an emphasis on concurrency, Node’s API for working with streaming data, and Node’s Buffer type for working with binary data. These initial sections are followed by sections that highlight and demonstrate some of the most important Node APIs, including those for working with files, networks, processes, and threads. Node的定义特性是它的单线程的基于事件的并发性，这是通过一个默认异步的API实现的。如果您使用其他语言编写过程序，但没有进行过多的JavaScript编码，或者如果您是一名经验丰富的客户端JavaScript程序员，习惯于为web浏览器编写代码，那么使用Node就需要一点调整，任何新的编程语言或环境都是如此。本章从解释节点编程模型开始，重点介绍并发性、处理流数据的节点API和处理二进制数据的节点缓冲区类型。在这些初始部分之后是突出显示和演示一些最重要的节点api的部分，包括那些用于处理文件、网络、进程和线程的api。 One chapter is not enough to document all of Node’s APIs, but my hope is that this chapter will explain enough of the fundamentals to make you productive with Node, and confident that you can master any new APIs you need. 一章不足以记录所有的Node api，但我希望这一章能够解释足够多的基础知识，使您能够高效地使用Node，并确信您能够掌握所需的任何新的api。 INSTALLING NODE Node is open source software. Visit https://nodejs.org to download and install Node for Windows and MacOS. On Linux, you may be able to install Node with your normal package manager, or you can visit https://nodejs.org/en/download to download the binaries directly. If you work on containerized software, you can find official Node Docker images at https://hub.docker.com. Node是开源软件。访问https://nodejs.org下载并安装用于Windows和MacOS的节点。在Linux上，您可以使用普通的包管理器安装Node，或者您可以访问https://nodejs.org/en/download来直接下载二进制文件。如果您使用的是容器化软件，您可以在https://hub.docker.com找到官方节点Docker镜像。 In addition to the Node executable, a Node installation also includes npm, a package manager that enables easy access to a vast ecosystem of JavaScript tools and libraries. The examples in this chapter will use only Node’s built-in packages and will not require npm or any external libraries. 除了节点可执行文件之外，节点安装还包括npm，这是一个包管理器，可以方便地访问大量的JavaScript工具和库。本章中的示例将只使用Node的内置包，而不需要npm或任何外部库。 Finally, do not overlook the official Node documentation, available at https://nodejs.org/api and https://nodejs.org/docs/guides. I have found it to be well organized and well written. 最后，不要忽视官方节点文档，可以从https://nodejs.org/api和https://nodejs.org/docs/guides获得。我发现它组织得很好，写得也很好。 ","date":"2020-11-02","objectID":"/posts/ch16/:0:0","tags":null,"title":"第 16 章 服务器端 JavaScript","uri":"/posts/ch16/"},{"categories":null,"content":"16.1 Node Programming Basics We’ll begin this chapter with a quick look at how Node programs are structured and how they interact with the operating system. 在本章的开始，我们将快速了解节点程序是如何构建的，以及它们如何与操作系统交互。 ","date":"2020-11-02","objectID":"/posts/ch16/:1:0","tags":null,"title":"第 16 章 服务器端 JavaScript","uri":"/posts/ch16/"},{"categories":null,"content":"16.1.1 Console Output If you are used to JavaScript programming for web browsers, one of the minor surprises about Node is that console.log() is not just for debugging, but is Node’s easiest way to display a message to the user, or, more generally, to send output to the stdout stream. Here’s the classic “Hello World” program in Node: 如果您习惯了web浏览器的JavaScript编程，那么Node的一个小惊喜就是console.log()不仅用于调试，而且是Node向用户显示消息的最简单的方式，或者更一般地，将输出发送到stdout流的最简单方式。下面是Node中的经典“Hello World”程序: console.log(\"Hello World!\"); There are lower-level ways to write to stdout, but no fancier or more official way than simply calling console.log(). 有一些低级别的方法可以写入stdout，但是没有比简单地调用console.log()更高级或更正式的方法了。 In web browsers, console.log(), console.warn(), and console.error() typically display little icons next to their output in the developer console to indicate the variety of the log message. Node does not do this, but output displayed with console.error() is distinguished from output displayed with console.log() because console.error() writes to the stderr stream. If you’re using Node to write a program that is designed to have stdout redirected to a file or a pipe, you can use console.error() to display text to the console where the user will see it, even though text printed with console.log() is hidden. 在web浏览器中，console.log()、console.warn()和console.error()通常在开发人员控制台中它们的输出旁边显示小图标，以指示日志消息的种类。Node不这样做，但是使用console.error()显示的输出与使用console.log()显示的输出是不同的，因为console.error()写入stderr流。如果您正在使用Node编写一个程序，该程序设计为将stdout重定向到文件或管道，那么您可以使用console.error()将文本显示到控制台，用户将在那里看到它，即使使用console.log()打印的文本是隐藏的。 ","date":"2020-11-02","objectID":"/posts/ch16/:1:1","tags":null,"title":"第 16 章 服务器端 JavaScript","uri":"/posts/ch16/"},{"categories":null,"content":"16.1.2 Command-Line Arguments and Environment Variables If you have previously written Unix-style programs designed to be invoked from a terminal or other command-line interface, you know that these programs typically get their input primarily from command-line arguments and secondarily from environment variables. Node follows these Unix conventions. A Node program can read its command-line arguments from the array of strings process.argv. The first element of this array is always the path to the Node executable. The second argument is the path to the file of JavaScript code that Node is executing. Any remaining elements in this array are the space-separated arguments that you passed on the command-line when you invoked Node. For example, suppose you save this very short Node program to the file argv.js: console.log(process.argv); You can then execute the program and see output like this: $ node –trace-uncaught argv.js –arg1 –arg2 filename [ ‘/usr/local/bin/node’, ‘/private/tmp/argv.js’, ‘–arg1’, ‘–arg2’, ‘filename’ ] There are a couple of things to note here: The first and second elements of process.argv will be fully qualified filesystem paths to the Node executable and the file of JavaScript that is being executed, even if you did not type them that way. Command-line arguments that are intended for and interpreted by the Node executable itself are consumed by the Node executable and do not appear in process.argv. (The –trace-uncaught command-line argument isn’t actually doing anything useful in the previous example; it is just there to demonstrate that it does not appear in the output.) Any arguments (such as –arg1 and filename) that appear after the name of the JavaScript file will appear in process.argv. Node programs can also take input from Unix-style environment variables. Node makes these available though the process.env object. The property names of this object are environment variable names, and the property values (always strings) are the values of those variables. Here is a partial list of environment variables on my system: $ node -p -e ‘process.env’ { SHELL: ‘/bin/bash’, USER: ‘david’, PATH: ‘/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin’, PWD: ‘/tmp’, LANG: ‘en_US.UTF-8’, HOME: ‘/Users/david’, } You can use node -h or node –help to find out what the -p and -e command-line arguments do. However, as a hint, note that you could rewrite the line above as node –eval ‘process.env’ –print. ","date":"2020-11-02","objectID":"/posts/ch16/:1:2","tags":null,"title":"第 16 章 服务器端 JavaScript","uri":"/posts/ch16/"},{"categories":null,"content":"16.1.3 Program Life Cycle The node command expects a command-line argument that specifies the file of JavaScript code to be run. This initial file typically imports other modules of JavaScript code, and may also define its own classes and functions. Fundamentally, however, Node executes the JavaScript code in the specified file from top to bottom. Some Node programs exit when they are done executing the last line of code in the file. Often, however, a Node program will keep running long after the initial file has been executed. As we’ll discuss in the following sections, Node programs are often asynchronous and based on callbacks and event handlers. Node programs do not exit until they are done running the initial file and until all callbacks have been called and there are no more pending events. A Node-based server program that listens for incoming network connections will theoretically run forever because it will always be waiting for more events. A program can force itself to exit by calling process.exit(). Users can usually terminate a Node program by typing Ctrl-C in the terminal window where the program is running. A program can ignore Ctrl-C by registering a signal handler function with process.on(“SIGINT”, ()=\u003e{}). If code in your program throws an exception and no catch clause catches it, the program will print a stack trace and exit. Because of Node’s asynchronous nature, exceptions that occur in callbacks or event handlers must be handled locally or not handled at all, which means that handling exceptions that occur in the asynchronous parts of your program can be a difficult problem. If you don’t want these exceptions to cause your program to completely crash, register a global handler function that will be invoked instead of crashing: process.setUncaughtExceptionCaptureCallback(e =\u003e { console.error(“Uncaught exception:”, e); }); A similar situation arises if a Promise created by your program is rejected and there is no .catch() invocation to handle it. As of Node 13, this is not a fatal error that causes your program to exit, but it does print a verbose error message to the console. In some future version of Node, unhandled Promise rejections are expected to become fatal errors. If you do not want unhandled rejections, to print error messages or terminate your program, register a global handler function: process.on(“unhandledRejection”, (reason, promise) =\u003e { // reason is whatever value would have been passed to a .catch() function // promise is the Promise object that rejected }); ","date":"2020-11-02","objectID":"/posts/ch16/:1:3","tags":null,"title":"第 16 章 服务器端 JavaScript","uri":"/posts/ch16/"},{"categories":null,"content":"16.1.4 Node Modules Chapter 10 documented JavaScript module systems, covering both Node modules and ES6 modules. Because Node was created before JavaScript had a module system, Node had to create its own. Node’s module system uses the require() function to import values into a module and the exports object or the module.exports property to export values from a module. These are a fundamental part of the Node programming model, and they are covered in detail in §10.2. Node 13 adds support for standard ES6 modules as well as require-based modules (which Node calls “CommonJS modules”). The two module systems are not fully compatible, so this is somewhat tricky to do. Node needs to know—before it loads a module—whether that module will be using require() and module.exports or if it will be using import and export. When Node loads a file of JavaScript code as a CommonJS module, it automatically defines the require() function along with identifiers exports and module, and it does not enable the import and export keywords. On the other hand, when Node loads a file of code as an ES6 module, it must enable the import and export declarations, and it must not define extra identifiers like require, module, and exports. The simplest way to tell Node what kind of module it is loading is to encode this information in the file extension. If you save your JavaScript code in a file that ends with .mjs, then Node will always load it as an ES6 module, will expect it to use import and export, and will not provide a require() function. And if you save your code in a file that ends with .cjs, then Node will always treat it as a CommonJS module, will provide a require() function, and will throw a SyntaxError if you use import or export declarations. For files that do not have an explicit .mjs or .cjs extension, Node looks for a file named package.json in the same directory as the file and then in each of the containing directories. Once the nearest package.json file is found, Node checks for a top-level type property in the JSON object. If the value of the type property is “module”, then Node loads the file as an ES6 module. If the value of that property is “commonjs”, then Node loads the file as a CommonJS module. Note that you do not need to have a package.json file to run Node programs: when no such file is found (or when the file is found but it does not have a type property), Node defaults to using CommonJS modules. This package.json trick only becomes necessary if you want to use ES6 modules with Node and do not want to use the .mjs file extension. Because there is an enormous amount of existing Node code written using CommonJS module format, Node allows ES6 modules to load CommonJS modules using the import keyword. The reverse is not true, however: a CommonJS module cannot use require() to load an ES6 module. ","date":"2020-11-02","objectID":"/posts/ch16/:1:4","tags":null,"title":"第 16 章 服务器端 JavaScript","uri":"/posts/ch16/"},{"categories":null,"content":"16.1.5 The Node Package Manager When you install Node, you typically get a program named npm as well. This is the Node Package Manager, and it helps you download and manage libraries that your program depends on. npm keeps track of those dependencies (as well as other information about your program) in a file named package.json in the root directory of your project. This package.json file created by npm is where you would add “type”:“module” if you wanted to use ES6 modules for your project. This chapter does not cover npm in any detail (but see §17.4 for a little more depth). I’m mentioning it here because unless you write programs that do not use any external libraries, you will almost certainly be using npm or a tool like it. Suppose, for example, that you are going to be developing a web server and plan to use the Express framework (https://expressjs.com) to simplify the task. To get started, you might create a directory for your project, and then, in that directory type npm init. npm will ask you for your project name, version number, etc., and will then create an initial package.json file based on your responses. Now to start using Express, you’d type npm install express. This tells npm to download the Express library along with all of its dependencies and install all the packages in a local node_modules/ directory: $ npm install express npm notice created a lockfile as package-lock.json. You should commit this file. npm WARN my-server@1.0.0 No description npm WARN my-server@1.0.0 No repository field. + express@4.17.1 added 50 packages from 37 contributors and audited 126 packages in 3.058s found 0 vulnerabilities When you install a package with npm, npm records this dependency—that your project depends on Express—in the package.json file. With this dependency recorded in package.json, you could give another programmer a copy of your code and your package.json, and they could simply type npm install to automatically download and install all of the libraries that your program needs in order to run. ","date":"2020-11-02","objectID":"/posts/ch16/:1:5","tags":null,"title":"第 16 章 服务器端 JavaScript","uri":"/posts/ch16/"},{"categories":null,"content":"16.2 Node Is Asynchronous by Default JavaScript is a general-purpose programming language, so it is perfectly possible to write CPU-intensive programs that multiply large matrices or perform complicated statistical analyses. But Node was designed and optimized for programs—like network servers—that are I/O intensive. And in particular, Node was designed to make it possible to easily implement highly concurrent servers that can handle many requests at the same time. Unlike many programming languages, however, Node does not achieve concurrency with threads. Multithreaded programming is notoriously hard to do correctly, and difficult to debug. Also, threads are a relatively heavyweight abstraction and if you want to write a server that can handle hundreds of concurrent requests, using hundreds of threads may require a prohibitive amount of memory. So Node adopts the single-threaded JavaScript programming model that the web uses, and this turns out to be a vast simplification that makes the creation of network servers a routine skill rather than an arcane one. TRUE PARALLELISM WITH NODE Node programs can run multiple operating system processes, and Node 10 and later support Worker objects (§16.11), which are a kind of thread borrowed from web browsers. If you use multiple processes or create one or more Worker threads and run your program on a system with more than one CPU, then your program will no longer be single-threaded and your program will truly be executing multiple streams of code in parallel. These techniques can be valuable for CPU-intensive operations but are not commonly used for I/O-intensive programs like servers. It is worth noting, however, that Node’s processes and Workers avoid the typical complexity of multithreaded programming because interprocess and inter-Worker communication is via message passing and they cannot easily share memory with each other. Node achieves high levels of concurrency while maintaining a single-threaded programming model by making its API asynchronous and nonblocking by default. Node takes its nonblocking approach very seriously and to an extreme that may surprise you. You probably expect functions that read from and write to the network to be asynchronous, but Node goes further and defines nonblocking asynchronous functions for reading and writing files from the local filesystem. This makes sense, when you think about it: the Node API was designed in the days when spinning hard drives were still the norm and there really were milliseconds of blocking “seek time” while waiting for the disc to spin around before a file operation could begin. And in modern datacenters, the “local” filesystem may actually be across the network somewhere with network latencies on top of drive latencies. But even if reading a file asynchronously seems normal to you, Node takes it still further: the default functions for initiating a network connection or looking up a file modification time, for example, are also nonblocking. Some functions in Node’s API are synchronous but nonblocking: they run to completion and return without ever needing to block. But most of the interesting functions perform some kind of input or output, and these are asynchronous functions so they can avoid even the tiniest amount of blocking. Node was created before JavaScript had a Promise class, so asynchronous Node APIs are callback-based. (If you have not yet read or have already forgotten Chapter 13, this would be a good time to skip back to that chapter.) Generally, the last argument you pass to an asynchronous Node function is a callback. Node uses error-first callbacks, which are typically invoked with two arguments. The first argument to an error-first callback is normally null in the case where no error occurred, and the second argument is whatever data or response was produced by the original asynchronous function you called. The reason for putting the error argument first is to make it impossible for you to omit it, and you","date":"2020-11-02","objectID":"/posts/ch16/:2:0","tags":null,"title":"第 16 章 服务器端 JavaScript","uri":"/posts/ch16/"},{"categories":null,"content":"16.3 Buffers One of the datatypes you’re likely to use frequently in Node—especially when reading data from files or from the network—is the Buffer class. A Buffer is a lot like a string, except that it is a sequence of bytes instead of a sequence of characters. Node was created before core JavaScript supported typed arrays (see §11.2) and there was no Uint8Array to represent an array of unsigned bytes. Node defined the Buffer class to fill that need. Now that Uint8Array is part of the JavaScript language, Node’s Buffer class is a subclass of Uint8Array. What distinguishes Buffer from its Uint8Array superclass is that it is designed to interoperate with JavaScript strings: the bytes in a buffer can be initialized from character strings or converted to character strings. A character encoding maps each character in some set of characters to an integer. Given a string of text and a character encoding, we can encode the characters in the string into a sequence of bytes. And given a (properly encoded) sequence of bytes and a character encoding, we can decode those bytes into a sequence of characters. Node’s Buffer class has methods that perform both encoding and decoding, and you can recognize these methods because they expect an encoding argument that specifies the encoding to be used. Encodings in Node are specified by name, as strings. The supported encodings are: “utf8” This is the default when no encoding is specified, and is the Unicode encoding you are most likely to use. “utf16le” Two-byte Unicode characters, with little-endian ordering. Codepoints above \\uffff are encoded as a pair of two-byte sequences. Encoding “ucs2” is an alias. “latin1” The one-byte-per-character ISO-8859-1 encoding that defines a character set suitable for many Western European languages. Because there is a one-to-one mapping between bytes and latin-1 characters, this encoding is also known as “binary”. “ascii” The 7-bit English-only ASCII encoding, a strict subset of the “utf8” encoding. “hex” This encoding converts each byte to a pair of ASCII hexadecimal digits. “base64” This encoding converts each sequence of three bytes into a sequence of four ascii characters. Here is some example code that demonstrates how to work with Buffers and how to convert to and from strings: let b = Buffer.from([0x41, 0x42, 0x43]); // \u003cBuffer 41 42 43\u003e b.toString() // =\u003e “ABC”; default “utf8” b.toString(“hex”) // =\u003e “414243” let computer = Buffer.from(“IBM3111”, “ascii”); // Convert string to Buffer for(let i = 0; i \u003c computer.length; i++) { // Use Buffer as byte array computer[i]–; // Buffers are mutable } computer.toString(“ascii”) // =\u003e “HAL2000” computer.subarray(0,3).map(x=\u003ex+1).toString() // =\u003e “IBM” // Create new “empty” buffers with Buffer.alloc() let zeros = Buffer.alloc(1024); // 1024 zeros let ones = Buffer.alloc(128, 1); // 128 ones let dead = Buffer.alloc(1024, “DEADBEEF”, “hex”); // Repeating pattern of bytes // Buffers have methods for reading and writing multi-byte values // from and to a buffer at any specified offset. dead.readUInt32BE(0) // =\u003e 0xDEADBEEF dead.readUInt32BE(1) // =\u003e 0xADBEEFDE dead.readBigUInt64BE(6) // =\u003e 0xBEEFDEADBEEFDEADn dead.readUInt32LE(1020) // =\u003e 0xEFBEADDE If you write a Node program that actually manipulates binary data, you may find yourself using the Buffer class extensively. On the other hand, if you are just working with text that is read from or written to a file or the network, then you may only encounter Buffer as an intermediate representation of your data. A number of Node APIs can take input or return output as either strings or Buffer objects. Typically, if you pass a string, or expect a string to be returned, from one of these APIs, you’ll need to specify the name of the text encoding you want to use. And if you do this, then you may not need to use a Buffer object at all. ","date":"2020-11-02","objectID":"/posts/ch16/:3:0","tags":null,"title":"第 16 章 服务器端 JavaScript","uri":"/posts/ch16/"},{"categories":null,"content":"16.4 Events and EventEmitter As described, all of Node’s APIs are asynchronous by default. For many of them, this asynchrony takes the form of two-argument error-first callbacks that are invoked when the requested operation is complete. But some of the more complicated APIs are event-based instead. This is typically the case when the API is designed around an object rather than a function, or when a callback function needs to be invoked multiple times, or when there are multiple types of callback functions that may be required. Consider the net.Server class, for example: an object of this type is a server socket that is used to accept incoming connections from clients. It emits a “listening” event when it first starts listening for connections, a “connection” event every time a client connects, and a “close” event when it has been closed and is no longer listening. In Node, objects that emit events are instances of EventEmitter or a subclass of EventEmitter: const EventEmitter = require(“events”); // Module name does not match class name const net = require(“net”); let server = new net.Server(); // create a Server object server instanceof EventEmitter // =\u003e true: Servers are EventEmitters The main feature of EventEmitters is that they allow you to register event handler functions with the on() method. EventEmitters can emit multiple types of events, and event types are identified by name. To register an event handler, call the on() method, passing the name of the event type and the function that should be invoked when an event of that type occurs. EventEmitters can invoke handler functions with any number of arguments, and you need to read the documentation for a specific kind of event from a specific EventEmitter to know what arguments you should expect to be passed: const net = require(“net”); let server = new net.Server(); // create a Server object server.on(“connection”, socket =\u003e { // Listen for “connection” events // Server “connection” events are passed a socket object // for the client that just connected. Here we send some data // to the client and disconnect. socket.end(“Hello World”, “utf8”); }); If you prefer more explicit method names for registering event listeners, you can also use addListener(). And you can remove a previously registered event listener with off() or removeListener(). As a special case, you can register an event listener that will be automatically removed after it is triggered for the first time by calling once() instead of on(). When an event of a particular type occurs for a particular EventEmitter object, Node invokes all of the handler functions that are currently registered on that EventEmitter for events of that type. They are invoked in order from the first registered to the last registered. If there is more than one handler function, they are invoked sequentially on a single thread: there is no parallelism in Node, remember. And, importantly, event handling functions are invoked synchronously, not asynchronously. What this means is that the emit() method does not queue up event handlers to be invoked at some later time. emit() invokes all the registered handlers, one after the other, and does not return until the last event handler has returned. What this means, in effect, is that when one of the built-in Node APIs emits an event, that API is basically blocking on your event handlers. If you write an event handler that calls a blocking function like fs.readFileSync(), no further event handling will happen until your synchronous file read is complete. If your program is one—like a network server—that needs to be responsive, then it is important that you keep your event handler functions nonblocking and fast. If you need to do a lot of computation when an event occurs, it is often best to use the handler to schedule that computation asynchronously using setTimeout() (see §11.10). Node also defines setImmediate(), which schedules a function to be invoked immediately after all pending callba","date":"2020-11-02","objectID":"/posts/ch16/:4:0","tags":null,"title":"第 16 章 服务器端 JavaScript","uri":"/posts/ch16/"},{"categories":null,"content":"16.5 Streams When implementing an algorithm to process data, it is almost always easiest to read all the data into memory, do the processing, and then write the data out. For example, you could write a Node function to copy a file like this.1 const fs = require(“fs”); // An asynchronous but nonstreaming (and therefore inefficient) function. function copyFile(sourceFilename, destinationFilename, callback) { fs.readFile(sourceFilename, (err, buffer) =\u003e { if (err) { callback(err); } else { fs.writeFile(destinationFilename, buffer, callback); } }); } This copyFile() function uses asynchronous functions and callbacks, so it does not block and is suitable for use in concurrent programs like servers. But notice that it must allocate enough memory to hold the entire contents of the file in memory at once. This may be fine in some use cases, but it starts to fail if the files to be copied are very large, or if your program is highly concurrent and there may be many files being copied at the same time. Another shortcoming of this copyFile() implementation is that it cannot start writing the new file until it has finished reading the old file. The solution to these problems is to use streaming algorithms where data “flows” into your program, is processed, and then flows out of your program. The idea is that your algorithm processes the data in small chunks and the full dataset is never held in memory at once. When streaming solutions are possible, they are more memory efficient and can also be faster. Node’s networking APIs are stream-based and Node’s filesystem module defines streaming APIs for reading and writing files, so you are likely to use a streaming API in many of the Node programs that you write. We’ll see a streaming version of the copyFile() function in “Flowing mode”. Node supports four basic stream types: Readable Readable streams are sources of data. The stream returned by fs.createReadStream(), for example, is a stream from which the content of a specified file can be read. process.stdin is another Readable stream that returns data from standard input. Writable Writable streams are sinks or destinations for data. The return value of fs.createWriteStream(), for example, is a Writable stream: it allows data to be written to it in chunks, and outputs all of that data to a specified file. Duplex Duplex streams combine a Readable stream and a Writable stream into one object. The Socket objects returned by net.connect() and other Node networking APIs, for example, are Duplex streams. If you write to a socket, your data is sent across the network to whatever computer the socket is connected to. And if you read from a socket, you access the data written by that other computer. Transform Transform streams are also readable and writable, but they differ from Duplex streams in an important way: data written to a Transform stream becomes readable—usually in some transformed form—from the same stream. The zlib.createGzip() function, for example, returns a Transform stream that compresses (with the gzip algorithm) the data written to it. In a similar way, the crypto.createCipheriv() function returns a Transform stream that encrypts or decrypts data that is written to it. By default, streams read and write buffers. If you call the setEncoding() method of a Readable stream, it will return decoded strings to you instead of Buffer objects. And if you write a string to a Writable buffer, it will be automatically encoded using the buffer’s default encoding or whatever encoding you specify. Node’s stream API also supports an “object mode” where streams read and write objects more complex than buffers and strings. None of Node’s core APIs use this object mode, but you may encounter it in other libraries. Readable streams have to read their data from somewhere, and Writable streams have to write their data to somewhere, so every stream has two ends: an input and an output or a source and a destination. The tricky thing about stream-based APIs i","date":"2020-11-02","objectID":"/posts/ch16/:5:0","tags":null,"title":"第 16 章 服务器端 JavaScript","uri":"/posts/ch16/"},{"categories":null,"content":"16.5.1 Pipes Sometimes, you need to read data from a stream simply to turn around and write that same data to another stream. Imagine, for example, that you are writing a simple HTTP server that serves a directory of static files. In this case, you will need to read data from a file input stream and write it out to a network socket. But instead of writing your own code to handle the reading and writing, you can instead simply connect the two sockets together as a “pipe” and let Node handle the complexities for you. Simply pass the Writable stream to the pipe() method of the Readable stream: const fs = require(“fs”); function pipeFileToSocket(filename, socket) { fs.createReadStream(filename).pipe(socket); } The following utility function pipes one stream to another and invokes a callback when done or when an error occurs: function pipe(readable, writable, callback) { // First, set up error handling function handleError(err) { readable.close(); writable.close(); callback(err); } // Next define the pipe and handle the normal termination case readable .on(\"error\", handleError) .pipe(writable) .on(\"error\", handleError) .on(\"finish\", callback); } Transform streams are particularly useful with pipes, and create pipelines that involve more than two streams. Here’s an example function that compresses a file: const fs = require(“fs”); const zlib = require(“zlib”); function gzip(filename, callback) { // Create the streams let source = fs.createReadStream(filename); let destination = fs.createWriteStream(filename + “.gz”); let gzipper = zlib.createGzip(); // Set up the pipeline source .on(\"error\", callback) // call callback on read error .pipe(gzipper) .pipe(destination) .on(\"error\", callback) // call callback on write error .on(\"finish\", callback); // call callback when writing is complete } Using the pipe() method to copy data from a Readable stream to a Writable stream is easy, but in practice, you often need to process the data somehow as it streams through your program. One way to do this is to implement your own Transform stream to do that processing, and this approach allows you to avoid manually reading and writing the streams. Here, for example, is a function that works like the Unix grep utility: it reads lines of text from an input stream, but writes only the lines that match a specified regular expression: const stream = require(“stream”); class GrepStream extends stream.Transform { constructor(pattern) { super({decodeStrings: false});// Don’t convert strings back to buffers this.pattern = pattern; // The regular expression we want to match this.incompleteLine = “\"; // Any remnant of the last chunk of data } // This method is invoked when there is a string ready to be // transformed. It should pass transformed data to the specified // callback function. We expect string input so this stream should // only be connected to readable streams that have had // setEncoding() called on them. _transform(chunk, encoding, callback) { if (typeof chunk !== \"string\") { callback(new Error(\"Expected a string but got a buffer\")); return; } // Add the chunk to any previously incomplete line and break // everything into lines let lines = (this.incompleteLine + chunk).split(\"\\n\"); // The last element of the array is the new incomplete line this.incompleteLine = lines.pop(); // Find all matching lines let output = lines // Start with all complete lines, .filter(l =\u003e this.pattern.test(l)) // filter them for matches, .join(\"\\n\"); // and join them back up. // If anything matched, add a final newline if (output) { output += \"\\n\"; } // Always call the callback even if there is no output callback(null, output); } // This is called right before the stream is closed. // It is our chance to write out any last data. _flush(callback) { // If we still have an incomplete line, and it matches // pass it to the callback if (this.pattern.test(this.incompleteLine)) { callback(null, this.incompleteLine + \"\\n\"); } } } // Now we can write a program like ‘grep’ with t","date":"2020-11-02","objectID":"/posts/ch16/:5:1","tags":null,"title":"第 16 章 服务器端 JavaScript","uri":"/posts/ch16/"},{"categories":null,"content":"16.5.2 Asynchronous Iteration In Node 12 and later, Readable streams are asynchronous iterators, which means that within an async function you can use a for/await loop to read string or Buffer chunks from a stream using code that is structured like synchronous code would be. (See §13.4 for more on asynchronous iterators and for/await loops.) Using an asynchronous iterator is almost as easy as using the pipe() method, and is probably easier when you need to process each chunk you read in some way. Here’s how we could rewrite the grep program in the previous section using an async function and a for/await loop: // Read lines of text from the source stream, and write any lines // that match the specified pattern to the destination stream. async function grep(source, destination, pattern, encoding=“utf8”) { // Set up the source stream for reading strings, not Buffers source.setEncoding(encoding); // Set an error handler on the destination stream in case standard // output closes unexpectedly (when piping output to `head`, e.g.) destination.on(\"error\", err =\u003e process.exit()); // The chunks we read are unlikely to end with a newline, so each will // probably have a partial line at the end. Track that here let incompleteLine = \"\"; // Use a for/await loop to asynchronously read chunks from the input stream for await (let chunk of source) { // Split the end of the last chunk plus this one into lines let lines = (incompleteLine + chunk).split(\"\\n\"); // The last line is incomplete incompleteLine = lines.pop(); // Now loop through the lines and write any matches to the destination for(let line of lines) { if (pattern.test(line)) { destination.write(line + \"\\n\", encoding); } } } // Finally, check for a match on any trailing text. if (pattern.test(incompleteLine)) { destination.write(incompleteLine + \"\\n\", encoding); } } let pattern = new RegExp(process.argv[2]); // Get a RegExp from command line. grep(process.stdin, process.stdout, pattern) // Call the async grep() function. .catch(err =\u003e { // Handle asynchronous exceptions. console.error(err); process.exit(); }); ","date":"2020-11-02","objectID":"/posts/ch16/:5:2","tags":null,"title":"第 16 章 服务器端 JavaScript","uri":"/posts/ch16/"},{"categories":null,"content":"16.5.3 Writing to Streams and Handling Backpressure The async grep() function in the preceding code example demonstrated how to use a Readable stream as an asynchronous iterator, but it also demonstrated that you can write data to a Writable stream simply by passing it to the write() method. The write() method takes a buffer or string as the first argument. (Object streams expect other kinds of objects, but are beyond the scope of this chapter.) If you pass a buffer, the bytes of that buffer will be written directly. If you pass a string, it will be encoded to a buffer of bytes before being written. Writable streams have a default encoding that is used when you pass a string as the only argument to write(). The default encoding is typically “utf8,” but you can set it explicitly by calling setDefaultEncoding() on the Writable stream. Alternatively, when you pass a string as the first argument to write() you can pass an encoding name as the second argument. write() optionally takes a callback function as its third argument. This will be invoked when the data has actually been written and is no longer in the Writable stream’s internal buffer. (This callback may also be invoked if an error occurs, but this is not guaranteed. You should register an “error” event handler on the Writable stream to detect errors.) The write() method has a very important return value. When you call write() on a stream, it will always accept and buffer the chunk of data you have passed. It then returns true if the internal buffer is not yet full. Or, if the buffer is now full or overfull, it returns false. This return value is advisory, and you can ignore it—Writable streams will enlarge their internal buffer as much as needed if you keep calling write(). But remember that the reason to use a streaming API in the first place is to avoid the cost of keeping lots of data in memory at once. A return value of false from the write() method is a form of backpressure: a message from the stream that you have written data more quickly than it can be handled. The proper response to this kind of backpressure is to stop calling write() until the stream emits a “drain” event, signaling that there is once again room in the buffer. Here, for example, is a function that writes to a stream, and then invokes a callback when it is OK to write more data to the stream: function write(stream, chunk, callback) { // Write the specified chunk to the specified stream let hasMoreRoom = stream.write(chunk); // Check the return value of the write() method: if (hasMoreRoom) { // If it returned true, then setImmediate(callback); // invoke callback asynchronously. } else { // If it returned false, then stream.once(\"drain\", callback); // invoke callback on drain event. } } The fact that it is sometimes OK to call write() multiple times in a row and sometimes you have to wait for an event between writes makes for awkward algorithms. This is one of the reasons that using the pipe() method is so appealing: when you use pipe(), Node handles backpressure for you automatically. If you are using await and async in your program, and are treating Readable streams as asynchronous iterators, it is straightforward to implement a Promise-based version of the write() utility function above to properly handle backpressure. In the async grep() function we just looked at, we did not handle backpressure. The async copy() function in the following example demonstrates how it can be done correctly. Note that this function just copies chunks from a source stream to a destination stream and calling copy(source, destination) is much like calling source.pipe(destination): // This function writes the specified chunk to the specified stream and // returns a Promise that will be fulfilled when it is OK to write again. // Because it returns a Promise, it can be used with await. function write(stream, chunk) { // Write the specified chunk to the specified stream let hasMoreRoom = stream.write(chunk); if (hasMoreRo","date":"2020-11-02","objectID":"/posts/ch16/:5:3","tags":null,"title":"第 16 章 服务器端 JavaScript","uri":"/posts/ch16/"},{"categories":null,"content":"16.5.4 Reading Streams with Events Node’s readable streams have two modes, each of which has its own API for reading. If you can’t use pipes or asynchronous iteration in your program, you will need to pick one of these two event-based APIs for handling streams. It is important that you use only one or the other and do not mix the two APIs. FLOWING MODE In flowing mode, when readable data arrives, it is immediately emitted in the form of a “data” event. To read from a stream in this mode, simply register an event handler for “data” events, and the stream will push chunks of data (buffers or strings) to you as soon as they becomes available. Note that there is no need to call the read() method in flowing mode: you only need to handle “data” events. Note that newly created streams do not start off in flowing mode. Registering a “data” event handler switches a stream into flowing mode. Conveniently, this means that a stream does not emit “data” events until you register the first “data” event handler. If you are using flowing mode to read data from a Readable stream, process it, then write it to a Writable stream, then you may need to handle backpressure from the Writable stream. If the write() method returns false to indicate that the write buffer is full, you can call pause() on the Readable stream to temporarily stop data events. Then, when you get a “drain” event from the Writable stream, you can call resume() on the Readable stream to start the “data” events flowing again. A stream in flowing mode emits an “end” event when the end of the stream is reached. This event indicates that no more “data” events will ever be emitted. And, as with all streams, an “error” event is emitted if an error occurs. At the beginning of this section on streams, we showed a nonstreaming copyFile() function and promised a better version to come. The following code shows how to implement a streaming copyFile() function that uses the flowing mode API and handles backpressure. This would have been easier to implement with a pipe() call, but it serves here as a useful demonstration of the multiple event handlers that are used to coordinate data flow from one stream to the other. const fs = require(“fs”); // A streaming file copy function, using “flowing mode”. // Copies the contents of the named source file to the named destination file. // On success, invokes the callback with a null argument. On error, // invokes the callback with an Error object. function copyFile(sourceFilename, destinationFilename, callback) { let input = fs.createReadStream(sourceFilename); let output = fs.createWriteStream(destinationFilename); input.on(\"data\", (chunk) =\u003e { // When we get new data, let hasRoom = output.write(chunk); // write it to the output stream. if (!hasRoom) { // If the output stream is full input.pause(); // then pause the input stream. } }); input.on(\"end\", () =\u003e { // When we reach the end of input, output.end(); // tell the output stream to end. }); input.on(\"error\", err =\u003e { // If we get an error on the input, callback(err); // call the callback with the error process.exit(); // and quit. }); output.on(\"drain\", () =\u003e { // When the output is no longer full, input.resume(); // resume data events on the input }); output.on(\"error\", err =\u003e { // If we get an error on the output, callback(err); // call the callback with the error process.exit(); // and quit. }); output.on(\"finish\", () =\u003e { // When output is fully written callback(null); // call the callback with no error. }); } // Here’s a simple command-line utility to copy files let from = process.argv[2], to = process.argv[3]; console.log(Copying file ${from} to ${to}...); copyFile(from, to, err =\u003e { if (err) { console.error(err); } else { console.log(“done.\"); } }); PAUSED MODE The other mode for Readable streams is “paused mode.” This is the mode that streams start in. If you never register a “data” event handler and never call the pipe() method, then a Readable stream remains in paused mode. In paused ","date":"2020-11-02","objectID":"/posts/ch16/:5:4","tags":null,"title":"第 16 章 服务器端 JavaScript","uri":"/posts/ch16/"},{"categories":null,"content":"16.6 Process, CPU, and Operating System Details The global Process object has a number of useful properties and functions that generally relate to the state of the currently running Node process. Consult the Node documentation for complete details, but here are some properties and functions you should be aware of: process.argv // An array of command-line arguments. process.arch // The CPU architecture: “x64”, for example. process.cwd() // Returns the current working directory. process.chdir() // Sets the current working directory. process.cpuUsage() // Reports CPU usage. process.env // An object of environment variables. process.execPath // The absolute filesystem path to the node executable. process.exit() // Terminates the program. process.exitCode // An integer code to be reported when the program exits. process.getuid() // Return the Unix user id of the current user. process.hrtime.bigint() // Return a “high-resolution” nanosecond timestamp. process.kill() // Send a signal to another process. process.memoryUsage() // Return an object with memory usage details. process.nextTick() // Like setImmediate(), invoke a function soon. process.pid // The process id of the current process. process.ppid // The parent process id. process.platform // The OS: “linux”, “darwin”, or “win32”, for example. process.resourceUsage() // Return an object with resource usage details. process.setuid() // Sets the current user, by id or name. process.title // The process name that appears in ps listings. process.umask() // Set or return the default permissions for new files. process.uptime() // Return Node’s uptime in seconds. process.version // Node’s version string. process.versions // Version strings for the libraries Node depends on. The “os” module (which, unlike process, needs to be explicitly loaded with require()) provides access to similarly low-level details about the computer and operating system that Node is running on. You may never need to use any of these features, but it is worth knowing that Node makes them available: const os = require(“os”); os.arch() // Returns CPU architecture. “x64” or “arm”, for example. os.constants // Useful constants such as os.constants.signals.SIGINT. os.cpus() // Data about system CPU cores, including usage times. os.endianness() // The CPU’s native endianness “BE” or “LE”. os.EOL // The OS native line terminator: “\\n” or “\\r\\n”. os.freemem() // Returns the amount of free RAM in bytes. os.getPriority() // Returns the OS scheduling priority of a process. os.homedir() // Returns the current user’s home directory. os.hostname() // Returns the hostname of the computer. os.loadavg() // Returns the 1, 5, and 15-minute load averages. os.networkInterfaces() // Returns details about available network. connections. os.platform() // Returns OS: “linux”, “darwin”, or “win32”, for example. os.release() // Returns the version number of the OS. os.setPriority() // Attempts to set the scheduling priority for a process. os.tmpdir() // Returns the default temporary directory. os.totalmem() // Returns the total amount of RAM in bytes. os.type() // Returns OS: “Linux”, “Darwin”, or “Windows_NT”, e.g. os.uptime() // Returns the system uptime in seconds. os.userInfo() // Returns uid, username, home, and shell of current user. ","date":"2020-11-02","objectID":"/posts/ch16/:6:0","tags":null,"title":"第 16 章 服务器端 JavaScript","uri":"/posts/ch16/"},{"categories":null,"content":"16.7 Working with Files Node’s “fs” module is a comprehensive API for working with files and directories. It is complemented by the “path” module, which defines utility functions for working with file and directory names. The “fs” module contains a handful of high-level functions for easily reading, writing, and copying files. But most of the functions in the module are low-level JavaScript bindings to Unix system calls (and their equivalents on Windows). If you have worked with low-level filesystem calls before (in C or other languages), then the Node API will be familiar to you. If not, you may find parts of the “fs” API to be terse and unintuitive. The function to delete a file, for example, is called unlink(). The “fs” module defines a large API, mainly because there are usually multiple variants of each fundamental operation. As discussed at the beginning of the chapter, most functions such as fs.readFile() are nonblocking, callback-based, and asynchronous. Typically, though, each of these functions has a synchronous blocking variant, such as fs.readFileSync(). In Node 10 and later, many of these functions also have a Promise-based asynchronous variant such as fs.promises.readFile(). Most “fs” functions take a string as their first argument, specifying the path (filename plus optional directory names) to the file that is to be operated on. But a number of these functions also support a variant that takes an integer “file descriptor” as the first argument instead of a path. These variants have names that begin with the letter “f.” For example, fs.truncate() truncates a file specified by path, and fs.ftruncate() truncates a file specified by file descriptor. There is a Promise-based fs.promises.truncate() that expects a path and another Promise-based version that is implemented as a method of a FileHandle object. (The FileHandle class is the equivalent of a file descriptor in the Promise-based API.) Finally, there are a handful of functions in the “fs” module that have variants whose names are prefixed with the letter “l.” These “l” variants are like the base function but do not follow symbolic links in the filesystem and instead operate directly on the symbolic links themselves. ","date":"2020-11-02","objectID":"/posts/ch16/:7:0","tags":null,"title":"第 16 章 服务器端 JavaScript","uri":"/posts/ch16/"},{"categories":null,"content":"16.7.1 Paths, File Descriptors, and FileHandles In order to use the “fs” module to work with files, you first need to be able to name the file you want to work with. Files are most often specified by path, which means the name of the file itself, plus the hierarchy of directories in which the file appears. If a path is absolute, it means that directories all the way up to the filesystem root are specified. Otherwise, the path is relative and is only meaningful in relation to some other path, usually the current working directory. Working with paths can be a little tricky because different operating systems use different characters to separate directory names, it is easy to accidentally double those separator characters when concatenating paths, and because ../ parent directory path segments need special handling. Node’s “path” module and a couple of other important Node features help: // Some important paths process.cwd() // Absolute path of the current working directory. __filename // Absolute path of the file that holds the current code. __dirname // Absolute path of the directory that holds __filename. os.homedir() // The user’s home directory. const path = require(“path”); path.sep // Either “/” or “\" depending on your OS // The path module has simple parsing functions let p = “src/pkg/test.js”; // An example path path.basename(p) // =\u003e “test.js” path.extname(p) // =\u003e “.js” path.dirname(p) // =\u003e “src/pkg” path.basename(path.dirname(p)) // =\u003e “pkg” path.dirname(path.dirname(p)) // =\u003e “src” // normalize() cleans up paths: path.normalize(“a/b/c/../d/\") // =\u003e “a/b/d/\": handles ../ segments path.normalize(“a/./b”) // =\u003e “a/b”: strips “./” segments path.normalize(\"//a//b//\") // =\u003e “/a/b/\": removes duplicate / // join() combines path segments, adding separators, then normalizes path.join(“src”, “pkg”, “t.js”) // =\u003e “src/pkg/t.js” // resolve() takes one or more path segments and returns an absolute // path. It starts with the last argument and works backward, stopping // when it has built an absolute path or resolving against process.cwd(). path.resolve() // =\u003e process.cwd() path.resolve(“t.js”) // =\u003e path.join(process.cwd(), “t.js”) path.resolve(\"/tmp”, “t.js”) // =\u003e “/tmp/t.js” path.resolve(\"/a”, “/b”, “t.js”) // =\u003e “/b/t.js” Note that path.normalize() is simply a string manipulation function that has no access to the actual filesystem. The fs.realpath() and fs.realpathSync() functions perform filesystem-aware canonicalization: they resolve symbolic links and interpret relative pathnames relative to the current working directory. In the previous examples, we assumed that the code is running on a Unix-based OS and path.sep is “/.” If you want to work with Unix-style paths even when on a Windows system, then use path.posix instead of path. And conversely, if you want to work with Windows paths even when on a Unix system, path.win32. path.posix and path.win32 define the same properties and functions as path itself. Some of the “fs” functions we’ll be covering in the next sections expect a file descriptor instead of a file name. File descriptors are integers used as OS-level references to “open” files. You obtain a descriptor for a given name by calling the fs.open() (or fs.openSync()) function. Processes are only allowed to have a limited number of files open at one time, so it is important that you call fs.close() on your file descriptors when you are done with them. You need to open files if you want to use the lowest-level fs.read() and fs.write() functions that allow you to jump around within a file, reading and writing bits of it at different times. There are other functions in the “fs” module that use file descriptors, but they all have name-based versions, and it only really makes sense to use the descriptor-based functions if you were going to open the file to read or write anyway. Finally, in the Promise-based API defined by fs.promises, the equivalent of fs.open() is fs.promises.open(), which returns a Promise that resolv","date":"2020-11-02","objectID":"/posts/ch16/:7:1","tags":null,"title":"第 16 章 服务器端 JavaScript","uri":"/posts/ch16/"},{"categories":null,"content":"16.7.2 Reading Files Node allows you to read file content all at once, via a stream, or with the low-level API. If your files are small, or if memory usage and performance are not the highest priority, then it is often easiest to read the entire content of a file with a single call. You can do this synchronously, with a callback, or with a Promise. By default, you’ll get the bytes of the file as a buffer, but if you specify an encoding, you’ll get a decoded string instead. const fs = require(“fs”); let buffer = fs.readFileSync(“test.data”); // Synchronous, returns buffer let text = fs.readFileSync(“data.csv”, “utf8”); // Synchronous, returns string // Read the bytes of the file asynchronously fs.readFile(“test.data”, (err, buffer) =\u003e { if (err) { // Handle the error here } else { // The bytes of the file are in buffer } }); // Promise-based asynchronous read fs.promises .readFile(“data.csv”, “utf8”) .then(processFileText) .catch(handleReadError); // Or use the Promise API with await inside an async function async function processText(filename, encoding=“utf8”) { let text = await fs.promises.readFile(filename, encoding); // … process the text here… } If you are able to process the contents of a file sequentially and do not need to have the entire content of the file in memory at the same time, then reading a file via a stream may be the most efficient approach. We’ve covered streams extensively: here is how you might use a stream and the pipe() method to write the contents of a file to standard output: function printFile(filename, encoding=“utf8”) { fs.createReadStream(filename, encoding).pipe(process.stdout); } Finally, if you need low-level control over exactly what bytes you read from a file and when you read them, you can open a file to get a file descriptor and then use fs.read(), fs.readSync(), or fs.promises.read() to read a specified number of bytes from a specified source location of the file into a specified buffer at the specified destination position: const fs = require(“fs”); // Reading a specific portion of a data file fs.open(“data”, (err, fd) =\u003e { if (err) { // Report error somehow return; } try { // Read bytes 20 through 420 into a newly allocated buffer. fs.read(fd, Buffer.alloc(400), 0, 400, 20, (err, n, b) =\u003e { // err is the error, if any. // n is the number of bytes actually read // b is the buffer that they bytes were read into. }); } finally { // Use a finally clause so we always fs.close(fd); // close the open file descriptor } }); The callback-based read() API is awkward to use if you need to read more than one chunk of data from a file. If you can use the synchronous API (or the Promise-based API with await), it becomes easy to read multiple chunks from a file: const fs = require(“fs”); function readData(filename) { let fd = fs.openSync(filename); try { // Read the file header let header = Buffer.alloc(12); // A 12 byte buffer fs.readSync(fd, header, 0, 12, 0); // Verify the file's magic number let magic = header.readInt32LE(0); if (magic !== 0xDADAFEED) { throw new Error(\"File is of wrong type\"); } // Now get the offset and length of the data from the header let offset = header.readInt32LE(4); let length = header.readInt32LE(8); // And read those bytes from the file let data = Buffer.alloc(length); fs.readSync(fd, data, 0, length, offset); return data; } finally { // Always close the file, even if an exception is thrown above fs.closeSync(fd); } } ","date":"2020-11-02","objectID":"/posts/ch16/:7:2","tags":null,"title":"第 16 章 服务器端 JavaScript","uri":"/posts/ch16/"},{"categories":null,"content":"16.7.3 Writing Files Writing files in Node is a lot like reading them, with a few extra details that you need to know about. One of these details is that the way you create a new file is simply by writing to a filename that does not already exist. As with reading, there are three basic ways to write files in Node. If you have the entire content of the file in a string or a buffer, you can write the entire thing in one call with fs.writeFile() (callback-based), fs.writeFileSync() (synchronous), or fs.promises.writeFile() (Promise-based): fs.writeFileSync(path.resolve(__dirname, “settings.json”), JSON.stringify(settings)); If the data you are writing to the file is a string, and you want to use an encoding other than “utf8,” pass the encoding as an optional third argument. The related functions fs.appendFile(), fs.appendFileSync(), and fs.promises.appendFile() are similar, but when the specified file already exists, they append their data to the end rather than overwriting the existing file content. If the data you want to write to a file is not all in one chunk, or if it is not all in memory at the same time, then using a Writable stream is a good approach, assuming that you plan to write the data from beginning to end without skipping around in the file: const fs = require(“fs”); let output = fs.createWriteStream(“numbers.txt”); for(let i = 0; i \u003c 100; i++) { output.write(${i}\\n); } output.end(); Finally, if you want to write data to a file in multiple chunks, and you want to be able to control the exact position within the file at which each chunk is written, then you can open the file with fs.open(), fs.openSync(), or fs.promises.open() and then use the resulting file descriptor with the fs.write() or fs.writeSync() functions. These functions come in different forms for strings and buffers. The string variant takes a file descriptor, a string, and the file position at which to write that string (with an encoding as an optional fourth argument). The buffer variant takes a file descriptor, a buffer, an offset, and a length that specify a chunk of data within the buffer, and a file position at which to write the bytes of that chunk. And if you have an array of Buffer objects that you want to write, you can do this with a single fs.writev() or fs.writevSync(). Similar low-level functions exist for writing buffers and strings using fs.promises.open() and the FileHandle object it produces. FILE MODE STRINGS We saw the fs.open() and fs.openSync() methods before when using the low-level API to read files. In that use case, it was sufficient to just pass the filename to the open function. When you want to write a file, however, you must also specify a second string argument that specifies how you intend to use the file descriptor. Some of the available flag strings are as follows: “w” Open the file for writing “w+” Open for writing and reading “wx” Open for creating a new file; fails if the named file already exists “wx+” Open for creation, and also allow reading; fails if the named file already exists “a” Open the file for appending; existing content won’t be overwritten “a+” Open for appending, but also allow reading If you do not pass one of these flag strings to fs.open() or fs.openSync(), they use the default “r” flag, making the file descriptor read-only. Note that it can also be useful to pass these flags to other file-writing methods: // Write to a file in one call, but append to anything that is already there. // This works like fs.appendFileSync() fs.writeFileSync(“messages.log”, “hello”, { flag: “a” }); // Open a write stream, but throw an error if the file already exists. // We don’t want to accidentally overwrite something! // Note that the option above is “flag” and is “flags” here fs.createWriteStream(“messages.log”, { flags: “wx” }); You can chop off the end of a file with fs.truncate(), fs.truncateSync(), or fs.promises.truncate(). These functions take a path as their first argument and a length as their second, and ","date":"2020-11-02","objectID":"/posts/ch16/:7:3","tags":null,"title":"第 16 章 服务器端 JavaScript","uri":"/posts/ch16/"},{"categories":null,"content":"16.7.4 File Operations The preceding discussion of Node’s stream classes included two examples of copyFile() functions. These are not practical utilities that you would actually use because the “fs” module defines its own fs.copyFile() method (and also fs.copyFileSync() and fs.promises.copyFile(), of course). These functions take the name of the original file and the name of the copy as their first two arguments. These can be specified as strings or as URL or Buffer objects. An optional third argument is an integer whose bits specify flags that control details of the copy operation. And for the callback-based fs.copyFile(), the final argument is a callback function that will be called with no arguments when the copy is complete, or that will be called with an error argument if something fails. Following are some examples: // Basic synchronous file copy. fs.copyFileSync(“ch15.txt”, “ch15.bak”); // The COPYFILE_EXCL argument copies only if the new file does not already // exist. It prevents copies from overwriting existing files. fs.copyFile(“ch15.txt”, “ch16.txt”, fs.constants.COPYFILE_EXCL, err =\u003e { // This callback will be called when done. On error, err will be non-null. }); // This code demonstrates the Promise-based version of the copyFile function. // Two flags are combined with the bitwise OR opeartor |. The flags mean that // existing files won’t be overwritten, and that if the filesystem supports // it, the copy will be a copy-on-write clone of the original file, meaning // that no additional storage space will be required until either the original // or the copy is modified. fs.promises.copyFile(“Important data”, `Important data ${new Date().toISOString()}” fs.constants.COPYFILE_EXCL | fs.constants.COPYFILE_FICLONE) .then(() =\u003e { console.log(“Backup complete”); }); .catch(err =\u003e { console.error(“Backup failed”, err); }); The fs.rename() function (along with the usual synchronous and Promise-based variants) moves and/or renames a file. Call it with the current path to the file and the desired new path to the file. There is no flags argument, but the callback-based version takes a callback as the third argument: fs.renameSync(“ch15.bak”, “backups/ch15.bak”); Note that there is no flag to prevent renaming from overwriting an existing file. Also keep in mind that files can only be renamed within a filesystem. The functions fs.link() and fs.symlink() and their variants have the same signatures as fs.rename() and behave something like fs.copyFile() except that they create hard links and symbolic links, respectively, rather than creating a copy. Finally, fs.unlink(), fs.unlinkSync(), and fs.promises.unlink() are Node’s functions for deleting a file. (The unintuitive naming is inherited from Unix where deleting a file is basically the opposite of creating a hard link to it.) Call this function with the string, buffer, or URL path to the file to be deleted, and pass a callback if you are using the callback-based version: fs.unlinkSync(“backups/ch15.bak”); ","date":"2020-11-02","objectID":"/posts/ch16/:7:4","tags":null,"title":"第 16 章 服务器端 JavaScript","uri":"/posts/ch16/"},{"categories":null,"content":"16.7.5 File Metadata The fs.stat(), fs.statSync(), and fs.promises.stat() functions allow you to obtain metadata for a specified file or directory. For example: const fs = require(“fs”); let stats = fs.statSync(“book/ch15.md”); stats.isFile() // =\u003e true: this is an ordinary file stats.isDirectory() // =\u003e false: it is not a directory stats.size // file size in bytes stats.atime // access time: Date when it was last read stats.mtime // modification time: Date when it was last written stats.uid // the user id of the file’s owner stats.gid // the group id of the file’s owner stats.mode.toString(8) // the file’s permissions, as an octal string The returned Stats object contains other, more obscure properties and methods, but this code demonstrates those that you are most likely to use. fs.lstat() and its variants work just like fs.stat(), except that if the specified file is a symbolic link, Node will return metadata for the link itself rather than following the link. If you have opened a file to produce a file descriptor or a FileHandle object, then you can use fs.fstat() or its variants to get metadata information for the opened file without having to specify the filename again. In addition to querying metadata with fs.stat() and all of its variants, there are also functions for changing metadata. fs.chmod(), fs.lchmod(), and fs.fchmod() (along with synchronous and Promise-based versions) set the “mode” or permissions of a file or directory. Mode values are integers in which each bit has a specific meaning and are easiest to think about in octal notation. For example, to make a file read-only to its owner and inaccessible to everyone else, use 0o400: fs.chmodSync(“ch15.md”, 0o400); // Don’t delete it accidentally! fs.chown(), fs.lchown(), and fs.fchown() (along with synchronous and Promise-based versions) set the owner and group (as IDs) for a file or directory. (These matter because they interact with the file permissions set by fs.chmod().) Finally, you can set the access time and modification time of a file or directory with fs.utimes() and fs.futimes() and their variants. ","date":"2020-11-02","objectID":"/posts/ch16/:7:5","tags":null,"title":"第 16 章 服务器端 JavaScript","uri":"/posts/ch16/"},{"categories":null,"content":"16.7.6 Working with Directories To create a new directory in Node, use fs.mkdir(), fs.mkdirSync(), or fs.promises.mkdir(). The first argument is the path of the directory to be created. The optional second argument can be an integer that specifies the mode (permissions bits) for the new directory. Or you can pass an object with optional mode and recursive properties. If recursive is true, then this function will create any directories in the path that do not already exist: // Ensure that dist/ and dist/lib/ both exist. fs.mkdirSync(“dist/lib”, { recursive: true }); fs.mkdtemp() and its variants take a path prefix you provide, append some random characters to it (this is important for security), create a directory with that name, and return (or pass to a callback) the directory path to you. To delete a directory, use fs.rmdir() or one of its variants. Note that directories must be empty before they can be deleted: // Create a random temporary directory and get its path, then // delete it when we are done let tempDirPath; try { tempDirPath = fs.mkdtempSync(path.join(os.tmpdir(), “d”)); // Do something with the directory here } finally { // Delete the temporary directory when we’re done with it fs.rmdirSync(tempDirPath); } The “fs” module provides two distinct APIs for listing the contents of a directory. First, fs.readdir(), fs.readdirSync(), and fs.promises.readdir() read the entire directory all at once and give you an array of strings or an array of Dirent objects that specify the names and types (file or directory) of each item. Filenames returned by these functions are just the local name of the file, not the entire path. Here are examples: let tempFiles = fs.readdirSync(\"/tmp”); // returns an array of strings // Use the Promise-based API to get a Dirent array, and then // print the paths of subdirectories fs.promises.readdir(\"/tmp”, {withFileTypes: true}) .then(entries =\u003e { entries.filter(entry =\u003e entry.isDirectory()) .map(entry =\u003e entry.name) .forEach(name =\u003e console.log(path.join(\"/tmp/”, name))); }) .catch(console.error); If you anticipate needing to list directories that might have thousands of entries, you might prefer the streaming approach of fs.opendir() and its variants. These functions return a Dir object representing the specified directory. You can use the read() or readSync() methods of the Dir object to read one Dirent at a time. If you pass a callback function to read(), it will call the callback. And if you omit the callback argument, it will return a Promise. When there are no more directory entries, you’ll get null instead of a Dirent object. The easiest way to use Dir objects is as async iterators with a for/await loop. Here, for example, is a function that uses the streaming API to list directory entries, calls stat() on each entry, and prints file and directory names and sizes: const fs = require(“fs”); const path = require(“path”); async function listDirectory(dirpath) { let dir = await fs.promises.opendir(dirpath); for await (let entry of dir) { let name = entry.name; if (entry.isDirectory()) { name += “/\"; // Add a trailing slash to subdirectories } let stats = await fs.promises.stat(path.join(dirpath, name)); let size = stats.size; console.log(String(size).padStart(10), name); } } ","date":"2020-11-02","objectID":"/posts/ch16/:7:6","tags":null,"title":"第 16 章 服务器端 JavaScript","uri":"/posts/ch16/"},{"categories":null,"content":"16.8 HTTP Clients and Servers Node’s “http,” “https,” and “http2” modules are full-featured but relatively low-level implementations of the HTTP protocols. They define comprehensive APIs for implementing HTTP clients and servers. Because the APIs are relatively low-level, there is not room in this chapter to cover all the features. But the examples that follow demonstrate how to write basic clients and servers. The simplest way to make a basic HTTP GET request is with http.get() or https.get(). The first argument to these functions is the URL to fetch. (If it is an http:// URL, you must use the “http” module, and if it is an https:// URL you must use the “https” module.) The second argument is a callback that will be invoked with an IncomingMessage object when the server’s response has started to arrive. When the callback is called, the HTTP status and headers are available, but the body may not be ready yet. The IncomingMessage object is a Readable stream, and you can use the techniques demonstrated earlier in this chapter to read the response body from it. The getJSON() function at the end of §13.2.6 used the http.get() function as part of a demonstration of the Promise() constructor. Now that you know about Node streams and the Node programming model more generally, it is worth revisiting that example to see how http.get() is used. http.get() and https.get() are slightly simplified variants of the more general http.request() and https.request() functions. The following postJSON() function demonstrates how to use https.request() to make an HTTPS POST request that includes a JSON request body. Like the getJSON() function of Chapter 13, it expects a JSON response and returns a Promise that fulfills to the parsed version of that response: const https = require(“https”); /* Convert the body object to a JSON string then HTTPS POST it to the specified API endpoint on the specified host. When the response arrives, parse the response body as JSON and resolve the returned Promise with that parsed value. */ function postJSON(host, endpoint, body, port, username, password) { // Return a Promise object immediately, then call resolve or reject // when the HTTPS request succeeds or fails. return new Promise((resolve, reject) =\u003e { // Convert the body object to a string let bodyText = JSON.stringify(body); // Configure the HTTPS request let requestOptions = { method: \"POST\", // Or \"GET\", \"PUT\", \"DELETE\", etc. host: host, // The host to connect to path: endpoint, // The URL path headers: { // HTTP headers for the request \"Content-Type\": \"application/json\", \"Content-Length\": Buffer.byteLength(bodyText) } }; if (port) { // If a port is specified, requestOptions.port = port; // use it for the request. } // If credentials are specified, add an Authorization header. if (username \u0026\u0026 password) { requestOptions.auth = `${username}:${password}`; } // Now create the request based on the configuration object let request = https.request(requestOptions); // Write the body of the POST request and end the request. request.write(bodyText); request.end(); // Fail on request errors (such as no network connection) request.on(\"error\", e =\u003e reject(e)); // Handle the response when it starts to arrive. request.on(\"response\", response =\u003e { if (response.statusCode !== 200) { reject(new Error(`HTTP status ${response.statusCode}`)); // We don't care about the response body in this case, but // we don't want it to stick around in a buffer somewhere, so // we put the stream into flowing mode without registering // a \"data\" handler so that the body is discarded. response.resume(); return; } // We want text, not bytes. We're assuming the text will be // JSON-formatted but aren't bothering to check the // Content-Type header. response.setEncoding(\"utf8\"); // Node doesn't have a streaming JSON parser, so we read the // entire response body into a string. let body = \"\"; response.on(\"data\", chunk =\u003e { body += chunk; }); // And now handle the response when it is complete. resp","date":"2020-11-02","objectID":"/posts/ch16/:8:0","tags":null,"title":"第 16 章 服务器端 JavaScript","uri":"/posts/ch16/"},{"categories":null,"content":"16.9 Non-HTTP Network Servers and Clients Web servers and clients have become so ubiquitous that it is easy to forget that it is possible to write clients and servers that do not use HTTP. Even though Node has a reputation as a good environment for writing web servers, Node also has full support for writing other types of network servers and clients. If you are comfortable working with streams, then networking is relatively simple, because network sockets are simply a kind of Duplex stream. The “net” module defines Server and Socket classes. To create a server, call net.createServer(), then call the listen() method of the resulting object to tell the server what port to listen on for connections. The Server object will generate “connection” events when a client connects on that port, and the value passed to the event listener will be a Socket object. The Socket object is a Duplex stream, and you can use it to read data from the client and write data to the client. Call end() on the Socket to disconnect. Writing a client is even easier: pass a port number and hostname to net.createConnection() to create a socket to communicate with whatever server is running on that host and listening on that port. Then use that socket to read and write data from and to the server. The following code demonstrates how to write a server with the “net” module. When the client connects, the server tells a knock-knock joke: // A TCP server that delivers interactive knock-knock jokes on port 6789. // (Why is six afraid of seven? Because seven ate nine!) const net = require(“net”); const readline = require(“readline”); // Create a Server object and start listening for connections let server = net.createServer(); server.listen(6789, () =\u003e console.log(“Delivering laughs on port 6789”)); // When a client connects, tell them a knock-knock joke. server.on(“connection”, socket =\u003e { tellJoke(socket) .then(() =\u003e socket.end()) // When the joke is done, close the socket. .catch((err) =\u003e { console.error(err); // Log any errors that occur, socket.end(); // but still close the socket! }); }); // These are all the jokes we know. const jokes = { “Boo”: “Don’t cry…it’s only a joke!”, “Lettuce”: “Let us in! It’s freezing out here!”, “A little old lady”: “Wow, I didn’t know you could yodel!” }; // Interactively perform a knock-knock joke over this socket, without blocking. async function tellJoke(socket) { // Pick one of the jokes at random let randomElement = a =\u003e a[Math.floor(Math.random() * a.length)]; let who = randomElement(Object.keys(jokes)); let punchline = jokes[who]; // Use the readline module to read the user's input one line at a time. let lineReader = readline.createInterface({ input: socket, output: socket, prompt: \"\u003e\u003e \" }); // A utility function to output a line of text to the client // and then (by default) display a prompt. function output(text, prompt=true) { socket.write(`${text}\\r\\n`); if (prompt) lineReader.prompt(); } // Knock-knock jokes have a call-and-response structure. // We expect different input from the user at different stages and // take different action when we get that input at different stages. let stage = 0; // Start the knock-knock joke off in the traditional way. output(\"Knock knock!\"); // Now read lines asynchronously from the client until the joke is done. for await (let inputLine of lineReader) { if (stage === 0) { if (inputLine.toLowerCase() === \"who's there?\") { // If the user gives the right response at stage 0 // then tell the first part of the joke and go to stage 1. output(who); stage = 1; } else { // Otherwise teach the user how to do knock-knock jokes. output('Please type \"Who\\'s there?\".'); } } else if (stage === 1) { if (inputLine.toLowerCase() === `${who.toLowerCase()} who?`) { // If the user's response is correct at stage 1, then // deliver the punchline and return since the joke is done. output(`${punchline}`, false); return; } else { // Make the user play along. output(`Please type \"${who} who?\".`); } } } } Simple ","date":"2020-11-02","objectID":"/posts/ch16/:9:0","tags":null,"title":"第 16 章 服务器端 JavaScript","uri":"/posts/ch16/"},{"categories":null,"content":"16.10 Working with Child Processes In addition to writing highly concurrent servers, Node also works well for writing scripts that execute other programs. In Node the “child_process” module defines a number of functions for running other programs as child processes. This section demonstrates some of those functions, starting with the simplest and moving to the more complicated. ","date":"2020-11-02","objectID":"/posts/ch16/:10:0","tags":null,"title":"第 16 章 服务器端 JavaScript","uri":"/posts/ch16/"},{"categories":null,"content":"16.10.1 execSync() and execFileSync() The easiest way to run another program is with child_process.execSync(). This function takes the command to run as its first argument. It creates a child process, runs a shell in that process, and uses the shell to execute the command you passed. Then it blocks until the command (and the shell) exit. If the command exits with an error, then execSync() throws an exception. Otherwise, execSync() returns whatever output the command writes to its stdout stream. By default this return value is a buffer, but you can specify an encoding in an optional second argument to get a string instead. If the command writes any output to stderr, that output just gets passed through to the parent process’s stderr stream. So, for example, if you are writing a script and performance is not a concern, you might use child_process.execSync() to list a directory with a familiar Unix shell command rather than using the fs.readdirSync() function: const child_process = require(“child_process”); let listing = child_process.execSync(“ls -l web/*.html”, {encoding: “utf8”}); The fact that execSync() invokes a full Unix shell means that the string you pass to it can include multiple semicolon-separated commands, and can take advantage of shell features such as filename wildcards, pipes, and output redirection. This also means that you must be careful to never pass a command to execSync() if any portion of that command is user input or comes from a similar untrusted source. The complex syntax of shell commands can be easily subverted to allow an attacker to run arbitrary code. If you don’t need the features of a shell, you can avoid the overhead of starting a shell by using child_process.execFileSync(). This function executes a program directly, without invoking a shell. But since no shell is involved, it can’t parse a command line, and you must pass the executable as the first argument and an array of command-line arguments as the second argument: let listing = child_process.execFileSync(“ls”, [\"-l”, “web/\"], {encoding: “utf8”}); CHILD PROCESS OPTIONS execSync() and many of the other child_process functions have a second or third optional argument that specifies additional details about how the child process is to run. The encoding property of this object was used earlier to specify that we’d like the command output to be delivered as a string rather than as a buffer. Other important properties that you can specify include the following (note that not all options are available to all child process functions): cwd specifies the working directory for the child process. If you omit this, then the child process inherits the value of process.cwd(). env specifies the environment variables that the child process will have access to. By default, child processes simply inherit process.env, but you can specify a different object if you want. input specifies a string or buffer of input data that should be used as the standard input to the child process. This option is only available to the synchronous functions that do not return a ChildProcess object. maxBuffer specifies the maximum number of bytes of output that will be collected by the exec functions. (It does not apply to spawn() and fork(), which use streams.) If a child process produces more output than this, it will be killed and will exit with an error. shell specifies the path to a shell executable or true. For child process functions that normally execute a shell command, this option allows you to specify which shell to use. For functions that do not normally use a shell, this option allows you to specify that a shell should be used (by setting the property to true) or to specify exactly which shell to use. timeout specifies the maximum number of milliseconds that the child process should be allowed to run. If it has not exited before this time elapses, it will be killed and will exit with an error. (This option applies to the exec functions but not to spawn() or fork().) ","date":"2020-11-02","objectID":"/posts/ch16/:10:1","tags":null,"title":"第 16 章 服务器端 JavaScript","uri":"/posts/ch16/"},{"categories":null,"content":"16.10.2 exec() and execFile() The execSync() and execFileSync() functions are, as their names indicate, synchronous: they block and do not return until the child process exits. Using these functions is a lot like typing Unix commands in a terminal window: they allow you to run a sequence of commands one at a time. But if you’re writing a program that needs to accomplish a number of tasks, and those tasks don’t depend on each other in any way, then you may want to parallelize them and run multiple commands at the same time. You can do this with the asynchronous functions child_process.exec() and child_process.execFile(). exec() and execFile() are like their synchronous variants except that they return immediately with a ChildProcess object that represents the running child process, and they take an error-first callback as their final argument. The callback is invoked when the child process exits, and it is actually called with three arguments. The first is the error, if any; it will be null if the process terminated normally. The second argument is the collected output that was sent to the child’s standard output stream. And the third argument is any output that was sent to the child’s standard error stream. The ChildProcess object returned by exec() and execFile() allows you to terminate the child process, and to write data to it (which it can then read from its standard input). We’ll cover ChildProcess in more detail when we discuss the child_process.spawn() function. If you plan to execute multiple child processes at the same time, then it may be easiest to use the “promisified” version of exec() which returns a Promise object which, if the child process exits without error, resolves to an object with stdout and stderr properties. Here, for example, is a function that takes an array of shell commands as its input and returns a Promise that resolves to the result of all of those commands: const child_process = require(“child_process”); const util = require(“util”); const execP = util.promisify(child_process.exec); function parallelExec(commands) { // Use the array of commands to create an array of Promises let promises = commands.map(command =\u003e execP(command, {encoding: “utf8”})); // Return a Promise that will fulfill to an array of the fulfillment // values of each of the individual promises. (Instead of returning objects // with stdout and stderr properties we just return the stdout value.) return Promise.all(promises) .then(outputs =\u003e outputs.map(out =\u003e out.stdout)); } module.exports = parallelExec; ","date":"2020-11-02","objectID":"/posts/ch16/:10:2","tags":null,"title":"第 16 章 服务器端 JavaScript","uri":"/posts/ch16/"},{"categories":null,"content":"16.10.3 spawn() The various exec functions described so far—both synchronous and asynchronous—are designed to be used with child processes that run quickly and do not produce a lot of output. Even the asynchronous exec() and execFile() are nonstreaming: they return the process output in a single batch, only after the process has exited. The child_process.spawn() function allows you streaming access to the output of the child process, while the process is still running. It also allows you to write data to the child process (which will see that data as input on its standard input stream): this means it is possible to dynamically interact with a child process, sending it input based on the output it generates. spawn() does not use a shell by default, so you must invoke it like execFile() with the executable to be run and a separate array of command-line arguments to pass to it. spawn() returns a ChildProcess object like execFile() does, but it does not take a callback argument. Instead of using a callback function, you listen to events on the ChildProcess object and on its streams. The ChildProcess object returned by spawn() is an event emitter. You can listen for the “exit” event to be notified when the child process exits. A ChildProcess object also has three stream properties. stdout and stderr are Readable streams: when the child process writes to its stdout and its stderr streams, that output becomes readable through the ChildProcess streams. Note the inversion of the names here. In the child process, “stdout” is a Writable output stream, but in the parent process, the stdout property of a ChildProcess object is a Readable input stream. Similarly, the stdin property of the ChildProcess object is a Writeable stream: anything you write to this stream becomes available to the child process on its standard input. The ChildProcess object also defines a pid property that specifies the process id of the child. And it defines a kill() method that you can use to terminate a child process. ","date":"2020-11-02","objectID":"/posts/ch16/:10:3","tags":null,"title":"第 16 章 服务器端 JavaScript","uri":"/posts/ch16/"},{"categories":null,"content":"16.10.4 fork() child_process.fork() is a specialized function for running a module of JavaScript code in a child Node process. fork() expects the same arguments as spawn(), but the first argument should specify the path to a file of JavaScript code instead of an executable binary file. A child process created with fork() can communicate with the parent process via its standard input and standard output streams, as described in the previous section for spawn(). But in addition, fork() enables another, much easier, communication channel between the parent and child processes. When you create a child process with fork(), you can use the send() method of the returned ChildProcess object to send a copy of an object to the child process. And you can listen for the “message” event on the ChildProcess to receive messages from the child. The code running in the child process can use process.send() to send a message to the parent and can listen for “message” events on process to receive messages from the parent. Here, for example, is some code that uses fork() to create a child process, then sends that child a message and waits for a response: const child_process = require(“child_process”); // Start a new node process running the code in child.js in our directory let child = child_process.fork(${__dirname}/child.js); // Send a message to the child child.send({x: 4, y: 3}); // Print the child’s response when it arrives. child.on(“message”, message =\u003e { console.log(message.hypotenuse); // This should print “5” // Since we only send one message we only expect one response. // After we receive it we call disconnect() to terminate the connection // between parent and child. This allows both processes to exit cleanly. child.disconnect(); }); And here is the code that runs in the child process: // Wait for messages from our parent process process.on(“message”, message =\u003e { // When we receive one, do a calculation and send the result // back to the parent. process.send({hypotenuse: Math.hypot(message.x, message.y)}); }); Starting child processes is an expensive operation, and the child process would have to be doing orders of magnitude more computation before it would make sense to use fork() and interprocess communication in this way. If you are writing a program that needs to be very responsive to incoming events and also needs to perform time-consuming computations, then you might consider using a separate child process to perform the computations so that they don’t block the event loop and reduce the responsiveness of the parent process. (Though a thread—see §16.11—may be a better choice than a child process in this scenario.) The first argument to send() will be serialized with JSON.stringify() and deserialized in the child process with JSON.parse(), so you should only include values that are supported by the JSON format. send() has a special second argument, however, that allows you to transfer Socket and Server objects (from the “net” module) to a child process. Network servers tend to be IO-bound rather than compute-bound, but if you have written a server that needs to do more computation than a single CPU can handle, and if you’re running that server on a machine with multiple CPUs, then you could use fork() to create multiple child processes for handling requests. In the parent process, you might listen for “connection” events on your Server object, then get the Socket object from that “connection” event and send() it—using the special second argument—to one of the child processes to be handled. (Note that this is an unlikely solution to an uncommon scenario. Rather than writing a server that forks child processes, it is probably simpler to keep your server single-threaded and deploy multiple instances of it in production to handle the load.) ","date":"2020-11-02","objectID":"/posts/ch16/:10:4","tags":null,"title":"第 16 章 服务器端 JavaScript","uri":"/posts/ch16/"},{"categories":null,"content":"16.11 Worker Threads As explained at the beginning of this chapter, Node’s concurrency model is single-threaded and event-based. But in version 10 and later, Node does allow true multithreaded programming, with an API that closely mirrors the Web Workers API defined by web browsers (§15.13). Multithreaded programming has a well-deserved reputation for being difficult. This is almost entirely because of the need to carefully synchronize access by threads to shared memory. But JavaScript threads (in both Node and browsers) do not share memory by default, so the dangers and difficulties of using threads do not apply to these “workers” in JavaScript. Instead of using shared memory, JavaScript’s worker threads communicate by message passing. The main thread can send a message to a worker thread by calling the postMessage() method of the Worker object that represents that thread. The worker thread can receive messages from its parent by listening for “message” events. And workers can send messages to the main thread with their own version of postMessage(), which the parent can receive with its own “message” event handler. The example code will make it clear how this works. There are three reasons why you might want to use worker threads in a Node application: If your application actually needs to do more computation than one CPU core can handle, then threads allow you to distribute work across the multiple cores, which have become commonplace on computers today. If you’re doing scientific computing or machine learning or graphics processing in Node, then you may want to use threads simply to throw more computing power at your problem. Even if your application is not using the full power of one CPU, you may still want to use threads to maintain the responsiveness of the main thread. Consider a server that handles large but relatively infrequent requests. Suppose it gets only one request a second, but needs to spend about half a second of (blocking CPU-bound) computation to process each request. On average, it will be idle 50% of the time. But when two requests arrive within a few milliseconds of each other, the server will not even be able to begin a response to the second request until the computation of the first response is complete. Instead, if the server uses a worker thread to perform the computation, the server can begin the response to both requests immediately and provide a better experience for the server’s clients. Assuming the server has more than one CPU core, it can also compute the body of both responses in parallel, but even if there is only a single core, using workers still improves the responsiveness. In general, workers allow us to turn blocking synchronous operations into nonblocking asynchronous operations. If you are writing a program that depends on legacy code that is unavoidably synchronous, you may be able to use workers to avoid blocking when you need to call that legacy code. Worker threads are not nearly as heavyweight as child processes, but they are not lightweight. It does not generally make sense to create a worker unless you have significant work for it to do. And, generally speaking, if your program is not CPU-bound and is not having responsiveness problems, then you probably do not need worker threads. ","date":"2020-11-02","objectID":"/posts/ch16/:11:0","tags":null,"title":"第 16 章 服务器端 JavaScript","uri":"/posts/ch16/"},{"categories":null,"content":"16.11.1 Creating Workers and Passing Messages The Node module that defines workers is known as “worker_threads.” In this section we’ll refer to it with the identifier threads: const threads = require(“worker_threads”); This module defines a Worker class to represent a worker thread, and you can create a new thread with the threads.Worker() constructor. The following code demonstrates using this constructor to create a worker, and shows how to pass messages from main thread to worker and from worker to main thread. It also demonstrates a trick that allows you to put the main thread code and the worker thread code in the same file.2 const threads = require(“worker_threads”); // The worker_threads module exports the boolean isMainThread property. // This property is true when Node is running the main thread and it is // false when Node is running a worker. We can use this fact to implement // the main and worker threads in the same file. if (threads.isMainThread) { // If we’re running in the main thread, then all we do is export // a function. Instead of performing a computationally intensive // task on the main thread, this function passes the task to a worker // and returns a Promise that will resolve when the worker is done. module.exports = function reticulateSplines(splines) { return new Promise((resolve,reject) =\u003e { // Create a worker that loads and runs this same file of code. // Note the use of the special __filename variable. let reticulator = new threads.Worker(__filename); // Pass a copy of the splines array to the worker reticulator.postMessage(splines); // And then resolve or reject the Promise when we get // a message or error from the worker. reticulator.on(\"message\", resolve); reticulator.on(\"error\", reject); }); }; } else { // If we get here, it means we’re in the worker, so we register a // handler to get messages from the main thread. This worker is designed // to only receive a single message, so we register the event handler // with once() instead of on(). This allows the worker to exit naturally // when its work is complete. threads.parentPort.once(“message”, splines =\u003e { // When we get the splines from the parent thread, loop // through them and reticulate all of them. for(let spline of splines) { // For the sake of example, assume that spline objects usually // have a reticulate() method that does a lot of computation. spline.reticulate ? spline.reticulate() : spline.reticulated = true; } // When all the splines have (finally!) been reticulated // pass a copy back to the main thread. threads.parentPort.postMessage(splines); }); } The first argument to the Worker() constructor is the path to a file of JavaScript code that is to run in the thread. In the preceding code, we used the predefined __filename identifier to create a worker that loads and runs the same file as the main thread. In general, though, you will be passing a file path. Note that if you specify a relative path, it is relative to process.cwd(), not relative to the currently running module. If you want a path relative to the current module, use something like path.resolve(__dirname, ‘workers/reticulator.js’). The Worker() constructor can also accept an object as its second argument, and the properties of this object provide optional configuration for the worker. We’ll cover a number of these options later, but for now note that if you pass {eval: true} as the second argument, then the first argument to Worker() is interpreted as a string of JavaScript code to be evaluated instead of a filename: new threads.Worker(const threads = require(\"worker_threads\"); threads.parentPort.postMessage(threads.isMainThread);, {eval: true}).on(“message”, console.log); // This will print “false” Node makes a copy of the object passed to postMessage() rather than sharing it directly with the worker thread. This prevents the worker thread and the main thread from sharing memory. You might expect that this copying would be done with JSON.stringify() and JSON.parse","date":"2020-11-02","objectID":"/posts/ch16/:11:1","tags":null,"title":"第 16 章 服务器端 JavaScript","uri":"/posts/ch16/"},{"categories":null,"content":"16.11.2 The Worker Execution Environment For the most part, JavaScript code in a Node worker thread runs just like it would in Node’s main thread. There are a few differences that you should be aware of, and some of these differences involve properties of the optional second argument to the Worker() constructor: As we’ve seen, threads.isMainThread is true in the main thread but is always false in any worker thread. In a worker thread, you can use threads.parentPort.postMessage() to send a message to the parent thread and threads.parentPort.on to register event handlers for messages from the parent thread. In the main thread, threads.parentPort is always null. In a worker thread, threads.workerData is set to a copy of the workerData property of the second argument to the Worker() constructor. In the main thread, this property is always null. You can use this workerData property to pass an initial message to the worker that will be available as soon as it starts so that the worker does not have to wait for a “message” event before it can start doing work. By default, process.env in a worker thread is a copy of process.env in the parent thread. But the parent thread can specify a custom set of environment variables by setting the env property of the second argument to the Worker() constructor. As a special (and potentially dangerous) case, the parent thread can set the env property to threads.SHARE_ENV, which will cause the two threads to share a single set of environment variables so that a change in one thread is visible in the other. By default, the process.stdin stream in a worker never has any readable data on it. You can change this default by passing stdin: true in the second argument to the Worker() constructor. If you do that, then the stdin property of the Worker object is a Writable stream. Any data that the parent writes to worker.stdin becomes readable on process.stdin in the worker. By default, the process.stdout and process.stderr streams in the worker are simply piped to the corresponding streams in the parent thread. This means, for example, that console.log() and console.error() produce output in exactly the same way in a worker thread as they do in the main thread. You can override this default by passing stdout:true or stderr:true in the second argument to the Worker() constructor. If you do this, then any output the worker writes to those streams becomes readable by the parent thread on the worker.stdout and worker.stderr threads. (There is a potentially confusing inversion of stream directions here, and we saw the same thing with with child processes earlier in the chapter: the output streams of a worker thread are input streams for the parent thread, and the input stream of a worker is an output stream for the parent.) If a worker thread calls process.exit(), only the thread exits, not the entire process. Worker threads are not allowed to change shared state of the process they are part of. Functions like process.chdir() and process.setuid() will throw exceptions when invoked from a worker. Operating system signals (like SIGINT and SIGTERM) are only delivered to the main thread; they cannot be received or handled in worker threads. ","date":"2020-11-02","objectID":"/posts/ch16/:11:2","tags":null,"title":"第 16 章 服务器端 JavaScript","uri":"/posts/ch16/"},{"categories":null,"content":"16.11.3 Communication Channels and MessagePorts When a new worker thread is created, a communication channel is created along with it that allows messages to be passed back and forth between the worker and the parent thread. As we’ve seen, the worker thread uses threads.parentPort to send and receive messages to and from the parent thread, and the parent thread uses the Worker object to send and receive messages to and from the worker thread. The worker thread API also allows the creation of custom communication channels using the MessageChannel API defined by web browsers and covered in §15.13.5. If you have read that section, much of what follows will sound familiar to you. Suppose a worker needs to handle two different kinds of messages sent by two different modules in the main thread. These two different modules could both share the default channel and send messages with worker.postMessage(), but it would be cleaner if each module has its own private channel for sending messages to the worker. Or consider the case where the main thread creates two independent workers. A custom communication channel can allow the two workers to communicate directly with each other instead of having to send all their messages via the parent. Create a new message channel with the MessageChannel() constructor. A MessageChannel object has two properties, named port1 and port2. These properties refer to a pair of MessagePort objects. Calling postMessage() on one of the ports will cause a “message” event to be generated on the other with a structured clone of the Message object: const threads = require(“worker_threads”); let channel = new threads.MessageChannel(); channel.port2.on(“message”, console.log); // Log any messages we receive channel.port1.postMessage(“hello”); // Will cause “hello” to be printed You can also call close() on either port to break the connection between the two ports and to signal that no more messages will be exchanged. When close() is called on either port, a “close” event is delivered to both ports. Note that the code example above creates a pair of MessagePort objects and then uses those objects to transmit a message within the main thread. In order to use custom communication channels with workers, we must transfer one of the two ports from the thread in which it is created to the thread in which it will be used. The next section explains how to do this. ","date":"2020-11-02","objectID":"/posts/ch16/:11:3","tags":null,"title":"第 16 章 服务器端 JavaScript","uri":"/posts/ch16/"},{"categories":null,"content":"16.11.4 Transferring MessagePorts and Typed Arrays The postMessage() function uses the structured clone algorithm, and as we’ve noted, it cannot copy objects like SSockets and Streams. It can handle MessagePort objects, but only as a special case using a special technique. The postMessage() method (of a Worker object, of threads.parentPort, or of any MessagePort object) takes an optional second argument. This argument (called transferList) is an array of objects that are to be transferred between threads rather than being copied. A MessagePort object cannot be copied by the structured clone algorithm, but it can be transferred. If the first argument to postMessage() has included one or more MessagePorts (nested arbitrarily deeply within the Message object), then those MessagePort objects must also appear as members of the array passed as the second argument. Doing this tells Node that it does not need to make a copy of the MessagePort, and can instead just give the existing object to the other thread. The key thing to understand, however, about transferring values between threads is that once a value is transferred, it can no longer be used in the thread that called postMessage(). Here is how you might create a new MessageChannel and transfer one of its MessagePorts to a worker: // Create a custom communication channel const threads = require(“worker_threads”); let channel = new threads.MessageChannel(); // Use the worker’s default channel to transfer one end of the new // channel to the worker. Assume that when the worker receives this // message it immediately begins to listen for messages on the new channel. worker.postMessage({ command: “changeChannel”, data: channel.port1 }, [ channel.port1 ]); // Now send a message to the worker using our end of the custom channel channel.port2.postMessage(“Can you hear me now?\"); // And listen for responses from the worker as well channel.port2.on(“message”, handleMessagesFromWorker); MessagePort objects are not the only ones that can be transferred. If you call postMessage() with a typed array as the message (or with a message that contains one or more typed arrays nested arbitrarily deep within the message), that typed array (or those typed arrays) will simply be copied by the structured clone algorithm. But typed arrays can be large; for example, if you are using a worker thread to do image processing on millions of pixels. So for efficiency, postMessage() also gives us the option to transfer typed arrays rather than copying them. (Threads share memory by default. Worker threads in JavaScript generally avoid shared memory, but when we allow this kind of controlled transfer, it can be done very efficiently.) What makes this safe is that when a typed array is transferred to another thread, it becomes unusable in the thread that transferred it. In the image-processing scenario, the main thread could transfer the pixels of an image to the worker thread, and then the worker thread could transfer the processed pixels back to the main thread when it was done. The memory would not need to be copied, but it would never be accessible by two threads at once. To transfer a typed array instead of copying it, include the ArrayBuffer that backs the array in the second argument to postMessage(): let pixels = new Uint32Array(1024*1024); // 4 megabytes of memory // Assume we read some data into this typed array, and then transfer the // pixels to a worker without copying. Note that we don’t put the array // itself in the transfer list, but the array’s Buffer object instead. worker.postMessage(pixels, [ pixels.buffer ]); As with transferred MessagePorts, a transferred typed array becomes unusable once transferred. No exceptions are thrown if you attempt to use a MessagePort or typed array that has been transferred; these objects simply stop doing anything when you interact with them. ","date":"2020-11-02","objectID":"/posts/ch16/:11:4","tags":null,"title":"第 16 章 服务器端 JavaScript","uri":"/posts/ch16/"},{"categories":null,"content":"16.11.5 Sharing Typed Arrays Between Threads In addition to transferring typed arrays between threads, it is actually possible to share a typed array between threads. Simply create a SharedArrayBuffer of the desired size and then use that buffer to create a typed array. When a typed array that is backed by a SharedArrayBuffer is passed via postMessage(), the underlying memory will be shared between the threads. You should not include the shared buffer in the second argument to postMessage() in this case. You really should not do this, however, because JavaScript was never designed with thread safety in mind and multithreaded programming is very difficult to get right. (And this is why SharedArrayBuffer was not covered in §11.2: it is a niche feature that is difficult to get right.) Even the simple ++ operator is not thread-safe because it needs to read a value, increment it, and write it back. If two threads are incrementing a value at the same time, it will often only be incremented once, as the following code demonstrates: const threads = require(“worker_threads”); if (threads.isMainThread) { // In the main thread, we create a shared typed array with // one element. Both threads will be able to read and write // sharedArray[0] at the same time. let sharedBuffer = new SharedArrayBuffer(4); let sharedArray = new Int32Array(sharedBuffer); // Now create a worker thread, passing the shared array to it with // as its initial workerData value so we don't have to bother with // sending and receiving a message let worker = new threads.Worker(__filename, { workerData: sharedArray }); // Wait for the worker to start running and then increment the // shared integer 10 million times. worker.on(\"online\", () =\u003e { for(let i = 0; i \u003c 10_000_000; i++) sharedArray[0]++; // Once we're done with our increments, we start listening for // message events so we know when the worker is done. worker.on(\"message\", () =\u003e { // Although the shared integer has been incremented // 20 million times, its value will generally be much less. // On my computer the final value is typically under 12 million. console.log(sharedArray[0]); }); }); } else { // In the worker thread, we get the shared array from workerData // and then increment it 10 million times. let sharedArray = threads.workerData; for(let i = 0; i \u003c 10_000_000; i++) sharedArray[0]++; // When we’re done incrementing, let the main thread know threads.parentPort.postMessage(“done”); } One scenario in which it might be reasonable to use a SharedArrayBuffer is when the two threads operate on entirely separate sections of the shared memory. You might enforce this by creating two typed arrays that serve as views of nonoverlapping regions of the shared buffer, and then have your two threads use those two separate typed arrays. A parallel merge sort could be done like this: one thread sorts the bottom half of an array and the other thread sorts the top half, for example. Or some kinds of image-processing algorithms are also suitable for this approach: multiple threads working on disjoint regions of the image. If you really must allow multiple threads to access the same region of a shared array, you can take one step toward thread safety with the functions defined by the Atomics object. Atomics was added to JavaScript when SharedArrayBuffer was to define atomic operations on the elements of a shared array. For example, the Atomics.add() function reads the specified element of a shared array, adds a specified value to it, and writes the sum back into the array. It does this atomically as if it was a single operation, and ensures that no other thread can read or write the value while the operation is taking place. Atomics.add() allows us to rewrite the parallel increment code we just looked at and get the correct result of 20 million increments of a shared array element: const threads = require(“worker_threads”); if (threads.isMainThread) { let sharedBuffer = new SharedArrayBuffer(4); let sharedArray = new Int3","date":"2020-11-02","objectID":"/posts/ch16/:11:5","tags":null,"title":"第 16 章 服务器端 JavaScript","uri":"/posts/ch16/"},{"categories":null,"content":"16.12 Summary Although JavaScript was created to run in web browsers, Node has made JavaScript into a general-purpose programming language. It is particularly popular for implementing web servers, but its deep bindings to the operating system mean that it is also a good alternative to shell scripts. The most important topics covered in this long chapter include: Node’s asynchronous-by-default APIs and its single-threaded, callback, and event-based style of concurrency. Node’s fundamental datatypes, buffers, and streams. Node’s “fs” and “path” modules for working with the filesystem. Node’s “http” and “https” modules for writing HTTP clients and servers. Node’s “net” module for writing non-HTTP clients and servers. Node’s “child_process” module for creating and communicating with child processes. Node’s “worker_threads” module for true multithreaded programming using message-passing instead of shared memory. 1 Node defines a fs.copyFile() function that you would actually use in practice. 2 It is often cleaner and simpler to define the worker code in a separate file. But this trick of having two threads run different sections of the same file blew my mind when I first encountered it for the Unix fork() system call. And I think it is worth demonstrating this technique simply for its strange elegance. ","date":"2020-11-02","objectID":"/posts/ch16/:12:0","tags":null,"title":"第 16 章 服务器端 JavaScript","uri":"/posts/ch16/"},{"categories":null,"content":"Congratulations on reaching the final chapter of this book. If you have read everything that comes before, you now have a detailed understanding of the JavaScript language and know how to use it in Node and in web browsers. This chapter is a kind of graduation present: it introduces a handful of important programming tools that many JavaScript programmers find useful, and also describes two widely used extensions to the core JavaScript language. Whether or not you choose to use these tools and extensions for your own projects, you are almost certain to see them used in other projects, so it is important to at least know what they are. 恭喜你读到了这本书的最后一章。如果您已经阅读了前面介绍的所有内容，那么您现在对JavaScript语言有了详细的了解，并且知道如何在Node和web浏览器中使用它。这一章是一份毕业礼物:它介绍了许多JavaScript程序员认为有用的重要编程工具，并描述了两个广泛使用的核心JavaScript语言扩展。无论您是否选择在您自己的项目中使用这些工具和扩展，您几乎肯定会在其他项目中看到它们的使用，所以至少知道它们是什么是很重要的。 The tools and language extensions covered in this chapter are: 本章涵盖的工具和语言扩展包括: ESLint for finding potential bugs and style problems in your code. Prettier for formatting your JavaScript code in a standardized way. Jest as an all-in-one solution for writing JavaScript unit tests. npm for managing and installing the software libraries that your program depends on. Code-bundling tools—like webpack, Rollup, and Parcel—that convert your modules of JavaScript code into a single bundle for use on the web. Babel for translating JavaScript code that uses brand-new language features (or that uses language extensions) into JavaScript code that can run in current web browsers. The JSX language extension (used by the React framework) that allows you to describe user interfaces using JavaScript expressions that look like HTML markup. The Flow language extension (or the similar TypeScript extension) that allows you to annotate your JavaScript code with types and check your code for type safety. ESLint用于查找代码中潜在的错误和样式问题。 以标准化的方式格式化你的JavaScript代码更漂亮。 Jest作为编写JavaScript单元测试的一体化解决方案。 npm用于管理和安装您的程序所依赖的软件库。 代码打包工具——如webpack、Rollup和parcels——将JavaScript代码模块转换为一个单独的包，以供web上使用。 Babel，用于将使用全新语言特性(或使用语言扩展)的JavaScript代码转换为可以在当前浏览器中运行的JavaScript代码。 JSX语言扩展(由React框架使用)，它允许您使用看起来像HTML标记的JavaScript表达式来描述用户界面。 流语言扩展(或类似的TypeScript扩展)，允许你用类型注释你的JavaScript代码，并检查你的代码的类型安全。 This chapter does not document these tools and extensions in any comprehensive way. The goal is simply to explain them in enough depth that you can understand why they are useful and when you might want to use them. Everything covered in this chapter is widely used in the JavaScript programming world, and if you do decide to adopt a tool or extension, you’ll find lots of documentation and tutorials online. 本章不以任何全面的方式记录这些工具和扩展。我们的目标仅仅是对它们进行足够深入的解释，以便您能够理解它们为什么有用以及何时需要使用它们。本章所涵盖的所有内容都在JavaScript编程领域得到了广泛的应用，如果您决定采用一种工具或扩展，您将在网上找到大量的文档和教程。 ","date":"2020-11-02","objectID":"/posts/ch17/:0:0","tags":null,"title":"第 17 章 JavaScript 工具和扩展","uri":"/posts/ch17/"},{"categories":null,"content":"17.1 Linting with ESLint In programming, the term lint refers to code that, while technically correct, is unsightly, or a possible bug, or suboptimal in some way. A linter is a tool for detecting lint in your code, and linting is the process of running a linter on your code (and then fixing your code to remove the lint so that the linter no longer complains). 在编程中，术语lint指的是尽管在技术上是正确的，但不美观的代码，或者可能存在bug，或者在某种程度上不是最优的代码。linter是用于检测代码中的linter的工具，linting是在代码上运行linter的过程(然后修改代码以删除linter，使linter不再报错)。 The most commonly used linter for JavaScript today is ESLint. If you run it and then take the time to actually fix the issues it points out, it will make your code cleaner and less likely to have bugs. Consider the following code: 目前JavaScript最常用的linter是ESLint。如果您运行它，然后花时间实际修复它指出的问题，它将使您的代码更干净，并且不太可能出现错误。考虑以下代码: var x = 'unused'; export function factorial(x) { if (x == 1) { return 1; } else { return x * factorial(x-1) } } If you run ESLint on this code, you might get output like this: $ eslint code/ch17/linty.js code/ch17/linty.js 1:1 error Unexpected var, use let or const instead no-var 1:5 error 'x' is assigned a value but never used no-unused-vars 1:9 warning Strings must use doublequote quotes 4:11 error Expected '===' and instead saw '==' eqeqeq 5:1 error Expected indentation of 8 spaces but found 6 indent 7:28 error Missing semicolon semi ✖ 6 problems (5 errors, 1 warning) 3 errors and 1 warning potentially fixable with the `--fix` option. Linters can seem nitpicky sometimes. Does it really matter whether we used double quotes or single quotes for our strings? On the other hand, getting indentation right is important for readability, and using === and let instead of == and var protects you from subtle bugs. And unused variables are dead weight in your code—there is no reason to keep those around. ESLint defines many linting rules and has an ecosystem of plug-ins that add many more. But ESLint is fully configurable, and you can define a configuration file that tunes ESLint to enforce exactly the rules you want and only those rules. ","date":"2020-11-02","objectID":"/posts/ch17/:1:0","tags":null,"title":"第 17 章 JavaScript 工具和扩展","uri":"/posts/ch17/"},{"categories":null,"content":"17.2 JavaScript Formatting with Prettier One of the reasons that some projects use linters is to enforce a consistent coding style so that when a team of programmers is working on a shared codebase, they use compatible code conventions. This includes code indentation rules, but can also include things like what kind of quotation marks are preferred and whether there should be a space between the for keyword and the open parenthesis that follows it. A modern alternative to enforcing code formatting rules via a linter is to adopt a tool like Prettier to automatically parse and reformat all of your code. Suppose you have written the following function, which works, but is formatted unconventionally: function factorial(x) { if(x===1){return 1} else{return x*factorial(x-1)} } Running Prettier on this code fixes the indentation, adds missing semicolons, adds spaces around binary operators and inserts line breaks after { and before }, resulting in much more conventional-looking code: $ prettier factorial.js function factorial(x) { if (x === 1) { return 1; } else { return x * factorial(x - 1); } } If you invoke Prettier with the –write option, it will simply reformat the specified file in place rather than printing a reformatted version. If you use git to manage your source code, you can invoke Prettier with the –write option in a commit hook so that code is automatically formatted before being checked in. Prettier is particularly powerful if you configure your code editor to run it automatically every time you save a file. I find it liberating to write sloppy code and see it fixed automatically for me. Prettier is configurable, but it only has a few options. You can select the maximum line length, the indentation amount, whether semicolons should be used, whether strings should be single- or double-quoted, and a few other things. In general, Prettier’s default options are quite reasonable. The idea is that you just adopt Prettier for your project and then never have to think about code formatting again. Personally, I really like using Prettier on JavaScript projects. I have not used it for the code in this book, however, because in much of my code I rely on careful hand formatting to align my comments vertically, and Prettier messes them up. ","date":"2020-11-02","objectID":"/posts/ch17/:2:0","tags":null,"title":"第 17 章 JavaScript 工具和扩展","uri":"/posts/ch17/"},{"categories":null,"content":"17.3 Unit Testing with Jest Writing tests is an important part of any nontrivial programming project. Dynamic languages like JavaScript support testing frameworks that dramatically reduce the effort required to write tests, and almost make test writing fun! There are a lot of test tools and libraries for JavaScript, and many are written in a modular way so that it is possible to pick one library as your test runner, another library for assertions, and a third for mocking. In this section, however, we’ll describe Jest, which is a popular framework that includes everything you need in a single package. Suppose you’ve written the following function: const getJSON = require(\"./getJSON.js\"); /** * getTemperature() takes the name of a city as its input, and returns * a Promise that will resolve to the current temperature of that city, * in degrees Fahrenheit. It relies on a (fake) web service that returns * world temperatures in degrees Celsius. */ module.exports = async function getTemperature(city) { // Get the temperature in Celsius from the web service let c = await getJSON( `https://globaltemps.example.com/api/city/${city.toLowerCase()}` ); // Convert to Fahrenheit and return that value. return (c * 5 / 9) + 32; // TODO: double-check this formula }; A good set of tests for this function might verify that getTemperature() is fetching the right URL, and that it is converting temperature scales correctly. We can do this with a Jest-based test like the following. This code defines a mock implementation of getJSON() so that the test does not actually make a network request. And because getTemperature() is an async function, the tests are async as well—it can be tricky to test asynchronous functions, but Jest makes it relatively easy: // Import the function we are going to test const getTemperature = require(\"./getTemperature.js\"); // And mock the getJSON() module that getTemperature() depends on jest.mock(\"./getJSON\"); const getJSON = require(\"./getJSON.js\"); // Tell the mock getJSON() function to return an already resolved Promise // with fulfillment value 0. getJSON.mockResolvedValue(0); // Our set of tests for getTemperature() begins here describe(\"getTemperature()\", () =\u003e { // This is the first test. We're ensuring that getTemperature() calls // getJSON() with the URL that we expect test(\"Invokes the correct API\", async () =\u003e { let expectedURL = \"https://globaltemps.example.com/api/city/vancouver\"; let t = await(getTemperature(\"Vancouver\")); // Jest mocks remember how they were called, and we can check that. expect(getJSON).toHaveBeenCalledWith(expectedURL); }); // This second test verifies that getTemperature() converts // Celsius to Fahrenheit correctly test(\"Converts C to F correctly\", async () =\u003e { getJSON.mockResolvedValue(0); // If getJSON returns 0C expect(await getTemperature(\"x\")).toBe(32); // We expect 32F // 100C should convert to 212F getJSON.mockResolvedValue(100); // If getJSON returns 100C expect(await getTemperature(\"x\")).toBe(212); // We expect 212F }); }); With the test written, we can use the jest command to run it, and we discover that one of our tests fails: $ jest getTemperature FAIL ch17/getTemperature.test.js getTemperature() ✓ Invokes the correct API (4ms) ✕ Converts C to F correctly (3ms) ● getTemperature() › Converts C to F correctly expect(received).toBe(expected) // Object.is equality Expected: 212 Received: 87.55555555555556 29 | // 100C should convert to 212F 30 | getJSON.mockResolvedValue(100); // If getJSON returns 100C \u003e 31 | expect(await getTemperature(\"x\")).toBe(212); // Expect 212F | ^ 32 | }); 33 | }); 34 | at Object.\u003canonymous\u003e (ch17/getTemperature.test.js:31:43) Test Suites: 1 failed, 1 total Tests: 1 failed, 1 passed, 2 total Snapshots: 0 total Time: 1.403s Ran all test suites matching /getTemperature/i. Our getTemperature() implementation is using the wrong formula for converting C to F. It multiplies by 5 and divides by 9 rather than multiplying by 9 and dividing by 5. If we fix the cod","date":"2020-11-02","objectID":"/posts/ch17/:3:0","tags":null,"title":"第 17 章 JavaScript 工具和扩展","uri":"/posts/ch17/"},{"categories":null,"content":"17.4 Package Management with npm In modern software development, it is common for any nontrivial program that you write to depend on third-party software libraries. If you’re writing a web server in Node, for example, you might be using the Express framework. And if you’re creating a user interface to be displayed in a web browser, you might use a frontend framework like React or LitElement or Angular. A package manager makes it easy to find and install third-party packages like these. Just as importantly, a package manager keeps track of what packages your code depends on and saves this information into a file so that when someone else wants to try your program, they can download your code and your list of dependencies, then use their own package manager to install all the third-party packages that your code needs. npm is the package manager that is bundled with Node, and was introduced in §16.1.5. It is just as useful for client-side JavaScript programming as it is for server-side programming with Node, however. If you are trying out someone else’s JavaScript project, then one of the first things you will often do after downloading their code is to type npm install. This reads the dependencies listed in the package.json file and downloads the third-party packages that the project needs and saves them in a node_modules/ directory. You can also type npm install \u003cpackage-name\u003e to install a particular package to your project’s node_modules/ directory: $ npm install express In addition to installing the named package, npm also makes a record of the dependency in the package.json file for the project. Recording dependencies in this way is what allows others to install those dependencies simply by typing npm install. The other kind of dependency is on developer tools that are needed by developers who want to work on your project, but aren’t actually needed to run the code. If a project uses Prettier, for example, to ensure that all of its code is consistently formatted, then Prettier is a “dev dependency,” and you can install and record one of these with –save-dev: $ npm install --save-dev prettier Sometimes you might want to install developer tools globally so that they are accessible anywhere even for code that is not part of a formal project with a package.json file and a node_modules/ directory. For that you can use the -g (for global) option: $ npm install -g eslint jest /usr/local/bin/eslint -\u003e /usr/local/lib/node_modules/eslint/bin/eslint.js /usr/local/bin/jest -\u003e /usr/local/lib/node_modules/jest/bin/jest.js + jest@24.9.0 + eslint@6.7.2 added 653 packages from 414 contributors in 25.596s $ which eslint /usr/local/bin/eslint $ which jest /usr/local/bin/jest In addition to the “install” command, npm supports “uninstall” and “update” commands, which do what their names say. npm also has an interesting “audit” command that you can use to find and fix security vulnerabilities in your dependencies: $ npm audit --fix === npm audit security report === found 0 vulnerabilities in 876354 scanned packages When you install a tool like ESLint locally for a project, the eslint script winds up in ./node_modules/.bin/eslint, which makes the command awkward to run. Fortunately, npm is bundled with a command known as “npx,” which you can use to run locally installed tools with commands like npx eslint or npx jest. (And if you use npx to invoke a tool that has not been installed yet, it will install it for you.) The company behind npm also maintains the https://npmjs.com package repository, which holds hundreds of thousands of open source packages. But you don’t have to use the npm package manager to access this repository of packages. Alternatives include yarn and pnpm. ","date":"2020-11-02","objectID":"/posts/ch17/:4:0","tags":null,"title":"第 17 章 JavaScript 工具和扩展","uri":"/posts/ch17/"},{"categories":null,"content":"17.5 Code Bundling If you are writing a large JavaScript program to run in web browsers, you will probably want to use a code-bundling tool, especially if you use external libraries that are delivered as modules. Web developers have been using ES6 modules (§10.3) for years, since well before the import and export keywords were supported on the web. In order to do this, programmers use a code-bundler tool that starts at the main entry point (or entry points) of the program and follows the tree of import directives to find all modules that the program depends on. It then combines all of those individual module files into a single bundle of JavaScript code and rewrites the import and export directives to make the code work in this new form. The result is a single file of code that can be loaded into a web browser that does not support modules. ES6 modules are nearly universally supported by web browsers today, but web developers still tend to use code bundlers, at least when releasing production code. Developers find that user experience is best when a single medium-sized bundle of code is loaded when a user first visits a website than when many small modules are loaded. NOTE Web performance is a notoriously tricky topic and there are lots of variables to consider, including ongoing improvements by browser vendors, so the only way to be sure of the fastest way to load your code is by testing thoroughly and measuring carefully. Keep in mind that there is one variable that is completely under your control: code size. Less JavaScript code will always load and run faster than more JavaScript code! There are a number of good JavaScript bundler tools available. Commonly used bundlers include webpack, Rollup and Parcel. The basic features of bundlers are more or less the same, and they are differentiated based on how configurable they are or how easy they are to use. Webpack has been around for a long time, has a large ecosystem of plug-ins, is highly configurable, and can support older nonmodule libraries. But it can also be complex and hard to configure. At the other end of the spectrum is Parcel which is intended as a zero-configuration alternative that simply does the right thing. In addition to performing basic bundling, bundler tools can also provide some additional features: Some programs have more than one entry point. A web application with multiple pages, for example, could be written with a different entry point for each page. Bundlers generally allow you to create one bundle per entry point or to create a single bundle that supports multiple entry points. Programs can use import() in its functional form (§10.3.6) instead of its static form to dynamically load modules when they are actually needed rather than statically loading them at program startup time. Doing this is often a good way to improve the startup time for your program. Bundler tools that support import() may be able to produce multiple output bundles: one to load at startup time, and one or more that are loaded dynamically when needed. This can work well if there are only a few calls to import() in your program and they load modules with relatively disjoint sets of dependencies. If the dynamically loaded modules share dependencies then it becomes tricky to figure out how many bundles to produce, and you are likely to have to manually configure your bundler to sort this out. Bundlers can generally output a source map file that defines a mapping between the lines of code in the bundle and the corresponding lines in the original source files. This allows browser developer tools to automatically display JavaScript errors at their original unbundled locations. Sometimes when you import a module into your program, you only use a few of its features. A good bundler tool can analyze the code to determine which parts are unused and can be omitted from the bundles. This feature goes by the whimsical name of “tree-shaking.” Bundlers typically have a plug-in–based architect","date":"2020-11-02","objectID":"/posts/ch17/:5:0","tags":null,"title":"第 17 章 JavaScript 工具和扩展","uri":"/posts/ch17/"},{"categories":null,"content":"17.6 Transpilation with Babel Babel is a tool that compiles JavaScript written using modern language features into JavaScript that does not use those modern language features. Because it compiles JavaScript to JavaScript, Babel is sometimes called a “transpiler.” Babel was created so that web developers could use the new language features of ES6 and later while still targeting web browsers that only supported ES5. Language features such as the ** exponentiation operator and arrow functions can be transformed relatively easily into Math.pow() and function expressions. Other language features, such as the class keyword, require much more complex transformations, and, in general, the code output by Babel is not meant to be human readable. Like bundler tools, however, Babel can produce source maps that map transformed code locations back to their original source locations, and this helps dramatically when working with transformed code. Browser vendors are doing a better job of keeping up with the evolution of the JavaScript language, and there is much less need today to compile away arrow functions and class declarations. Babel can still help when you want to use the very latest features like underscore separators in numeric literals. Like most of the other tools described in this chapter, you can install Babel with npm and run it with npx. Babel reads a .babelrc configuration file that tells it how you would like your JavaScript code transformed. Babel defines “presets” that you can choose from depending on which language extensions you want to use and how aggressively you want to transform standard language features. One of Babel’s interesting presets is for code compression by minification (stripping comments and whitespace, renaming variables, and so on). If you use Babel and a code-bundling tool, you may be able to set up the code bundler to automatically run Babel on your JavaScript files as it builds the bundle for you. If so, this can be a convenient option because it simplifies the process of producing runnable code. Webpack, for example, supports a “babel-loader” module that you can install and configure to run Babel on each JavaScript module as it is bundled up. Even though there is less need to transform the core JavaScript language today, Babel is still commonly used to support nonstandard extensions to the language, and we’ll describe two of these language extensions in the sections that follow. ","date":"2020-11-02","objectID":"/posts/ch17/:6:0","tags":null,"title":"第 17 章 JavaScript 工具和扩展","uri":"/posts/ch17/"},{"categories":null,"content":"17.7 JSX: Markup Expressions in JavaScript JSX is an extension to core JavaScript that uses HTML-style syntax to define a tree of elements. JSX is most closely associated with the React framework for user interfaces on the web. In React, the trees of elements defined with JSX are ultimately rendered into a web browser as HTML. Even if you have no plans to use React yourself, its popularity means that you are likely to see code that uses JSX. This section explains what you need to know to make sense of of it. (This section is about the JSX language extension, not about React, and it explains only enough of React to provide context for the JSX syntax.) You can think of a JSX element as a new type of JavaScript expression syntax. JavaScript string literals are delimited with quotation marks, and regular expression literals are delimited with slashes. In the same way, JSX expression literals are delimited with angle brackets. Here is a very simple one: let line = \u003chr/\u003e; If you use JSX, you will need to use Babel (or a similar tool) to compile JSX expressions into regular JavaScript. The transformation is simple enough that some developers choose to use React without using JSX. Babel transforms the JSX expression in this assignment statement into a simple function call: let line = React.createElement(\"hr\", null); JSX syntax is HTML-like, and like HTML elements, React elements can have attributes like these: let image = \u003cimg src=\"logo.png\" alt=\"The JSX logo\" hidden/\u003e; When an element has one or more attributes, they become properties of an object passed as the second argument to createElement(): let image = React.createElement(\"img\", { src: \"logo.png\", alt: \"The JSX logo\", hidden: true }); Like HTML elements, JSX elements can have strings and other elements as children. Just as JavaScript’s arithmetic operators can be used to write arithmetic expressions of arbitrary complexity, JSX elements can also be nested arbitrarily deeply to create trees of elements: let sidebar = ( \u003cdiv className=\"sidebar\"\u003e \u003ch1\u003eTitle\u003c/h1\u003e \u003chr/\u003e \u003cp\u003eThis is the sidebar content\u003c/p\u003e \u003c/div\u003e ); Regular JavaScript function call expressions can also be nested arbitrarily deeply, and these nested JSX expressions translate into a set of nested createElement() calls. When an JSX element has children, those children (which are typically strings and other JSX elements) are passed as the third and subsequent arguments: let sidebar = React.createElement( \"div\", { className: \"sidebar\"}, // This outer call creates a \u003cdiv\u003e React.createElement(\"h1\", null, // This is the first child of the \u003cdiv/\u003e \"Title\"), // and its own first child. React.createElement(\"hr\", null), // The second child of the \u003cdiv/\u003e. React.createElement(\"p\", null, // And the third child. \"This is the sidebar content\")); The value returned by React.createElement() is an ordinary JavaScript object that is used by React to render output in a browser window. Since this section is about the JSX syntax and not about React, we’re not going to go into any detail about the returned Element objects or the rendering process. It is worth noting that you can configure Babel to compile JSX elements to invocations of a different function, so if you think that JSX syntax would be a useful way to express other kinds of nested data structures, you can adopt it for your own non-React uses. An important feature of JSX syntax is that you can embed regular JavaScript expressions within JSX expressions. Within a JSX expression, text within curly braces is interpreted as plain JavaScript. These nested expressions are allowed as attribute values and as child elements. For example: function sidebar(className, title, content, drawLine=true) { return ( \u003cdiv className={className}\u003e \u003ch1\u003e{title}\u003c/h1\u003e { drawLine \u0026\u0026 \u003chr/\u003e } \u003cp\u003e{content}\u003c/p\u003e \u003c/div\u003e ); } The sidebar() function returns a JSX element. It takes four arguments that it uses within the JSX element. The curly brace syntax may remind you of template literals that use ${} to include JavaS","date":"2020-11-02","objectID":"/posts/ch17/:7:0","tags":null,"title":"第 17 章 JavaScript 工具和扩展","uri":"/posts/ch17/"},{"categories":null,"content":"17.8 Type Checking with Flow Flow is a language extension that allows you to annotate your JavaScript code with type information, and a tool for checking your JavaScript code (both annotated and unannotated) for type errors. To use Flow, you start writing code using the Flow language extension to add type annotations. Then you run the Flow tool to analyze your code and report type errors. Once you have fixed the errors and are ready to run the code, you use Babel (perhaps automatically as part of the code-bundling process) to strip the Flow type annotations out of your code. (One of the nice things about the Flow language extension is that there isn’t any new syntax that Flow has to compile or transform. You use the Flow language extension to add annotations to the code, and all Babel has to do is to strip those annotations out to return your code to standard JavaScript.) TYPESCRIPT VERSUS FLOW TypeScript is a very popular alternative to Flow. TypeScript is an extension of JavaScript that adds types as well as other language features. The TypeScript compiler “tsc” compiles TypeScript programs into JavaScript programs and in the process analyzes them and reports type errors in much the same the way that Flow does. tsc is not a Babel plugin: it is its own standalone compiler. Simple type annotations in TypeScript are usually written identically to the same annotations in Flow. For more advanced typing, the syntax of the two extensions diverges, but the intent and value of the two extensions is the same. My goal in this section is to explain the benefits of type annotations and static code analysis. I’ll be doing that with examples based on Flow, but everything demonstrated here can also be achieved with TypeScript with relatively simple syntax changes. TypeScript was released in 2012, before ES6, when JavaScript did not have a class keyword or a for/of loop or modules or Promises. Flow is a narrow language extension that adds type annotations to JavaScript and nothing else. TypeScript, by contrast, was very much designed as a new language. As its name implies, adding types to JavaScript is the primary purpose of TypeScript, and it is the reason that people use it today. But types are not the only feature that TypeScript adds to JavaScript: the TypeScript language has enum and namespace keywords that simply do not exist in JavaScript. In 2020, TypeScript has better integration with IDEs and code editors (particularly VSCode, which, like TypeScript, is from Microsoft) than Flow does. Ultimately, this is a book about JavaScript, and I’m covering Flow here instead of TypeScript because I don’t want to take the focus off of JavaScript. But everything you learn here about adding types to JavaScript will be helpful to you if you decide to adopt TypeScript for your projects. Using Flow requires commitment, but I have found that for medium and large projects, the extra effort is worth it. It takes extra time to add type annotations to your code, to run Flow every time you edit the code, and to fix the type errors it reports. But in return Flow will enforce good coding discipline and will not allow you to cut corners that can lead to bugs. When I have worked on projects that use Flow, I have been impressed by the number of errors it found in my own code. Being able to fix those issues before they became bugs is a great feeling and gives me extra confidence that my code is correct. When I first started using Flow, I found that it was sometimes difficult to understand why it was complaining about my code. With some practice, though, I came to understand its error messages and found that it was usually easy to make minor changes to my code to make it safer and to satisfy Flow.1 I do not recommend using Flow if you still feel like you are learning JavaScript itself. But once you are confident with the language, adding Flow to your JavaScript projects will push you to take your programming skills to the next level. And this, really, is why I’m","date":"2020-11-02","objectID":"/posts/ch17/:8:0","tags":null,"title":"第 17 章 JavaScript 工具和扩展","uri":"/posts/ch17/"},{"categories":null,"content":"17.8.1 Installing and Running Flow Like the other tools described in this chapter, you can install the Flow type-checking tool using a package manager, with a command like npm install -g flow-bin or npm install –save-dev flow-bin. If you install the tool globally with -g, then you can run it with flow. And if you install it locally in your project with –save-dev, then you can run it with npx flow. Before using Flow to do type checking, the first time run it as flow –init in the root directory of your project to create a .flowconfig configuration file. You may never need to add anything to this file, but Flow needs it to know where your project root is. When you run Flow, it will find all the JavaScript source code in your project, but it will only report type errors for the files that have “opted in” to type checking by adding a // @flow comment at the top of the file. This opt-in behavior is important because it means that you can adopt Flow for existing projects and then begin to convert your code one file at a time, without being bothered by errors and warnings on files that have not yet been converted. Flow may be able to find errors in your code even if all you do is opt in with a // @flow comment. Even if you do not use the Flow language extension and add no type annotations to your code, the Flow type checker tool can still make inferences about the values in your program and alert you when you use them inconsistently. Consider the following Flow error message: Error ┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈ variableReassignment.js:6:3 Cannot assign 1 to i.r because: • property r is missing in number [1]. 2│ let i = { r: 0, i: 1 }; // The complex number 0+1i [1] 3│ for(i = 0; i \u003c 10; i++) { // Oops! The loop variable overwrites i 4│ console.log(i); 5│ } 6│ i.r = 1; // Flow detects the error here In this case, we declare the variable i and assign an object to it. Then we use i again as a loop variable, overwriting the object. Flow notices this and flags an error when we try to use i as if it still held an object. (A simple fix would be to write for(let i = 0; making the loop variable local to the loop.) Here is another error that Flow detects even without type annotations: Error ┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈ size.js:3:14 Cannot get x.length because property length is missing in Number [1]. 1│ // @flow 2│ function size(x) { 3│ return x.length; 4│ } [1] 5│ let s = size(1000); Flow sees that the size() function takes a single argument. It doesn’t know the type of that argument, but it can see that the argument is expected to have a length property. When it sees this size() function being called with a numeric argument, it correctly flags this as an error because numbers do not have length properties. ","date":"2020-11-02","objectID":"/posts/ch17/:8:1","tags":null,"title":"第 17 章 JavaScript 工具和扩展","uri":"/posts/ch17/"},{"categories":null,"content":"17.8.2 Using Type Annotations When you declare a JavaScript variable, you can add a Flow type annotation to it by following the variable name with a colon and the type: let message: string = \"Hello world\"; let flag: boolean = false; let n: number = 42; Flow would know the types of these variables even if you did not annotate them: it can see what values you assign to each variable, and it keeps track of that. If you add type annotations, however, Flow knows both the type of the variable and that you have expressed the intent that the variable should always be of that type. So if you use the type annotation, Flow will flag an error if you ever assign a value of a different type to that variable. Type annotations for variables are also particularly useful if you tend to declare all your variables up at the top of a function before they are used. Type annotations for function arguments are like annotations for variables: follow the name of the function argument with a colon and the type name. When annotating a function, you typically also add an annotation for the return type of the function. This goes between the close parenthesis and the open curly brace of the function body. Functions that return nothing use the Flow type void. In the preceding example we defined a size() function that expected an argument with a length property. Here’s how we could change that function to explicitly specify that it expects a string argument and returns a number. Note, Flow now flags an error if we pass an array to the function, even though the function would work in that case: Error ┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈ size2.js:5:18 Cannot call size with array literal bound to s because array literal [1] is incompatible with string [2]. [2] 2│ function size(s: string): number { 3│ return s.length; 4│ } [1] 5│ console.log(size([1,2,3])); Using type annotations with arrow functions is also possible, though it can turn this normally succinct syntax into something more verbose: const size = (s: string): number =\u003e s.length; An important thing to understand about Flow is that the JavaScript value null has the Flow type null and the JavaScript value undefined has the Flow type void. But neither of these values is a member of any other type (unless you explicitly add it). If you declare a function parameter to be a string, then it must be a string, and it is an error to pass null or to pass undefined or to omit the argument (which is basically the same thing as passing undefined): Error ┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈ size3.js:3:18 Cannot call size with null bound to s because null [1] is incompatible with string [2]. 1│ // @flow [2] 2│ const size = (s: string): number =\u003e s.length; [1] 3│ console.log(size(null)); If you want to allow null and undefined as legal values for a variable or function argument, simply prefix the type with a question mark. For example, use ?string or ?number instead of string or number. If we change our size() function to expect an argument of type ?string, then Flow doesn’t complain when we pass null to the function. But it now has something else to complain about: Error ┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈ size4.js:3:14 Cannot get s.length because property length is missing in null or undefined [1]. 1│ // @flow [1] 2│ function size(s: ?string): number { 3│ return s.length; 4│ } 5│ console.log(size(null)); What Flow is telling us here is that it is not safe to write s.length because, at this place in our code, s might be null or undefined, and those values do not have length properties. This is where Flow makes sure we do not cut any corners. If a value might be null, Flow will insist that we check for that case before we do anything that depends on the value not being null. In this case, we can fix the issue by changing the body of the function as follows: function size(s: ?string): number { // At this point in the code, s could be a string or null or undefined. if (s === n","date":"2020-11-02","objectID":"/posts/ch17/:8:2","tags":null,"title":"第 17 章 JavaScript 工具和扩展","uri":"/posts/ch17/"},{"categories":null,"content":"17.8.3 Class Types In addition to the primitive types that Flow knows about, it also knows about all of JavaScript’s built-in classes and allows you to use class name as types. The following function, for example, uses type annotations to indicate that it should be invoked with one Date object and one RegExp object: // @flow // Return true if the ISO representation of the specified date // matches the specified pattern, or false otherwise. // E.g: const isTodayChristmas = dateMatches(new Date(), /^\\d{4}-12-25T/); export function dateMatches(d: Date, p: RegExp): boolean { return p.test(d.toISOString()); } If you define your own classes with the class keyword, those classes automatically become valid Flow types. In order to make this work, however, Flow does require you to use type annotations in the class. In particular, each property of the class must have its type declared. Here is a simple complex number class that demonstrates this: // @flow export default class Complex { // Flow requires an extended class syntax that includes type annotations // for each of the properties used by the class. i: number; r: number; static i: Complex; constructor(r: number, i:number) { // Any properties initialized by the constructor must have Flow type // annotations above. this.r = r; this.i = i; } add(that: Complex) { return new Complex(this.r + that.r, this.i + that.i); } } // This assignment would not be allowed by Flow if there was not a // type annotation for i inside the class. Complex.i = new Complex(0,1); ","date":"2020-11-02","objectID":"/posts/ch17/:8:3","tags":null,"title":"第 17 章 JavaScript 工具和扩展","uri":"/posts/ch17/"},{"categories":null,"content":"17.8.4 Object Types The Flow type to describe an object looks a lot like an object literal, except that property values are replaced by property types. Here, for example, is a function that expects an object with numeric x and y properties: // @flow // Given an object with numeric x and y properties, return the // distance from the origin to the point (x,y) as a number. export default function distance(point: {x:number, y:number}): number { return Math.hypot(point.x, point.y); } In this code, the text {x:number, y:number} is a Flow type, just like string or Date is. As with any type, you can add a question mark at the front to indicate that null and undefined should also be allowed. Within an object type, you can follow any of the property names with a question mark to indicate that that property is optional and may be omitted. For example, you might write the type for an object that represents a 2D or 3D point like this: {x: number, y: number, z?: number} If a property is not marked as optional in an object type, then it is required, and Flow will report an error if an appropriate property is not present in the actual value. Normally, however, Flow tolerates extra properties. If you were to pass an object that had a w property to the distance() function above, Flow would not complain. If you want Flow to strictly enforce that an object does not have properties other than those explicitly declared in its type, you can declare an exact object type by adding vertical bars to the curly braces: {| x: number, y: number |} JavaScript’s objects are sometimes used as dictionaries or string-to-value maps. When used like this, the property names are not known in advance and cannot be declared in a Flow type. If you use objects this way, you can still use Flow to describe the data structure. Suppose that you have an object where the properties are the names of the world’s major cities and the values of those properties are objects that specify the geographical location of those cities. You might declare this data structure like this: // @flow const cityLocations : {[string]: {longitude:number, latitude:number}} = { \"Seattle\": { longitude: 47.6062, latitude: -122.3321 }, // TODO: if there are any other important cities, add them here. }; export default cityLocations; ","date":"2020-11-02","objectID":"/posts/ch17/:8:4","tags":null,"title":"第 17 章 JavaScript 工具和扩展","uri":"/posts/ch17/"},{"categories":null,"content":"17.8.5 Type Aliases Objects can have many properties, and the Flow type that describes such an object will be long and difficult to type. And even relatively short object types can be confusing because they look so much like object literals. Once we get beyond simple types like number and ?string, it is often useful to be able to define names for our Flow types. And in fact, Flow uses the type keyword to do exactly that. Follow the type keyword with an identifier, an equals sign, and a Flow type. Once you’ve done that, the identifier will be an alias for the type. Here, for example, is how we could rewrite the distance() function from the previous section with an explicitly defined Point type: // @flow export type Point = { x: number, y: number }; // Given a Point object return its distance from the origin export default function distance(point: Point): number { return Math.hypot(point.x, point.y); } Note that this code exports the distance() function and also exports the Point type. Other modules can use import type Point from ‘./distance.js’ if they want to use that type definition. Keep in mind, though, that import type is a Flow language extension and not a real JavaScript import directive. Type imports and exports are used by the Flow type checker, but like all other Flow language extensions, they are stripped out of the code before it ever runs. Finally, it is worth noting that instead of defining a name for a Flow object type that represents a point, it would probably be simpler and cleaner to just define a Point class and use that class as the type. ","date":"2020-11-02","objectID":"/posts/ch17/:8:5","tags":null,"title":"第 17 章 JavaScript 工具和扩展","uri":"/posts/ch17/"},{"categories":null,"content":"17.8.6 Array Types The Flow type to describe an array is a compound type that also includes the type of the array elements. Here, for example, is a function that expects an array of numbers, and the error that Flow reports if you try to call the function with an array that has non-numeric elements: Error ┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈ average.js:8:16 Cannot call average with array literal bound to data because string [1] is incompatible with number [2] in array element. [2] 2│ function average(data: Array\u003cnumber\u003e) { 3│ let sum = 0; 4│ for(let x of data) sum += x; 5│ return sum/data.length; 6│ } 7│ [1] 8│ average([1, 2, \"three\"]); The Flow type for an array is Array followed by the element type in angle brackets. You can also express an array type by following the element type with open and close square brackets. So in this example we could have written number[] instead of Array\u003cnumber\u003e. I prefer the angle bracket notation because, as we’ll see, there are other Flow types that use this angle-bracket syntax. The Array type syntax shown works for arrays with an arbitrary number of elements, all of which have the same type. Flow has a different syntax for describing the type of a tuple: an array with a fixed number of elements, each of which may have a different type. To express the type of a tuple, simply write the type of each of its elements, separate them with commas, and enclose them all in square brackets. A function that returns an HTTP status code and message might look like this, for example: function getStatus():[number, string] { return [getStatusCode(), getStatusMessage()]; } Functions that return tuples are awkward to work with unless you use destructuring assignment: let [code, message] = getStatus(); Destructuring assignment, plus Flow’s type-aliasing capabilities, make tuples easy enough to work with that you might consider them as an alternative to classes for simple datatypes: // @flow export type Color = [number, number, number, number]; // [r, g, b, opacity] function gray(level: number): Color { return [level, level, level, 1]; } function fade([r,g,b,a]: Color, factor: number): Color { return [r, g, b, a/factor]; } let [r, g, b, a] = fade(gray(75), 3); Now that we have a way to express the type of an array, let’s return to the size() function from earlier and modify it to expect an array argument instead of a string argument. We want the function to be able to accept an array of any length, so a tuple type is not appropriate. But we don’t want to restrict our function to working only for arrays where all the elements have the same type. The solution is the type Array\u003cmixed\u003e: // @flow function size(s: Array\u003cmixed\u003e): number { return s.length; } console.log(size([1,true,\"three\"])); The element type mixed indicates that the elements of the array can be of any type. If our function actually indexed the array and attempted to use any of those elements, Flow would insist that we use typeof checks or other tests to determine the type of the element before performing any unsafe operation on it. (If you are willing to give up on type checking, you can also use any instead of mixed: it allows you to do whatever you want with the values of the array without ensuring that the values are of the type you expect.) ","date":"2020-11-02","objectID":"/posts/ch17/:8:6","tags":null,"title":"第 17 章 JavaScript 工具和扩展","uri":"/posts/ch17/"},{"categories":null,"content":"17.8.7 Other Parameterized Types We’ve seen that when you annotate a value as an Array, Flow requires you to also specify the type of the array elements inside angle brackets. This additional type is known as a type parameter, and Array is not the only JavaScript class that is parameterized. JavaScript’s Set class is a collection of elements, like an array is, and you can’t use Set as a type by itself, but you have to include a type parameter within angle brackets to specify the type of the values contained in the set. (Though you can use mixed or any if the set may contain values of multiple types.) Here’s an example: // @flow // Return a set of numbers with members that are exactly twice those // of the input set of numbers. function double(s: Set\u003cnumber\u003e): Set\u003cnumber\u003e { let doubled: Set\u003cnumber\u003e = new Set(); for(let n of s) doubled.add(n * 2); return doubled; } console.log(double(new Set([1,2,3]))); // Prints \"Set {2, 4, 6}\" Map is another parameterized type. In this case, there are two type parameters that must be specified; the type of the keys and the types of the values: // @flow import type { Color } from \"./Color.js\"; let colorNames: Map\u003cstring, Color\u003e = new Map([ [\"red\", [1, 0, 0, 1]], [\"green\", [0, 1, 0, 1]], [\"blue\", [0, 0, 1, 1]] ]); Flow lets you define type parameters for your own classes as well. The following code defines a Result class but parameterizes that class with an Error type and a Value type. We use placeholders E and V in the code to represent these type parameters. When the user of this class declares a variable of type Result, they will specify the actual types to substitute for E and V. The variable declaration might look like this: let result: Result\u003cTypeError, Set\u003cstring\u003e\u003e; And here is how the parameterized class is defined: // @flow // This class represents the result of an operation that can either // throw an error of type E or a value of type V. export class Result\u003cE, V\u003e { error: ?E; value: ?V; constructor(error: ?E, value: ?V) { this.error = error; this.value = value; } threw(): ?E { return this.error; } returned(): ?V { return this.value; } get():V { if (this.error) { throw this.error; } else if (this.value === null || this.value === undefined) { throw new TypeError(\"Error and value must not both be null\"); } else { return this.value; } } } And you can even define type parameters for functions: // @flow // Combine the elements of two arrays into an array of pairs function zip\u003cA,B\u003e(a:Array\u003cA\u003e, b:Array\u003cB\u003e): Array\u003c[?A,?B]\u003e { let result:Array\u003c[?A,?B]\u003e = []; let len = Math.max(a.length, b.length); for(let i = 0; i \u003c len; i++) { result.push([a[i], b[i]]); } return result; } // Create the array [[1,'a'], [2,'b'], [3,'c'], [4,undefined]] let pairs: Array\u003c[?number,?string]\u003e = zip([1,2,3,4], ['a','b','c']) ","date":"2020-11-02","objectID":"/posts/ch17/:8:7","tags":null,"title":"第 17 章 JavaScript 工具和扩展","uri":"/posts/ch17/"},{"categories":null,"content":"17.8.8 Read-Only Types Flow defines some special parameterized “utility types” that have names beginning with $. Most of these types have advanced use cases that we are not going to cover here. But two of them are quite useful in practice. If you have an object type T and want to make a read-only version of that type, just write $ReadOnly\u003cT\u003e. Similarly, you can write $ReadOnlyArray\u003cT\u003e to describe a read-only array with elements of type T. The reason to use these types is not because they can offer any guarantee that an object or array can’t be modified (see Object.freeze() in §14.2 if you want true read-only objects) but because it allows you to catch bugs caused by unintentional modifications. If you write a function that takes an object or array argument and does not change any of the object’s properties or the array’s elements, then you can annotate the function parameter with one of Flow’s read-only types. If you do this, then Flow will report an error if you forget and accidentally modify the input value. Here are two examples: // @flow type Point = {x:number, y:number}; // This function takes a Point object but promises not to modify it function distance(p: $ReadOnly\u003cPoint\u003e): number { return Math.hypot(p.x, p.y); } let p: Point = {x:3, y:4}; distance(p) // =\u003e 5 // This function takes an array of numbers that it will not modify function average(data: $ReadOnlyArray\u003cnumber\u003e): number { let sum = 0; for(let i = 0; i \u003c data.length; i++) sum += data[i]; return sum/data.length; } let data: Array\u003cnumber\u003e = [1,2,3,4,5]; average(data) // =\u003e 3 ","date":"2020-11-02","objectID":"/posts/ch17/:8:8","tags":null,"title":"第 17 章 JavaScript 工具和扩展","uri":"/posts/ch17/"},{"categories":null,"content":"17.8.9 Function Types We have seen how to add type annotations to specify the types of a function’s parameters and its return type. But when one of the parameters of a function is itself a function, we need to be able to specify the type of that function parameter. To express the type of a function with Flow, write the types of each parameter, separate them with commas, enclose them in parentheses, and then follow that with an arrow and type return type of the function. Here is an example function that expects to be passed a callback function. Notice how we defined a type alias for the type of the callback function: // @flow // The type of the callback function used in fetchText() below export type FetchTextCallback = (?Error, ?number, ?string) =\u003e void; export default function fetchText(url: string, callback: FetchTextCallback) { let status = null; fetch(url) .then(response =\u003e { status = response.status; return response.text() }) .then(body =\u003e { callback(null, status, body); }) .catch(error =\u003e { callback(error, status, null); }); } ","date":"2020-11-02","objectID":"/posts/ch17/:8:9","tags":null,"title":"第 17 章 JavaScript 工具和扩展","uri":"/posts/ch17/"},{"categories":null,"content":"17.8.10 Union Types Let’s return one more time to the size() function. It doesn’t really make sense to have a function that does nothing other than return the length of an array. Arrays have a perfectly good length property for that. But size() might be useful if it could take any kind of collection object (an array or a Set or a Map) and return the number of elements in the collection. In regular untyped JavaScript it would be easy to write a size() function like that. With Flow, we need a way to express a type that allows arrays, Sets, and Maps, but doesn’t allow values of any other type. Flow calls types like this Union types and allows you to express them by simply listing the desired types and separating them with vertical bar characters: // @flow function size(collection: Array\u003cmixed\u003e|Set\u003cmixed\u003e|Map\u003cmixed,mixed\u003e): number { if (Array.isArray(collection)) { return collection.length; } else { return collection.size; } } size([1,true,\"three\"]) + size(new Set([true,false])) // =\u003e 5 Union types can be read using the word “or”—“an array or a Set or a Map”—so the fact that this Flow syntax uses the same vertical bar character as JavaScript’s OR operators is intentional. We saw earlier that putting a question mark before a type allows null and undefined values. And now you can see that a ? prefix is simply a shortcut for adding a |null|void suffix to a type. In general, when you annotate a value with a Union type, Flow will not allow you to use that value until you’ve done enough tests to figure out what the type of the actual value is. In the size() example we just looked at, we need to explicitly check whether the argument is an array before we try to access the length property of the argument. Note that we do not have to distinguish a Set argument from a Map argument, however: both of those classes define a size property, so the code in the else clause is safe as long as the argument is not an array. ","date":"2020-11-02","objectID":"/posts/ch17/:8:10","tags":null,"title":"第 17 章 JavaScript 工具和扩展","uri":"/posts/ch17/"},{"categories":null,"content":"17.8.11 Enumerated Types and Discriminated Unions Flow allows you to use primitive literals as types that consist of that one single value. If you write let x:3;, then Flow will not allow you to assign any value to that variable other than 3. It is not often useful to define types that have only a single member, but a union of literal types can be useful. You can probably imagine a use for types like these, for example: type Answer = \"yes\" | \"no\"; type Digit = 0|1|2|3|4|5|6|7|8|9; If you use types made up of literals, you need to understand that only literal values are allowed: let a: Answer = \"Yes\".toLowerCase(); // Error: can't assign string to Answer let d: Digit = 3+4; // Error: can't assign number to Digit When Flow checks your types, it does not actually do the calculations: it just checks the types of the calculations. Flow knows that toLowerCase() returns a string and that the + operator on numbers returns a number. Even though we know that both of these calculations return values that are within the type, Flow cannot know that and flags errors on both of these lines. A union type of literal types like Answer and Digit is an example of an enumerated type, or enum. A canonical use case for enum types is to represent the suits of playing cards: type Suit = \"Clubs\" | \"Diamonds\" | \"Hearts\" | \"Spades\"; A more relevant example might be HTTP status codes: type HTTPStatus = | 200 // OK | 304 // Not Modified | 403 // Forbidden | 404; // Not Found One of the pieces of advice that new programmers often hear is to avoid using literals in their code and to instead define symbolic constants to represent those values. One practical reason for this is to avoid the problem of typos: if you misspell a string literal like “Diamonds” JavaScript may never complain but your code may not work right. If you mistype an identifier, on the other hand, JavaScript is likely to throw an error that you’ll notice. With Flow, this advice does not always apply. If you annotate a variable with the type Suit, and then try to assign a misspelled suit to it, Flow will alert you to the error. Another important use for literal types is the creation of discriminated unions. When you work with union types (made up of actually different types, not of literals), you typically have to write code to discriminate among the possible types. In the previous section, we wrote a function that could take an array or a Set or a Map as its argument and had to write code to discriminate array input from Set or Map input. If you want to create a union of Object types, you can make these types easy to discriminate by using a literal type within each of the individual Object types. An example will make this clear. Suppose you’re using a worker thread in Node (§16.11) and are using postMessage() and “message” events for sending object-based messages between the main thread and the worker thread. There are multiple types of messages that the worker might want to send to the main thread, but we’d like to write a Flow Union type that describes all possible messages. Consider this code: // @flow // The worker sends a message of this type when it is done // reticulating the splines we sent it. export type ResultMessage = { messageType: \"result\", result: Array\u003cReticulatedSpline\u003e, // Assume this type is defined elsewhere. }; // The worker sends a message of this type if its code failed with an exception. export type ErrorMessage = { messageType: \"error\", error: Error, }; // The worker sends a message of this type to report usage statistics. export type StatisticsMessage = { messageType: \"stats\", splinesReticulated: number, splinesPerSecond: number }; // When we receive a message from the worker it will be a WorkerMessage. export type WorkerMessage = ResultMessage | ErrorMessage | StatisticsMessage; // The main thread will have an event handler function that is passed // a WorkerMessage. But because we've carefully defined each of the // message types to have a messageType property wit","date":"2020-11-02","objectID":"/posts/ch17/:8:11","tags":null,"title":"第 17 章 JavaScript 工具和扩展","uri":"/posts/ch17/"},{"categories":null,"content":"17.9 Summary JavaScript is the most-used programming language in the world today. It is a living language—one that continues to evolve and improve—surrounded by a flourishing ecosystem of libraries, tools, and extensions. This chapter introduced some of those tools and extensions, but there are many more to learn about. The JavaScript ecosystem flourishes because the JavaScript developer community is active and vibrant, full of peers who share their knowledge through blog posts, videos, and conference presentations. As you close this book and go forth to join this community, you will find no shortage of information sources to keep you engaged with and learning about JavaScript. Best wishes, David Flanagan, March 2020 If you have programmed with Java, you may have experienced something like this the first time you wrote a generic API that used a type parameter. I found the learning process for Flow to be remarkably similar to what I went through in 2004 when generics were added to Java. ","date":"2020-11-02","objectID":"/posts/ch17/:9:0","tags":null,"title":"第 17 章 JavaScript 工具和扩展","uri":"/posts/ch17/"}]